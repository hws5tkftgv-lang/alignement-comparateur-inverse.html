<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement – Comparateur inversé (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.75);
  --ok:#4caf50;
  --bad:#ff5252;
  --accent:#00a2ff;
  --warn:#ffb300;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{ margin:0; background:var(--bg); color:var(--text); font-family:Arial,system-ui,sans-serif; }

header{
  padding:14px 14px 10px;
  text-align:center;
  font-size:18px;
  font-weight:800;
}
.sub{
  text-align:center;
  opacity:.85;
  margin:-6px 0 10px;
  font-size:12px;
}

.wrap{
  padding:0 12px 18px;
  max-width:980px;
  margin:0 auto;
}

.grid{
  display:grid;
  gap:12px;
}
@media (min-width: 860px){
  .grid{ grid-template-columns: 1.05fr 0.95fr; align-items:start; }
}

.card{
  background:var(--card);
  border-radius:14px;
  padding:14px;
}

h2{
  margin:0 0 8px;
  font-size:16px;
}
p{
  margin:6px 0 10px;
  font-size:13px;
  color:var(--muted);
  line-height:1.35;
}

.step{
  border:1px solid rgba(255,255,255,.08);
  border-radius:14px;
  padding:12px;
  margin-top:10px;
  background:rgba(255,255,255,.03);
}
.stepHead{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
}
.stepTitle{
  font-weight:800;
  font-size:14px;
}
.badge{
  font-size:12px;
  font-weight:800;
  padding:4px 8px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
  color:var(--muted);
}
.badge.ok{ background:rgba(76,175,80,.15); color:#bff3c1; }
.badge.bad{ background:rgba(255,82,82,.15); color:#ffc2c2; }
.badge.warn{ background:rgba(255,179,0,.16); color:#ffe6b0; }

.row{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px;
}
.row3{
  display:grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap:8px;
}

label{
  display:block;
  font-size:12px;
  color:var(--muted);
  margin-bottom:4px;
}

input, select{
  width:100%;
  padding:10px 10px;
  font-size:16px;
  border-radius:12px;
  border:none;
  outline:none;
}

.smallNote{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  line-height:1.35;
}

.btnRow{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:10px;
}
button{
  flex:1;
  min-width:140px;
  padding:12px;
  font-size:16px;
  border:none;
  border-radius:12px;
  background:var(--accent);
  color:#fff;
  font-weight:800;
}
button.secondary{
  background:rgba(255,255,255,.12);
}

.hr{
  height:1px;
  background:rgba(255,255,255,.08);
  margin:12px 0;
}

/* ====== CANVAS AREA ====== */
.canvasGrid{
  display:grid;
  gap:12px;
}
@media (min-width: 860px){
  .canvasGrid{
    grid-template-columns: 1fr 1fr;
  }
}
.canvasCard{
  background:#000;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.canvasHeader{
  padding:10px 12px;
  font-size:13px;
  font-weight:800;
  background:rgba(0,0,0,.35);
  color:#eaf1ff;
  border-bottom:1px solid rgba(255,255,255,.08);
}
canvas{
  width:100%;
  height:240px;
  display:block;
  background:#000;
}
@media (min-width: 860px){
  canvas{ height:280px; }
}

.legend{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
}
.dot{
  width:10px;height:10px;border-radius:999px;display:inline-block;margin-right:6px;
}
.dot.motor{ background:#00a2ff; }
.dot.pump{ background:#ff9800; }

.kpi{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px;
  margin-top:10px;
}
.kpi .box{
  padding:10px;
  border-radius:12px;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.08);
}
.kpi b{ color:#cfe2ff; }
.kpi .v{ font-size:14px; font-weight:800; margin-top:4px; }

.mono{
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  font-size:12px;
}
</style>
</head>

<body>
<header>Alignement – Comparateur inversé (mils)</header>
<div class="sub">iPhone-first • 2 vues (dessus + profil) • corrections visibles (exagérées) • pas de blocage d’étapes</div>

<div class="wrap">
  <div class="grid">

    <!-- ===== LEFT: STEPS / INPUTS ===== -->
    <div class="card" id="panelInputs">
      <h2>Entrées & étapes</h2>
      <p>
        Signe standard : <b>+</b> = <b>monte / va à droite</b>, <b>−</b> = <b>descend / va à gauche</b>.
        Les déplacements sont <b>exagérés visuellement</b> pour être perceptibles.
      </p>

      <div class="step" id="step1">
        <div class="stepHead">
          <div class="stepTitle">1) Voilage (runout)</div>
          <div class="badge" id="b1">Info</div>
        </div>
        <p>Entrer le voilage max (mils). (Ce n’est pas bloquant; on indique seulement l’état.)</p>
        <div class="row">
          <div>
            <label>Voilage (mils)</label>
            <input id="runout" type="number" inputmode="decimal" step="0.1" value="0.8">
          </div>
          <div>
            <label>Tolérance voilage (mils)</label>
            <input id="runoutTol" type="number" inputmode="decimal" step="0.1" value="2.0">
          </div>
        </div>
      </div>

      <div class="step" id="step2">
        <div class="stepHead">
          <div class="stepTitle">2) Pied boiteux (soft foot)</div>
          <div class="badge" id="b2">Info</div>
        </div>
        <p>Entrer les 4 lectures (mils) par patte (différence max-min). Le logiciel retient la pire patte.</p>

        <div class="row">
          <div>
            <label>Patte AV-G (mils)</label>
            <input id="sfFL" type="number" inputmode="decimal" step="0.1" value="2.0">
          </div>
          <div>
            <label>Patte AV-D (mils)</label>
            <input id="sfFR" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <div>
            <label>Patte AR-G (mils)</label>
            <input id="sfRL" type="number" inputmode="decimal" step="0.1" value="0.5">
          </div>
          <div>
            <label>Patte AR-D (mils)</label>
            <input id="sfRR" type="number" inputmode="decimal" step="0.1" value="3.5">
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <div>
            <label>Tolérance pied boiteux (mils)</label>
            <input id="sfTol" type="number" inputmode="decimal" step="0.1" value="3.0">
          </div>
          <div>
            <label>Patte affectée</label>
            <select id="sfFoot">
              <option value="auto" selected>Auto (pire patte)</option>
              <option value="FL">AV-G</option>
              <option value="FR">AV-D</option>
              <option value="RL">AR-G</option>
              <option value="RR">AR-D</option>
            </select>
          </div>
        </div>

        <div class="smallNote">
          Astuce : en vrai, on corrige par cales (shims). Ici, la vue de profil montre une patte plus basse pour comprendre l’effet.
        </div>
      </div>

      <div class="step" id="step3">
        <div class="stepHead">
          <div class="stepTitle">3) Angularité verticale</div>
          <div class="badge" id="b3">Info</div>
        </div>
        <p>Entrer l’angularité verticale (mils). (+) = nez du moteur “monte” côté pompe (visuel).</p>
        <div class="row">
          <div>
            <label>Angularité V (mils)</label>
            <input id="angV" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tolérance (mils)</label>
            <input id="angVTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <div class="step" id="step4">
        <div class="stepHead">
          <div class="stepTitle">4) Parallélisme vertical</div>
          <div class="badge" id="b4">Info</div>
        </div>
        <p>Entrer le parallélisme vertical (mils). (+) = moteur “monte” globalement.</p>
        <div class="row">
          <div>
            <label>Parallélisme V (mils)</label>
            <input id="parV" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tolérance (mils)</label>
            <input id="parVTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <div class="step" id="step5">
        <div class="stepHead">
          <div class="stepTitle">5) Angularité horizontale</div>
          <div class="badge" id="b5">Info</div>
        </div>
        <p>Entrer l’angularité horizontale (mils). (+) = nez du moteur “va à droite”.</p>
        <div class="row">
          <div>
            <label>Angularité H (mils)</label>
            <input id="angH" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tolérance (mils)</label>
            <input id="angHTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <div class="step" id="step6">
        <div class="stepHead">
          <div class="stepTitle">6) Parallélisme horizontal</div>
          <div class="badge" id="b6">Info</div>
        </div>
        <p>Entrer le parallélisme horizontal (mils). (+) = moteur “se décale” à droite.</p>
        <div class="row">
          <div>
            <label>Parallélisme H (mils)</label>
            <input id="parH" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tolérance (mils)</label>
            <input id="parHTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <h2>Affichage (pédagogique)</h2>
      <p>Le gain visuel amplifie les mils en pixels pour voir les corrections.</p>
      <div class="row">
        <div>
          <label>Gain visuel (px par mil)</label>
          <input id="gain" type="number" inputmode="decimal" step="1" value="25">
        </div>
        <div>
          <label>Réinitialiser</label>
          <button class="secondary" id="btnReset" type="button">Reset valeurs</button>
        </div>
      </div>

      <div class="kpi">
        <div class="box">
          <b>Résumé vertical</b>
          <div class="v mono" id="kpiV">—</div>
        </div>
        <div class="box">
          <b>Résumé horizontal</b>
          <div class="v mono" id="kpiH">—</div>
        </div>
      </div>

      <div class="legend">
        <div><span class="dot motor"></span>Moteur (mobile)</div>
        <div><span class="dot pump"></span>Pompe (fixe)</div>
      </div>

      <div class="smallNote">
        Les tolérances ici sont des valeurs pédagogiques par défaut. On pourra les ajuster à ta méthode (et plus tard: calculs complets “comparateur inversé”).
      </div>
    </div>

    <!-- ===== RIGHT: CANVAS VIEWS ===== -->
    <div class="card">
      <h2>Vues synchronisées</h2>
      <p>Les deux vues changent en temps réel à chaque modification.</p>

      <div class="canvasGrid">
        <div class="canvasCard">
          <div class="canvasHeader">Vue de dessus (horizontal)</div>
          <canvas id="topView"></canvas>
        </div>
        <div class="canvasCard">
          <div class="canvasHeader">Vue de profil (vertical)</div>
          <canvas id="sideView"></canvas>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
(() => {
  "use strict";

  /* ===================== ÉTAT (mils) ===================== */
  const align = {
    runout: 0.8,
    runoutTol: 2.0,

    sf: { FL:2.0, FR:1.0, RL:0.5, RR:3.5 },
    sfTol: 3.0,
    sfFoot: "auto", // auto|FL|FR|RL|RR

    angV: 0.0,
    angVTol: 1.0,

    parV: 0.0,
    parVTol: 1.0,

    angH: 0.0,
    angHTol: 1.0,

    parH: 0.0,
    parHTol: 1.0,

    gain: 25
  };

  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
  const isNum = (x)=>Number.isFinite(x);

  /* ===================== DOM ===================== */
  const el = (id)=>document.getElementById(id);

  const runout    = el("runout");
  const runoutTol = el("runoutTol");

  const sfFL = el("sfFL");
  const sfFR = el("sfFR");
  const sfRL = el("sfRL");
  const sfRR = el("sfRR");
  const sfTol = el("sfTol");
  const sfFoot = el("sfFoot");

  const angV = el("angV");
  const angVTol = el("angVTol");

  const parV = el("parV");
  const parVTol = el("parVTol");

  const angH = el("angH");
  const angHTol = el("angHTol");

  const parH = el("parH");
  const parHTol = el("parHTol");

  const gain = el("gain");
  const btnReset = el("btnReset");

  const kpiV = el("kpiV");
  const kpiH = el("kpiH");

  const b1 = el("b1");
  const b2 = el("b2");
  const b3 = el("b3");
  const b4 = el("b4");
  const b5 = el("b5");
  const b6 = el("b6");

  const topCanvas = el("topView");
  const topCtx = topCanvas.getContext("2d");

  const sideCanvas = el("sideView");
  const sideCtx = sideCanvas.getContext("2d");

  /* ===================== LECTURE / MAJ ===================== */
  function readFloat(inputEl, fallback){
    const v = parseFloat(inputEl.value);
    return isNum(v) ? v : fallback;
  }

  function syncFromInputs(){
    align.runout = readFloat(runout, align.runout);
    align.runoutTol = Math.max(0, readFloat(runoutTol, align.runoutTol));

    align.sf.FL = Math.abs(readFloat(sfFL, align.sf.FL));
    align.sf.FR = Math.abs(readFloat(sfFR, align.sf.FR));
    align.sf.RL = Math.abs(readFloat(sfRL, align.sf.RL));
    align.sf.RR = Math.abs(readFloat(sfRR, align.sf.RR));

    align.sfTol = Math.max(0, readFloat(sfTol, align.sfTol));
    align.sfFoot = sfFoot.value || "auto";

    align.angV = readFloat(angV, align.angV);
    align.angVTol = Math.max(0, readFloat(angVTol, align.angVTol));

    align.parV = readFloat(parV, align.parV);
    align.parVTol = Math.max(0, readFloat(parVTol, align.parVTol));

    align.angH = readFloat(angH, align.angH);
    align.angHTol = Math.max(0, readFloat(angHTol, align.angHTol));

    align.parH = readFloat(parH, align.parH);
    align.parHTol = Math.max(0, readFloat(parHTol, align.parHTol));

    align.gain = clamp(readFloat(gain, align.gain), 1, 120);
  }

  /* ===================== STATUTS (non bloquant) ===================== */
  function setBadge(badgeEl, kind, txt){
    badgeEl.classList.remove("ok","bad","warn");
    badgeEl.classList.add(kind);
    badgeEl.textContent = txt;
  }

  function computeWorstSoftFoot(){
    const entries = Object.entries(align.sf); // [ [FL,val], ... ]
    entries.sort((a,b)=>b[1]-a[1]);
    return { foot: entries[0][0], val: entries[0][1] };
  }

  function getActiveSoftFoot(){
    if(align.sfFoot && align.sfFoot !== "auto"){
      return { foot: align.sfFoot, val: align.sf[align.sfFoot] ?? 0 };
    }
    return computeWorstSoftFoot();
  }

  function updateBadges(){
    // 1) runout
    const okRunout = Math.abs(align.runout) <= align.runoutTol;
    setBadge(b1, okRunout ? "ok" : "bad", okRunout ? "OK" : "À corriger");

    // 2) soft foot (pire patte ou patte choisie)
    const sf = getActiveSoftFoot();
    const okSF = sf.val <= align.sfTol;
    setBadge(b2, okSF ? "ok" : "bad", okSF ? "OK" : "À corriger");

    // 3) ang V
    const okAngV = Math.abs(align.angV) <= align.angVTol;
    setBadge(b3, okAngV ? "ok" : "bad", okAngV ? "OK" : "À corriger");

    // 4) par V
    const okParV = Math.abs(align.parV) <= align.parVTol;
    setBadge(b4, okParV ? "ok" : "bad", okParV ? "OK" : "À corriger");

    // 5) ang H
    const okAngH = Math.abs(align.angH) <= align.angHTol;
    setBadge(b5, okAngH ? "ok" : "bad", okAngH ? "OK" : "À corriger");

    // 6) par H
    const okParH = Math.abs(align.parH) <= align.parHTol;
    setBadge(b6, okParH ? "ok" : "bad", okParH ? "OK" : "À corriger");

    // KPI text
    const sf2 = getActiveSoftFoot();
    kpiV.textContent =
      `SF ${sf2.foot}=${sf2.val.toFixed(1)} mil | angV=${align.angV.toFixed(1)} | parV=${align.parV.toFixed(1)} | gain=${align.gain.toFixed(0)}`;

    kpiH.textContent =
      `angH=${align.angH.toFixed(1)} | parH=${align.parH.toFixed(1)} | (+)=droite`;
  }

  /* ===================== CANVAS UTILS ===================== */
  function dprNow(){ return Math.min(3, window.devicePixelRatio || 1); }

  function resizeCanvas(c, ctx){
    const dpr = dprNow();
    const w = c.clientWidth || 300;
    const h = c.clientHeight || 240;
    c.width  = Math.round(w * dpr);
    c.height = Math.round(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return { W: w, H: h };
  }

  function clear(ctx, W, H){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);
  }

  function drawGrid(ctx, W, H){
    ctx.strokeStyle="rgba(255,255,255,.06)";
    ctx.lineWidth=1;
    const step = 24;
    for(let x=0; x<=W; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for(let y=0; y<=H; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
  }

  function drawCoupling(ctx, x, y, r){
    ctx.strokeStyle="rgba(255,255,255,.25)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(x,y,r*0.55,0,Math.PI*2); ctx.stroke();
  }

  function drawFoot(ctx, x, y, w, h){
    ctx.fillRect(x, y, w, h);
  }

  /* ===================== RENDU – VUE DESSUS (HORIZONTAL) ===================== */
  function drawTopView(){
    const { W, H } = resizeCanvas(topCanvas, topCtx);
    clear(topCtx, W, H);
    drawGrid(topCtx, W, H);

    // plan
    const midY = H * 0.55;
    const baseX = 40;
    const unitLen = Math.min(150, (W - 120) * 0.45); // longueur machine
    const gap = Math.min(90, (W - 120) * 0.18);

    // pompe (fixe)
    const pumpX = baseX + unitLen + gap;
    const pumpY = midY;
    const pumpW = unitLen;
    const pumpH = 42;

    // moteur (mobile) — base position (à gauche)
    const motorX0 = baseX;
    const motorY0 = midY;
    const motorW = unitLen;
    const motorH = 42;

    // transform moteur selon parH + angH
    const g = align.gain;

    // parH: translation latérale (droite=+)
    const dx = align.parH * g;

    // angH: rotation autour centre (petit angle pédagogique)
    const ang = (align.angH * 0.0025); // radians par mil (tweak pédagogique)

    // dessin pompe
    topCtx.fillStyle="#ff9800";
    topCtx.fillRect(pumpX, pumpY - pumpH/2, pumpW, pumpH);

    // pattes pompe (4)
    topCtx.fillStyle="#d98200";
    const fw=16, fh=8;
    drawFoot(topCtx, pumpX+10,         pumpY - pumpH/2 - fh - 2, fw, fh);
    drawFoot(topCtx, pumpX+pumpW-26,   pumpY - pumpH/2 - fh - 2, fw, fh);
    drawFoot(topCtx, pumpX+10,         pumpY + pumpH/2 + 2,      fw, fh);
    drawFoot(topCtx, pumpX+pumpW-26,   pumpY + pumpH/2 + 2,      fw, fh);

    topCtx.fillStyle="#eaf1ff";
    topCtx.font="12px Arial";
    topCtx.textAlign="center";
    topCtx.fillText("Pompe (fixe)", pumpX + pumpW/2, pumpY - pumpH/2 - 16);

    // dessin moteur avec rotation + translation (autour son centre)
    const cx = motorX0 + motorW/2;
    const cy = motorY0;

    topCtx.save();
    topCtx.translate(cx + dx, cy);
    topCtx.rotate(ang);
    topCtx.translate(-cx, -cy);

    // corps moteur
    topCtx.fillStyle="#00a2ff";
    topCtx.fillRect(motorX0, motorY0 - motorH/2, motorW, motorH);

    // pattes moteur (4)
    topCtx.fillStyle="#0086d6";
    drawFoot(topCtx, motorX0+10,        motorY0 - motorH/2 - fh - 2, fw, fh);
    drawFoot(topCtx, motorX0+motorW-26, motorY0 - motorH/2 - fh - 2, fw, fh);
    drawFoot(topCtx, motorX0+10,        motorY0 + motorH/2 + 2,      fw, fh);
    drawFoot(topCtx, motorX0+motorW-26, motorY0 + motorH/2 + 2,      fw, fh);

    topCtx.fillStyle="#eaf1ff";
    topCtx.font="12px Arial";
    topCtx.textAlign="center";
    topCtx.fillText("Moteur (mobile)", motorX0 + motorW/2, motorY0 - motorH/2 - 16);

    // arbre moteur (ligne)
    topCtx.strokeStyle="rgba(255,255,255,.55)";
    topCtx.lineWidth=3;
    topCtx.beginPath();
    topCtx.moveTo(motorX0+motorW, motorY0);
    topCtx.lineTo(pumpX, pumpY);
    topCtx.stroke();

    // accouplement au milieu du gap
    const coupX = motorX0 + motorW + gap/2;
    const coupY = motorY0;
    drawCoupling(topCtx, coupX, coupY, 12);

    topCtx.restore();

    // note bas
    topCtx.fillStyle="rgba(255,255,255,.75)";
    topCtx.font="12px Arial";
    topCtx.textAlign="left";
    topCtx.fillText(`parH=${align.parH.toFixed(1)} mil, angH=${align.angH.toFixed(1)} mil (visuel exagéré)`, 12, H - 12);
  }

  /* ===================== RENDU – VUE PROFIL (VERTICAL) ===================== */
  function drawSideView(){
    const { W, H } = resizeCanvas(sideCanvas, sideCtx);
    clear(sideCtx, W, H);
    drawGrid(sideCtx, W, H);

    const midY = H * 0.60;
    const baseX = 40;
    const unitLen = Math.min(150, (W - 120) * 0.45);
    const gap = Math.min(90, (W - 120) * 0.18);

    // pompe fixe
    const pumpX = baseX + unitLen + gap;
    const pumpW = unitLen;
    const pumpH = 42;

    // moteur mobile
    const motorX0 = baseX;
    const motorW = unitLen;
    const motorH = 42;

    const g = align.gain;

    // parV: translation verticale (haut = +, donc Y diminue)
    const dy = -align.parV * g;

    // angV: rotation (profil)
    const ang = -(align.angV * 0.0025); // rad par mil (tweak)

    // soft foot: patte affectée est “plus basse” (descend) => +val => patte baisse
    const sf = getActiveSoftFoot();
    const sfDrop = sf.val * g * 0.35; // drop visuel modéré
    const footSel = sf.foot;

    // pompe (fixe)
    const pumpY = midY;
    sideCtx.fillStyle="#ff9800";
    sideCtx.fillRect(pumpX, pumpY - pumpH/2, pumpW, pumpH);

    // pattes pompe (profil = 2 pattes visibles)
    sideCtx.fillStyle="#d98200";
    const fw=20, fh=10;
    // avant
    drawFoot(sideCtx, pumpX+16, pumpY + pumpH/2 + 2, fw, fh);
    // arrière
    drawFoot(sideCtx, pumpX+pumpW-36, pumpY + pumpH/2 + 2, fw, fh);

    sideCtx.fillStyle="#eaf1ff";
    sideCtx.font="12px Arial";
    sideCtx.textAlign="center";
    sideCtx.fillText("Pompe (fixe)", pumpX + pumpW/2, pumpY - pumpH/2 - 16);

    // moteur transformé
    const motorY0 = midY + dy;
    const cx = motorX0 + motorW/2;
    const cy = motorY0;

    sideCtx.save();
    sideCtx.translate(cx, cy);
    sideCtx.rotate(ang);
    sideCtx.translate(-cx, -cy);

    // corps moteur
    sideCtx.fillStyle="#00a2ff";
    sideCtx.fillRect(motorX0, motorY0 - motorH/2, motorW, motorH);

    // pattes moteur (profil=2 pattes visibles) + soft foot drop (si patte AV ou AR)
    sideCtx.fillStyle="#0086d6";
    // avant (FL/FR)
    const frontDrop = (footSel === "FL" || footSel === "FR") ? sfDrop : 0;
    // arrière (RL/RR)
    const rearDrop  = (footSel === "RL" || footSel === "RR") ? sfDrop : 0;

    drawFoot(sideCtx, motorX0+16,         motorY0 + motorH/2 + 2 + frontDrop, fw, fh);
    drawFoot(sideCtx, motorX0+motorW-36,  motorY0 + motorH/2 + 2 + rearDrop,  fw, fh);

    // arbre / ligne centre
    sideCtx.strokeStyle="rgba(255,255,255,.55)";
    sideCtx.lineWidth=3;
    sideCtx.beginPath();
    sideCtx.moveTo(motorX0+motorW, motorY0);
    sideCtx.lineTo(pumpX, pumpY);
    sideCtx.stroke();

    // accouplement
    const coupX = motorX0 + motorW + gap/2;
    const coupY = motorY0;
    drawCoupling(sideCtx, coupX, coupY, 12);

    // label moteur
    sideCtx.fillStyle="#eaf1ff";
    sideCtx.font="12px Arial";
    sideCtx.textAlign="center";
    sideCtx.fillText("Moteur (mobile)", motorX0 + motorW/2, motorY0 - motorH/2 - 16);

    sideCtx.restore();

    // annotation soft foot
    sideCtx.fillStyle="rgba(255,255,255,.80)";
    sideCtx.font="12px Arial";
    sideCtx.textAlign="left";
    sideCtx.fillText(`SF: patte ${sf.foot} = ${sf.val.toFixed(1)} mil (affiché exagéré)`, 12, H - 28);
    sideCtx.fillText(`parV=${align.parV.toFixed(1)} mil, angV=${align.angV.toFixed(1)} mil`, 12, H - 12);
  }

  /* ===================== RENDER GLOBAL ===================== */
  function render(){
    syncFromInputs();
    updateBadges();
    drawTopView();
    drawSideView();
  }

  /* ===================== RESET (valeurs) ===================== */
  function resetValues(){
    runout.value = "0.8";
    runoutTol.value = "2.0";

    sfFL.value = "2.0";
    sfFR.value = "1.0";
    sfRL.value = "0.5";
    sfRR.value = "3.5";
    sfTol.value = "3.0";
    sfFoot.value = "auto";

    angV.value = "0.0";
    angVTol.value = "1.0";

    parV.value = "0.0";
    parVTol.value = "1.0";

    angH.value = "0.0";
    angHTol.value = "1.0";

    parH.value = "0.0";
    parHTol.value = "1.0";

    gain.value = "25";

    render();
  }

  /* ===================== EVENTS ===================== */
  const allInputs = [
    runout, runoutTol,
    sfFL, sfFR, sfRL, sfRR, sfTol, sfFoot,
    angV, angVTol,
    parV, parVTol,
    angH, angHTol,
    parH, parHTol,
    gain
  ];

  allInputs.forEach(x => {
    x.addEventListener("input", render, { passive:true });
    x.addEventListener("change", render, { passive:true });
  });

  btnReset.addEventListener("click", resetValues);

  window.addEventListener("resize", render);
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", render);
  }

  /* ===================== INIT ===================== */
  render();

})();
</script>
</body>
</html>