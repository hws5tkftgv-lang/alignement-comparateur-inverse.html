<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement ‚Äì Comparateur invers√© (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.75);
  --ok:#4caf50;
  --bad:#ff5252;
  --accent:#00a2ff;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:Arial,system-ui,sans-serif;
}

/* ===== HEADER ===== */
.headerBar{
  position:sticky;
  top:0;
  z-index:50;
  background:linear-gradient(to bottom, rgba(11,20,54,.98), rgba(11,20,54,.88));
  border-bottom:1px solid rgba(255,255,255,.08);
  padding:12px;
  text-align:center;
  font-weight:900;
  font-size:16px;
}

/* ===== LAYOUT ===== */
.wrap{
  padding:12px;
  max-width:1100px;
  margin:0 auto;
}
.grid{
  display:grid;
  gap:12px;
}
@media (min-width:900px){
  .grid{ grid-template-columns:1fr 1fr; }
}

/* ===== CARDS ===== */
.card{
  background:var(--card);
  border-radius:14px;
  padding:12px;
  border:1px solid rgba(255,255,255,.06);
}
h2{
  margin:0 0 8px;
  font-size:15px;
}
p{
  margin:6px 0;
  font-size:13px;
  color:var(--muted);
}

/* ===== √âTAPES ===== */
.step{
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:12px;
  background:rgba(255,255,255,.03);
}
.stepHead{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:6px;
}
.stepTitle{
  font-weight:900;
  font-size:14px;
}
.badge{
  font-size:12px;
  font-weight:900;
  padding:4px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
}
.badge.ok{ background:rgba(76,175,80,.15); }
.badge.bad{ background:rgba(255,82,82,.15); }

/* ===== INPUTS ===== */
.row{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
}
@media(max-width:420px){
  .row{ grid-template-columns:1fr; }
}
label{
  font-size:12px;
  color:var(--muted);
}
input{
  width:100%;
  padding:10px;
  font-size:16px;
  border-radius:12px;
  border:none;
}

/* ===== NAV ===== */
.navRow{
  display:flex;
  gap:10px;
  margin-top:10px;
}
button{
  flex:1;
  padding:12px;
  font-size:16px;
  border:none;
  border-radius:12px;
  background:var(--accent);
  color:#fff;
  font-weight:900;
}
button.secondary{
  background:rgba(255,255,255,.15);
}

/* ===== CANVAS ===== */
.canvasGrid{
  display:grid;
  gap:12px;
}
@media(min-width:900px){
  .canvasGrid{ grid-template-columns:1fr 1fr; }
}
.canvasCard{
  background:#000;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.canvasHeader{
  padding:8px 12px;
  font-size:13px;
  font-weight:900;
  background:rgba(0,0,0,.35);
}
/* ===== CANVAS (dessins p√©dagogiques) ===== */
canvas{
  width:100%;
  height:180px;   /* ‚¨ÖÔ∏è r√©duit proportionnellement */
  display:block;
}

@media(min-width:900px){
  canvas{
    height:280px; /* ‚¨ÖÔ∏è r√©duit aussi sur PC */
  }
}

/* ===== INFO ===== */
.infoBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.2);
  font-size:12px;
  white-space:pre-line;
}
/* ===== FORMULES (PC seulement) ===== */
.formulaBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.25);
  font-size:13px;
  font-family:Consolas, monospace;
  line-height:1.45;
  white-space:pre-line;
  display:none; /* cach√© par d√©faut (mobile) */
}
@media (min-width:900px){
  .formulaBox{ display:block; } /* visible PC */
}

.c-blue{ border:2px solid #00a2ff !important; }
.c-green{ border:2px solid #4caf50 !important; }
.c-orange{ border:2px solid #ff9800 !important; }

.noteBox{
  background:rgba(255,255,255,.10);
  border-radius:12px;
  padding:10px 12px;
  font-size:13px;
  color:rgba(234,241,255,.9);
  line-height:1.4;
}

.btnActive{
  background:#00a2ff !important;
  color:white !important;
}
/* =========================
   MODAL AIDE / FORMULES
========================= */
#helpModal{
  position:fixed;
  inset:0;
  z-index:9999;
}

#helpBackdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.65);
}

#helpPanel{
  position:relative;
  width:min(920px, calc(100% - 24px));
  max-height:calc(100% - 24px);
  margin:12px auto;
  background:#0b1436;
  border:1px solid rgba(255,255,255,.12);
  border-radius:14px;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  box-shadow:0 10px 40px rgba(0,0,0,.35);
}

.helpHeader{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  padding:12px;
  background:rgba(255,255,255,.06);
  border-bottom:1px solid rgba(255,255,255,.10);
}

.helpTitle{
  font-weight:900;
  font-size:14px;
}

.helpActions{
  display:flex;
  gap:10px;
}

.helpBtn{
  padding:10px 12px;
  border:none;
  border-radius:10px;
  background:var(--accent);
  color:#fff;
  font-weight:900;
  cursor:pointer;
}

.helpBtn.secondary{
  background:rgba(255,255,255,.15);
}

.helpContent{
  padding:20px;
  overflow:auto;
  font-size:14px;
  line-height:1.6;
  color:#000;
  background:#fff;
  text-align:left;
  max-width:820px;
  margin:auto;
}

/* Titres internes */
.helpContent h3{
  margin:20px 0 10px;
  font-size:16px;
  text-align:center;
  font-weight:900;
}
.helpContent .box{
  border:1px solid #ddd;
  background:#f8f8f8;
  border-radius:10px;
  padding:14px 16px;
  margin:10px 0;
}
.helpContent code{
  font-family:Consolas, monospace;
  background:#eee;
  padding:2px 6px;
  border-radius:4px;
  font-size:13px;
}
  #trainingModal{
  position:fixed;
  inset:0;
  z-index:9998;
}

#trainingBackdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.65);
}


  
/* ==========================
   MODE IMPRESSION ‚Äî PRO
========================== */

@media print {

  body {
    background:#fff !important;
    color:#000 !important;
  }

  body > * {
    display:none !important;
  }

  #helpModal {
    display:block !important;
    position:static !important;
  }

  #helpPanel {
    display:block !important;
    width:100% !important;
    max-width:100% !important;
    box-shadow:none !important;
    background:#fff !important;
    color:#000 !important;
    border-radius:0 !important;
    padding:20px !important;
  }

  #helpBackdrop {
    display:none !important;
  }

  .helpActions {
    display:none !important;
  }

  /* ===== TEXTE ULTRA LISIBLE ===== */

  .helpContent {
    font-size:13.5pt !important;
    line-height:1.45 !important;
    color:#000 !important;
  }

  .helpContent h3 {
    font-size:16pt !important;
    margin-top:20px !important;
    color:#000 !important;
    border-bottom:2px solid #000 !important;
    padding-bottom:4px !important;
  }

  .helpContent .box {
    border:1px solid #000 !important;
    background:#fff !important;
    color:#000 !important;
  }

  .helpContent code {
    background:#eee !important;
    color:#000 !important;
    font-weight:bold !important;
    padding:2px 5px !important;
  }

}

/* ===== FORMULES P√âDAGOGIQUES ===== */
.formula{
  font-family: Consolas, monospace;
  font-size: 14px;
  background: rgba(255,255,255,.12);
  padding: 4px 8px;
  border-radius: 6px;
  font-weight: 600;
  display: inline-block;
}
#trainingModal{
  position:fixed;
  inset:0;
  z-index:9999;
}

#trainingBackdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.65);
}

#trainingPanel{
  position:relative;
  width:min(900px, calc(100% - 24px));
  margin:12px auto;
  background:#0b1436;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.15);
  box-shadow:0 10px 40px rgba(0,0,0,.45);

  display:flex;
  flex-direction:column;

  max-height:90vh;
  overflow:hidden;
}
#trainingPanel{
  padding-bottom: env(safe-area-inset-bottom);
}

#dialBlock{
  margin-top:6px;
  padding:8px;
  background:#0b1436;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.15);
}
@media (max-width:600px){
  #dialBlock{
    padding:8px;
    margin-top:6px;
  }
}
#dialBlock,
#dialBlock *{
  color: #ffffff !important;
}


body.modal-open{
  overflow: hidden;
  position: fixed;
  width: 100%;
}


#trainDial{
  width:100%;
  height:100%;
  background:#000;
  border-radius:50%;
  border:3px solid #666;
}


@media (min-width: 1200px){
  #dialWrap{ max-width:220px; }
}

#dialWrap{
  width:100%;
  max-width:220px;
  aspect-ratio:1 / 1;
  margin:6px auto 4px auto;
  display:flex;
  justify-content:center;
  align-items:center;
}

#trainDial{
  width:100%;
  height:100%;
  display:block;
  background:#000;
  border-radius:50%;
  border:3px solid #666;
}

#dialValue{
  margin-top:4px !important;
  font-size:14px;
}

#trainingExplain{
  margin-top:4px;
  font-size:12px;
  line-height:1.25;
  max-height:60px;
  overflow:hidden;
}

.canvasGrid{
  margin-top:6px !important;
}

/* =====================================================
   TRAINING ‚Äî MOBILE COMPACT (SANS IMPACT GLOBAL)
===================================================== */
@media (max-width: 768px){

  /* On cible UNIQUEMENT le training */
  body.training-on #trainingPanel{
    max-height:100vh;
  }

  /* ======================
     1Ô∏è‚É£ CADRAN
  ====================== */
  body.training-on #dialBlock{
    padding:10px;
  }

  

  body.training-on #dialValue{
    font-size:12px;
  }

  body.training-on #trainingExplain{
    font-size:11px;
    max-height:46px;
  }

  /* ======================
     2Ô∏è‚É£ SLIDER
  ====================== */
  body.training-on input[type="range"]{
    height:22px;
    margin:4px 0;
  }

  body.training-on .rangeLabels{
    font-size:11px;
    margin-top:2px;
  }

  /* ======================
     3Ô∏è‚É£ DESSINS (CANVAS)
  ====================== */
  body.training-on .canvasGrid{
    gap:8px;
  }

  body.training-on .canvasCard{
    padding:0;
  }

  body.training-on canvas{
    height:190px; /* r√©duit mais lisible */
  }

  body.training-on .canvasHeader{
    font-size:11px;
    padding:5px 8px;
  }
}



/* =====================================================
   TRAINING ‚Äî SUPPRESSION DU BLOC INTRO P√âDAGOGIQUE
   (titre + but p√©dagogique)
===================================================== */
#trainingModal h2,
#trainingModal .noteBox{
  display: none !important;
}
/* =====================================================
   TRAINING ‚Äî SUPPRESSION DU TITRE "COMPR√âHENSION DU CADRAN"
===================================================== */

/* Supprime le titre texte dans le contenu du modal */
#trainingModal #trainingPanel h1,
#trainingModal #trainingPanel h2:first-of-type{
  display: none !important;
}



/* =====================================================
   TRAINING ‚Äî SUPPRESSION DU TITRE INTERNE (SOUS LE BANDEAU)
===================================================== */

#trainingModal #trainingPanel .wrap > h2:first-of-type,
#trainingModal #trainingPanel .wrap > .card > h2:first-of-type{
  display: none !important;
}

/* =====================================================
   TRAINING ‚Äî SUPPRESSION DU TITRE
   "Mode entra√Ænement ‚Äî Compr√©hension du cadran"
===================================================== */

#trainingModal #trainingPanel h1,
#trainingModal #trainingPanel h2{
  display: none !important;
}

.trainingOptions{
  display:flex;
  gap:12px;
  align-items:center;
}

.trainingOptions .opt{
  display:flex;
  flex-direction:column;
  font-size:11px;
}

.trainingOptions label{
  font-size:11px;
  opacity:.85;
  margin-bottom:2px;
}

.trainingOptions select{
  font-size:13px;
  padding:6px 8px;
  border-radius:8px;
}


#trainingContent{
  overflow-y:auto;
  flex:1;
  padding-bottom:16px;
}

#trainingControls{
  position:sticky;
  bottom:0;
  background:#0b1436;
  padding:12px 0 16px;
  border-top:1px solid rgba(255,255,255,.15);
}

/* =====================================================
   MODE TEST ‚Äî SLIDERS ULTRA COMPACTS (MOBILE SAFARI)
===================================================== */

@media (max-width: 768px){

  /* Zone compl√®te des contr√¥les TEST */
  #trainingControls{
    padding: 6px 10px !important;
  }

  /* Met les 2 sliders sur UNE SEULE LIGNE */
  #trainingControls .row{
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  /* Labels plus petits */
  #trainingControls label{
    font-size: 11px;
    margin-bottom: 2px;
  }

  /* Sliders beaucoup moins hauts */
  #trainingControls input[type="range"]{
    height: 22px;
    margin: 2px 0;
  }

  /* Bouton reset compact */
  #btnResetTraining{
    margin-top: 6px;
    padding: 8px;
    font-size: 13px;
    border-radius: 10px;
  }
}
/* ===============================
   TRAINING TEST ‚Äî SLIDERS COMPACTS
   =============================== */

#trainingControls{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:10px;
  margin-top:8px;
}

#trainingControls label{
  font-size:11px;
  opacity:.85;
}

#trainingControls input[type="range"]{
  margin:4px 0 0 0;
}

/* Bouton reset centr√© et compact */
#btnResetTraining{
  grid-column:1 / -1;
  margin-top:8px;
  padding:10px;
  font-size:14px;
}

/* iPhone : encore plus compact */
@media (max-width:600px){
  #trainingControls{
    gap:8px;
  }

  #trainingControls label{
    font-size:10.5px;
  }

  #btnResetTraining{
    padding:9px;
    font-size:13px;
  }
}


/* ===============================
   MODE TEST ‚Äî CADRAN COMPACT (iPhone)
   =============================== */
@media (max-width: 600px) {

  #dialBlock{
    transform: scale(0.78);     /* ~22 % plus petit */
    transform-origin: top center;
    margin-top: -20px;          /* remonte visuellement */
    margin-bottom: -30px;       /* r√©cup√®re de la hauteur */
  }

}
/* ===============================
   MODE TEST ‚Äî DESSINS COMPACTS
   =============================== */
@media (max-width: 600px) {

  .visualisation-pedagogique,
  #visualisationPedagogique,
  .pedagoBox{
    transform: scale(0.80);     /* ~20 % plus petit */
    transform-origin: top center;
    margin-top: -15px;
    margin-bottom: -25px;
  }

}

/* ================================
   R√âDUCTION PROPORTIONNELLE BLOCS
   ================================ */




/* ===== NOTE CLIGNOTANTE (parall√©lisme) ===== */
@keyframes blinkNote {
  0%   { opacity: 1; }
  50%  { opacity: 0.50; }
  100% { opacity: 1; }
}

.note-blink{
  animation: blinkNote 3.1s infinite;
  border-left: 4px solid #ff5252;
  padding-left: 10px;
}

/* ============================
   FIX MOBILE ‚Äî SIDE VIEW TROP PETIT
============================ */
#sideView{
  width: 100%;
  min-height: 280px;   /* ‚Üê valeur test√©e, SAFE */
  display: block;
}

/* ===============================
   TRAINING ‚Äî CADRAN (R√àGLE MA√éTRE)
=============================== */

#dialWrap{
  width: 100%;
  max-width: 420px;   /* ‚Üê AJUSTE ICI (420‚Äì480 recommand√©) */
  aspect-ratio: 1 / 1;
  margin: 10px auto;
  display: flex;
  justify-content: center;
  align-items: center;
}

#trainDial{
  width: 100%;
  height: 100%;
  display: block;
}
.toggleGroup{
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 8px;
}

.defectToggle{
  padding: 8px;
  background: #1c2b6a;
  border: 1px solid #2f3f9e;
  color: #eaf1ff;
  border-radius: 6px;
  font-size: 13px;
}

.defectToggle.active{
  background: #00a2ff;
  color: #000;
  font-weight: 600;
}

#topViewTest,
#sideViewTest{
  width: 100%;
  height: 220px;
  display: block;
}



</style>
</head>

<body>

<div class="headerBar">
  <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
    <span>Alignement d‚Äôarbres ‚Äî Comparateur invers√© (mils)</span>

    <button id="btnHelp"
      type="button"
      style="flex:0; padding:6px 10px; border-radius:10px; border:none; background:rgba(255,255,255,.15); color:#fff; font-weight:900; cursor:pointer;">
      ‚ÑπÔ∏è
    </button>
    <button id="btnTraining"
  type="button"
  style="flex:0; padding:6px 12px; border-radius:10px; border:none; background:#4caf50; color:#fff; font-weight:900; cursor:pointer;">
  üéì Training
</button>
  </div>
</div>

<div class="wrap">
  <div class="grid">
    
      <div class="step" id="stepCard">
  <div class="stepHead">
    <div class="stepTitle" id="stepTitle">‚Äî</div>
    <div class="badge" id="stepBadge">Info</div>
  </div>

  <!-- Inputs g√©n√©r√©s par JS selon l'√©tape -->
  <div id="inputsArea"></div>
  <div id="formulaBox" class="formulaBox"></div>

  <div class="navRow">
    <button class="secondary" id="btnPrev" type="button">‚óÄ Pr√©c√©dent</button>
    <button id="btnNext" type="button">Suivant ‚ñ∂</button>
  </div>
<div id="noteBox" class="noteBox" style="margin-top:10px;">
‚Äî
</div>
  <div class="infoBox" id="infoBox">‚Äî</div>
</div>
    </div>

    <!-- ===== DESSINS ===== -->
    <div class="card">
      <h2>Dessins p√©dagogiques</h2>
      <p>
Vue de dessus (horizontal) et vue de profil (vertical).
Les pattes A / B / C / D seront affich√©es ici.
      </p>

      <div class="canvasGrid">
        <div class="canvasCard">
          <div class="canvasHeader">Vue de dessus (TopView)</div>
          <canvas id="topView"></canvas>
        </div>
        <div class="canvasCard">
          <div class="canvasHeader">Vue de profil (SideView)</div>
          <canvas id="sideView"></canvas>
        </div>
      </div>
      
      
      
<!-- =========================
     MODAL AIDE / FORMULES
========================= -->
<div id="helpModal" class="print-scope" style="display:none;">

  <div id="helpBackdrop"></div>

  <div id="helpPanel" role="dialog" aria-modal="true" aria-label="Aide et formules">
    <div class="helpHeader">
      <div class="helpTitle">‚ÑπÔ∏è Guide ‚Äî Formules & Conventions (Alignement)</div>

      <div class="helpActions">
        <button id="btnHelpPrint" type="button" class="helpBtn">üñ®Ô∏è Imprimer</button>
        <button id="btnHelpClose" type="button" class="helpBtn secondary">Fermer ‚úï</button>
      </div>
    </div>

    <div id="helpContent" class="helpContent">
      <!-- inject√© par JS -->
    </div>
  </div>

</div>
  <!-- =========================
     MODAL üéì TRAINING
========================= -->
<div id="trainingModal" style="display:none;">
  <div id="trainingBackdrop"></div>

  <div id="trainingPanel">
    <div class="helpHeader">
    <div class="trainingOptions">
  <div class="opt">
    <label>Montage cadran sur:</label>
    <select id="trainMount">
      <option value="motor">Moteur</option>
      <option value="pump">Pompe</option>
    </select>
  </div>

  
</div>

      <div class="helpActions">
        <button id="btnTrainingClose" type="button" class="helpBtn secondary">
          Fermer ‚úï
        </button>
      </div>
    </div>

    <div id="trainingContent" class="helpContent">
      <!-- inject√© par JS -->
    </div>
    
  </div>
</div>
</div>
<script>
"use strict";
// ===============================
// GLOBALS TRAINING (OBLIGATOIRE)
// ===============================
let trainingMode = false;

let trainMount = "motor";
let dialZeroOffset = 0;

let trainType = "parH";
let trainValue = 0;
let lastSliderValue = 0;
let parallelOffset = 0;   // E = parall√©lisme (3-9)
let angularReading = 0;   // C = angularit√© (12-6)
// ===============================
// R√âGLAGES SLIDER (iPhone SAFE)
// ===============================
const SLIDER_GAIN = 0.20;      // sensibilit√© (0.2 √† 0.4)
const SLIDER_DEADBAND = 0.5;   // zone morte anti micro-bruit iOS
// refs canvases training (s√©curitaire)
window.topCanvasTest = null;
window.sideCanvasTest = null;
window.topCtxTest = null;
window.sideCtxTest = null;
/* =====================================================
   AIDE / FORMULES (BULLE ‚ÑπÔ∏è) + IMPRESSION
===================================================== */
const MATERIAL_COEFF = {
  aluminium: 0.0000124,
  acier:     0.0000063,
  inox:      0.0000095,
  fonte:     0.0000065,
  bronze:    0.0000100
};


function materialOptions(selected){
  return Object.keys(MATERIAL_COEFF)
    .map(key => {
      const label =
        key === "aluminium" ? "Aluminium" :
        key === "acier"     ? "Acier au carbone" :
        key === "inox"      ? "Acier inoxydable" :
        key === "fonte"     ? "Fonte" :
        key === "bronze"    ? "Bronze" :
        key;

      return `<option value="${key}" ${key === selected ? "selected" : ""}>${label}</option>`;
    })
    .join("");
}

// ========================================
// FORMATAGE D‚ÄôAFFICHAGE ‚Äî COEFFICIENT
// (‚ö†Ô∏è affichage seulement, PAS de calcul)
// ========================================
function formatCoefficient(coef){
  if(!Number.isFinite(coef)) return "‚Äî";
  return coef.toFixed(7); // ex: 0.0000124
}


// 1) contenu HTML de la fiche
function buildHelpHTML(){
  // ‚ö†Ô∏è Ici on √©crit LA r√©f√©rence p√©dagogique (une seule source de v√©rit√©)
  return `
  <h3><b>Conventions importantes</b></h3>

<div class="box">
  <b>1) Comparateur invers√© = mesure RELATIVE entre 2 arbres</b><br>
  La lecture au cadran repr√©sente l‚Äô√©cart entre l‚Äôarbre mobile (moteur) et l‚Äôarbre fixe (pompe).<br>
</div>

<div class="box">
  <b>2) Parall√©lisme (12‚Äì6 et 3‚Äì9) : r√®gle CRITIQUE</b><br>
  En parall√©lisme, le comparateur lit le double du d√©placement r√©el, car une seule machine est corrig√©e.<br>
  Correction moteur = Lecture √∑ 2<br>
</div>

<div class="box">
  <b>3) Angularit√©</b><br>
  Les valeurs <b>Avant</b> et <b>Arri√®re</b> sont des valeurs absolues de cale.
  Ensuite, le <b>signe</b> (+ / ‚àí) indique quelle extr√©mit√© est plus haute ou plus basse, et la r√®gle (ajouter / enlever) indique sur quelles pattes appliquer la correction.
</div>


<h3><b>√âtape 1 ‚Äî Voilage (Runout)</b></h3>
<div class="box">
  But : v√©rifier que la rotation est correcte et que la lecture est dans la tol√©rance.<br>
  Condition : Il faut que la valeur mesur√©e soit plus petite que la tol√©rance admissible.
</div>


<h3><b>√âtape 2 ‚Äî Pied boiteux (Soft Foot)</b></h3>
<div class="box">
  M√©thode par diagonales :<br>
  Diag 1 = A (haut gauche) + C (bas droit)<br>
  Diag 2 = B (haut droit) + D (bas gauche)<br><br>
<ul>
Œî = Diag 1 (la plus grande valeur)
  ‚àí Diag 2 (la valeur la plus petite)
</ul>
 <ul> Si r√©sultat = 3 mils et moins = Aucune correction n√©c√©ssaire</ul>
 <ul> Si r√©sultat = 3 mils et plus  = Correction ‚âà 0.8 √ó Œî</ul>
 <ul> On corrige les deux pattes de la diagonale la plus √©lev√©e
  Par patte (2 pattes) = Correction √∑ 2</ul>
</div>


<h3><b>√âtape 3 ‚Äî Mesures g√©om√©triques</b></h3>
<div class="box">
  D = diam√®tre de l‚Äôaccouplement (support) en pouces (po)<br>
  a = distance entre le point de mesure et les pattes AVANT (po)<br>
  b = distance entre les pattes AVANT et les pattes ARRI√àRE (po)
</div>


<h3><b>√âtape 4 ‚Äî Angularit√© verticale (12‚Äì6)</b></h3>
<div class="box">
  Lecture : v = Lecture du cadran 12‚Äì6 (mils)<br><br>

  Formules :<br>
  Avant  = (valeur cadran √∑ D) √ó a<br>
  Arri√®re = (valeur cadran √∑ D) √ó (a + b)<br><br>

  Appliquer ensuite selon le signe (+ / ‚àí) et la r√®gle d‚Äôajout / retrait.
</div>


<h3><b>√âtape 5 ‚Äî Parall√©lisme vertical (12‚Äì6)</b></h3>
<div class="box">
  Lecture : Lecture du cadran 12‚Äì6
  R√®gle : Correction = Valeur mesur√©e √∑ 2<br><br>

  Application : m√™me correction sur les quatre pattes (A + B + C + D), en ajout ou en retrait selon le signe.
</div>


<h3><b>√âtape 6 ‚Äî Angularit√© horizontale (3‚Äì9)</b></h3>
<div class="box">
  Lecture : Lecture du cadran 3‚Äì9 <br><br>

  Formules :<br>
  Avant  = (valeur cadran √∑ D) √ó a<br>
  Arri√®re = (valeur cadran √∑ D) √ó (a + b)<br><br>

  Appliquer selon le signe (+ / ‚àí) sur les bonnes pattes en poussant ou en tirant.
</div>


<h3><b>√âtape 7 ‚Äî Parall√©lisme horizontal (3‚Äì9)</b></h3>
<div class="box">
  Lecture : Lecture du cadran 3-9
  R√®gle : Correction = Valeur mesur√©e √∑ 2<br><br>

  Le d√©placement r√©el du moteur correspond √† la moiti√© de la lecture mesur√©e.
</div>

<h3><b>√âtape 8 ‚Äî Dilatation thermique</b></h3>

<div class="box">
<b>C‚Äôest quoi la dilatation thermique ?</b><br>
Quand une machine est en op√©ration,elle devient plus chaude et un peu plus haute.
Le moteur et la pompe ne chauffent pas pareil et ne sont pas faits du m√™me mat√©riau,
donc ils ne montent pas de la m√™me fa√ßon.
</div>

<div class="box">
<b>De quoi √ßa d√©pend ?</b><br>
La dilatation d√©pend de :
<ul>
  <li>la hauteur de l‚Äôaxe</li>
  <li>le mat√©riau</li>
  <li>la diff√©rence de temp√©rature</li>
</ul>
</div>

<div class="box">
<b>La formule </b><br><br>
<ul>
    <li>H: Hauteur de l'axe</li>
    <li>T1:Temp√©rature op√©ration</li>
    <li>T2:Temp√©rature ambiante</li>
    <li>C: Coefficient</li>
</ul>
<b>H √ó Coef √ó (T1-T2)</b><br><br>
<ul>
   <li>aluminium: 0.0000124</li>
   <li>acier:     0.0000063</li>
   <li>inox:      0.0000095</li>
   <li>fonte:     0.0000065</li>
   <li>bronze:    0.0000100</li>
</ul>
</span>
</div>



<div class="box">
<b>Comment on corrige en vrai ?</b><br>
<ul>
  <li>Si le moteur monte plus que la pompe ‚Üí on enl√®ve des cales √† froid</li>
  <li>Si le moteur monte moins que la pompe ‚Üí on ajoute des cales √† froid</li>
</ul>
</div>

<div class="box">
<b>R√®gle importante √† retenir</b><br>
‚ö†Ô∏è La dilatation thermique :
<ul>
  <li>se calcule APR√àS l‚Äôalignement √† froid</li>
  <li>ne change PAS les lectures au cadran</li>
  <li>sert seulement √† anticiper la position √† chaud</li>
</ul>
</div>
  `;
}

// 2) ouvrir/fermer/imprimer
function openHelp(){
  const modal = document.getElementById("helpModal");
  const content = document.getElementById("helpContent");
  if(!modal || !content) return;

  content.innerHTML = buildHelpHTML();
  modal.style.display = "block";
  document.body.classList.add("modal-open");
}

function closeHelp(){
  const modal = document.getElementById("helpModal");
  if(!modal) return;
  modal.style.display = "none";
  document.body.classList.remove("modal-open");
}

function printHelp(){

  const help = document.getElementById("helpContent");
  if(!help) return;

  // Clone le contenu pour √©viter les styles du site
  const content = help.cloneNode(true);

  // Nouvelle page propre
  const printWindow = window.open('', '', 'width=900,height=700');

  printWindow.document.write(`
    <html>
    <head>
      <title>Guide Alignement</title>

      <style>
        body{
          font-family: Arial, Helvetica, sans-serif;
          padding: 30px;
          background:white;
          color:black;
        }

        h1,h2,h3{
          color:black;
        }

        .box{
          border:1px solid #000;
          border-radius:10px;
          padding:12px;
          margin-bottom:14px;
          page-break-inside: avoid;
        }

        button{ display:none; }
      </style>
    </head>
    <body></body>
    </html>
  `);

  printWindow.document.body.appendChild(content);
  printWindow.document.close();

  // Attendre que le DOM soit rendu (CRUCIAL)
  printWindow.onload = () => {
  setTimeout(() => {
    printWindow.focus();
    printWindow.print();
  }, 300);
};
}

function buildTrainingHTML(){
  return `


<div class="box">
  <b>S√©lection du d√©faut √† observer</b>

  <div class="toggleGroup">
    <button class="defectToggle active" data-defect="parH">Parall√©lisme H</button>
    <button class="defectToggle" data-defect="angH">Angularit√© H</button>
    <button class="defectToggle" data-defect="parV">Parall√©lisme V</button>
    <button class="defectToggle" data-defect="angV">Angularit√© V</button>
  </div>

  <button id="btnResetTraining" style="margin-top:10px;">
    Reset alignement
  </button>
</div>

<!-- =========================
     SLIDER UNIQUE
========================= -->
<div style="margin-top:18px;">
  <input id="trainSlider" type="range" min="-200" max="200" step="1" value="0">

  <!-- =========================
       DOUBLE CADRAN
  ========================== -->
  <div id="dialBlock" style="display:flex; gap:14px; justify-content:center; margin-top:14px;">

    <!-- PARALL√âLISME -->
    <div class="dialCard active" data-dial="parallel">
      <div class="dialTitle">Parall√©lisme</div>

      <canvas id="dialParallel" width="220" height="220"></canvas>

      <div class="dialValue" id="dialParallelValue">0.00 mil</div>

      <button class="zeroDialBtn" data-dial="parallel">
        Z√©ro cadran
      </button>
    </div>

    <!-- ANGULARIT√â -->
    <div class="dialCard" data-dial="angular">
      <div class="dialTitle">Angularit√©</div>

      <canvas id="dialAngular" width="220" height="220"></canvas>

      <div class="dialValue" id="dialAngularValue">0.00 mil</div>

      <button class="zeroDialBtn" data-dial="angular">
        Z√©ro cadran
      </button>
    </div>

  </div>


</div>

<!-- ============================
     VISUALISATION
============================= -->
<div class="card" style="margin-top:16px; border:2px dashed rgba(255,255,255,.25);">

  <div class="canvasGrid">
    <div class="canvasCard">
      <canvas id="topViewTest"></canvas>
    </div>

    <div class="canvasCard">
      <canvas id="sideViewTest"></canvas>
    </div>
  </div>
</div>
<div id="trainingExplain" class="noteBox" style="margin-top:12px;">
‚Äî
</div>
<div id="trainInfo" class="noteBox" style="margin-top:14px;text-align:center;">
‚Äî
</div>
`;
}

/* =====================================================
   TRAINING ‚Äî √âTAPES P√âDAGOGIQUES (IND√âPENDANTES DU COURS)
===================================================== */
let trainingStep = 0;

const TRAINING_STEPS = [
  {
    id: "intro",
    text:
      "Observer la relation entre d√©placement r√©el du moteur et lecture au cadran."
  },
  {
    id: "par",
    text:
      "Parall√©lisme : le comparateur lit DEUX FOIS le d√©placement r√©el (correction = lecture √∑ 2)."
  },
  {
    id: "ang",
    text:
      "Angularity : la lecture d√©pend de l‚Äôinclinaison et du bras de levier."
  },
  {
    id: "invert",
    text:
      "Montage sur la pompe : la lecture du cadran est INVERS√âE."
  }
];

// ===============================
// INIT DES CADRANS TRAINING
// ===============================
let dialParallelCanvas, dialParallelCtx;
let dialAngularCanvas, dialAngularCtx;

function initTrainingDials(){
  // Dessine juste un cadran "0" au bon endroit
  drawDial("dialParallel", 0);
  drawDial("dialAngular", 0);
}
// ===============================
// TRAINING ‚Äî SCROLL LOCK (iOS safe)
// ===============================
let __trainingScrollY = 0;

function trainingLockScroll(){
  __trainingScrollY = window.scrollY || 0;
  document.body.style.position = "fixed";
  document.body.style.top = `-${__trainingScrollY}px`;
  document.body.style.left = "0";
  document.body.style.right = "0";
  document.body.style.width = "100%";
}

function trainingUnlockScroll(){
  document.body.style.position = "";
  document.body.style.top = "";
  document.body.style.left = "";
  document.body.style.right = "";
  document.body.style.width = "";
  window.scrollTo(0, __trainingScrollY);
}

// ===============================
// TRAINING ‚Äî MODAL HEIGHT (visualViewport)
// ===============================
let __trainingResizeRAF = 0;

function trainingResizeModalHeight(){
  const modal = document.getElementById("trainingModal");
  if(!modal) return;

  const vh = (window.visualViewport && window.visualViewport.height)
    ? window.visualViewport.height
    : window.innerHeight;

  modal.style.height = `${Math.round(vh)}px`;
}

function trainingRequestResize(){
  if(__trainingResizeRAF) return;
  __trainingResizeRAF = requestAnimationFrame(() => {
    __trainingResizeRAF = 0;
    trainingResizeModalHeight();
    forceResizeTrainingCanvases();
    drawTrainingViews();
    updateTraining();
  });
}

function trainingAttachResizeListeners(){
  window.addEventListener("resize", trainingRequestResize, { passive:true });
  window.addEventListener("orientationchange", trainingRequestResize, { passive:true });

  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", trainingRequestResize, { passive:true });
    window.visualViewport.addEventListener("scroll", trainingRequestResize, { passive:true });
  }
}

function trainingDetachResizeListeners(){
  window.removeEventListener("resize", trainingRequestResize);
  window.removeEventListener("orientationchange", trainingRequestResize);

  if(window.visualViewport){
    window.visualViewport.removeEventListener("resize", trainingRequestResize);
    window.visualViewport.removeEventListener("scroll", trainingRequestResize);
  }
}



let trainState = {
  angV: 0,
  parV: 0,
  angH: 0,
  parH: 0
};
// ===============================
// Z√âROS IND√âPENDANTS DES CADRANS
// ===============================

let dialState = {
  angular: {
    zero: 0
  },
  parallel: {
    zero: 0
  }
};

// ==========================================
// LECTURE M√âCANIQUE R√âELLE (SOURCE UNIQUE)
// ==========================================
function getMechanicalReading(defect){

  const v = Number(trainState[defect]) || 0;

  // üîπ PARALL√âLISME ‚Üí lecture DOUBLE
  if(defect === "parH" || defect === "parV"){
    return v * 2;
  }

  // üîπ ANGULARIT√â ‚Üí lecture directe
  if(defect === "angH" || defect === "angV"){
    return v;
  }

  return 0;
}
// ===============================
// HELPERS ‚Äî TYPE DE D√âFAUT
// ===============================
function isAngular(defect){
  return defect === "angH" || defect === "angV";
}

function isParallel(defect){
  return defect === "parH" || defect === "parV";
}

let activeDefect = "angV";

let activeDial = "parallel"; // "parallel" ou "angular"

function openTraining(){

  // ===============================
  // ACTIVER MODE TRAINING
  // ===============================
  trainingMode = true;

  const modal   = document.getElementById("trainingModal");
  const content = document.getElementById("trainingContent");
  if(!modal || !content) return;

  content.innerHTML = buildTrainingHTML();

  // ===============================
  // CANVAS TRAINING
  // ===============================
  const tc = document.getElementById("topViewTest");
  const sc = document.getElementById("sideViewTest");

  if(tc && sc){
    window.topCanvasTest  = tc;
    window.sideCanvasTest = sc;
    window.topCtxTest  = tc.getContext("2d");
    window.sideCtxTest = sc.getContext("2d");
  }

  modal.style.display = "block";
  document.body.classList.add("modal-open","training-on");

  trainingLockScroll();
  trainingResizeModalHeight();
  trainingAttachResizeListeners();

  // ===============================
  // UI REFS
  // ===============================
  const slider = document.getElementById("trainSlider");
  const mount  = document.getElementById("trainMount");

  // ===============================
  // √âTAT INITIAL
  // ===============================
  trainMount    = mount?.value || "motor";
  activeDefect  = "parH";
  activeDial    = "parallel";     // ‚¨ÖÔ∏è TR√àS IMPORTANT
  

  if(slider) slider.value = 0;

  // ===============================
  // S√âLECTEURS DE D√âFAUT
  // ===============================
  document.querySelectorAll(".defectToggle").forEach(btn=>{
  btn.addEventListener("click",()=>{
    document.querySelectorAll(".defectToggle")
      .forEach(b=>b.classList.remove("active"));

    btn.classList.add("active");

    activeDefect = btn.dataset.defect;
trainType    = activeDefect;

// optionnel mais logique : s√©lectionner automatiquement le bon cadran
activeDial = (activeDefect.startsWith("par")) ? "parallel" : "angular";

// le slider revient EXACTEMENT √† la valeur d√©j√† stock√©e pour ce d√©faut
// ‚úÖ CORRECT ‚Äî slider neutre
if(slider){
  slider.value = 0;
  lastSliderValue = 0;
}
// met √† jour l'√©tat visuel des cartes cadrans
document.querySelectorAll(".dialCard").forEach(c=>c.classList.remove("active"));
const card = document.querySelector(`.dialCard[data-dial="${activeDial}"]`);
if(card) card.classList.add("active");

updateTraining();
  });
});
  // ===============================
  // S√âLECTION DU CADRAN ACTIF
  // ===============================
  document.querySelectorAll(".dialCard").forEach(card=>{
    card.addEventListener("click",()=>{
      document.querySelectorAll(".dialCard")
        .forEach(c=>c.classList.remove("active"));

      card.classList.add("active");
      activeDial = card.dataset.dial; // "parallel" | "angular"
    });
  });

    // ===============================
  // SLIDER PRINCIPAL
  // ===============================
  // ===============================
// SLIDER PRINCIPAL (AMORTI iPHONE)
// ===============================


if (slider) {
  slider.addEventListener("input", () => {

    const raw = Number(slider.value) || 0;
    const diff = raw - lastSliderValue;
    lastSliderValue = raw;

    // üõë zone morte iOS
    if (Math.abs(diff) < SLIDER_DEADBAND) return;

    // üéöÔ∏è amortissement
    const delta = diff * SLIDER_GAIN;

    // üìå valeur actuelle m√©canique
    const current = Number(trainState[activeDefect]) || 0;
    const next = current + delta;

    // üîí limite M√âCANIQUE R√âELLE
    trainState[activeDefect] = Math.max(-200, Math.min(200, next));

    updateTraining();
  });
}
  // ===============================
  // Z√âRO CADRAN (IND√âPENDANT)
  // ===============================
  document.querySelectorAll(".zeroDialBtn").forEach(btn=>{
  btn.addEventListener("click", () => {

  const dial = btn.dataset.dial;        // "parallel" ou "angular"

  // üîé associer le bon d√©faut m√©canique au cadran
  const defect =
    dial === "parallel"
      ? (activeDefect.startsWith("par") ? activeDefect : null)
      : (activeDefect.startsWith("ang") ? activeDefect : null);

  if (!defect) return;

  // 1Ô∏è‚É£ fixer le z√©ro du cadran √† la position ACTUELLE du dessin
  dialState[dial].zero = getMechanicalReading(defect);

  // 2Ô∏è‚É£ recentrer le slider visuellement
  const slider = document.getElementById("trainSlider");
  if (slider) {
    slider.value = 0;
    lastSliderValue = 0; // üîë OBLIGATOIRE pour √©viter les sauts
  }

  updateTraining();
});
});
  // ===============================
  // RESET ALIGNEMENT
  // ===============================
  const resetBtn = document.getElementById("btnResetTraining");
  if(resetBtn){
    resetBtn.addEventListener("click",()=>{
      trainState.parH = 0;
      trainState.angH = 0;
      trainState.parV = 0;
      trainState.angV = 0;

      dialState.parallel.zero = 0;
      dialState.angular.zero  = 0;

      
      if(slider) slider.value = 0;

      updateTraining();
    });
  }

  // ===============================
  // MONTAGE (MOTEUR / POMPE)
  // ===============================
  if(mount){
    mount.addEventListener("change",()=>{
      trainMount = mount.value;
      updateTraining();
    });
  }

  // ===============================
  // INIT + iPHONE FIX
  // ===============================
  initTrainingDials();
drawTrainingViews();
  requestAnimationFrame(()=>{
    trainingRequestResize();
    updateTraining();
  });

  // Safari iOS : redraw forc√©
  setTimeout(()=>{
    drawDial("dialParallel", 0);
    drawDial("dialAngular", 0);
  },60);
}
function closeTraining(){
  trainingMode = false;

  const modal = document.getElementById("trainingModal");
  if(!modal) return;

  modal.style.display = "none";

  document.body.classList.remove("modal-open");
  document.body.classList.remove("training-on");

  trainingDetachResizeListeners();
  trainingUnlockScroll();
}


function drawDial(canvasId, needleVal){

  const canvas = document.getElementById(canvasId);
  if(!canvas) return;

  const ctx = canvas.getContext("2d");

  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();

  const size = Math.max(200, Math.min(300, rect.width || 240));

  canvas.width  = Math.round(size * dpr);
  canvas.height = Math.round(size * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  const w = size, h = size;
  const cx = w/2, cy = h/2;

  ctx.clearRect(0,0,w,h);

  // fond
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(cx,cy, w*0.48, 0, Math.PI*2);
  ctx.fill();

  // cercle
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 4;
  ctx.stroke();

  // graduations simples
  ctx.save();
  ctx.translate(cx,cy);
  for(let i=0;i<12;i++){
    ctx.rotate(Math.PI*2/12);
    ctx.beginPath();
    ctx.moveTo(0,-w*0.42);
    ctx.lineTo(0,-w*0.48);
    ctx.strokeStyle="#fff";
    ctx.lineWidth=2;
    ctx.stroke();
  }
  ctx.restore();

  // aiguille
  let v = Math.max(-200, Math.min(200, Number(needleVal) || 0));
  const ang = (v / 100) * Math.PI * 2;

  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(ang);
  ctx.strokeStyle="#ff3b30";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(0,10);
  ctx.lineTo(0,-w*0.35);
  ctx.stroke();
  ctx.restore();

  // centre
  ctx.fillStyle="#fff";
  ctx.beginPath();
  ctx.arc(cx,cy,6,0,Math.PI*2);
  ctx.fill();
}



function updateTraining(){
  if(!trainingMode) return;

  // ===============================
  // LECTURE M√âCANIQUE R√âELLE
  // ===============================
  const parDefect = activeDefect.startsWith("par") ? activeDefect : null;
  const angDefect = activeDefect.startsWith("ang") ? activeDefect : null;

  const parRaw = parDefect ? getMechanicalReading(parDefect) : 0;
  const angRaw = angDefect ? getMechanicalReading(angDefect) : 0;

  // ===============================
  // APPLICATION DES Z√âROS
  // ===============================
  const parDisplay = parRaw - (dialState.parallel.zero || 0);
  const angDisplay = angRaw - (dialState.angular.zero || 0);

  // ===============================
  // DESSIN DES CADRANS
  // ===============================
  drawDial("dialParallel", parDisplay);
  drawDial("dialAngular",  angDisplay);

  // ===============================
  // TEXTE SOUS CADRANS
  // ===============================
  const pv = document.getElementById("dialParallelValue");
  const av = document.getElementById("dialAngularValue");

  if(pv) pv.textContent = parDisplay.toFixed(2) + " mil";
  if(av) av.textContent = angDisplay.toFixed(2) + " mil";

  // ===============================
  // DESSINS M√âCANIQUES
  // ===============================
  forceResizeTrainingCanvases();
  drawTrainingViews();

  // ===============================
  // TEXTE P√âDAGOGIQUE
  // ===============================
  const explain = document.getElementById("trainingExplain");
  if(explain){
    explain.innerHTML =
      `<b>D√©faut actif :</b> ${activeDefect}<br>
       Lecture brute : ${parDefect ? parRaw.toFixed(2) : angRaw.toFixed(2)} mil`;
  }
}

/* =====================================================
   MAPPING PATTES (lettres ‚Üî coins)
   Coins = TL (haut-gauche), TR (haut-droite),
           BR (bas-droite), BL (bas-gauche)
===================================================== */
const FOOT_SCHEMES = {
  standard: { name:"Standard (A HG, B HD, C BD, D BG)", TL:"A", TR:"B", BR:"C", BL:"D" },
  invBottom:{ name:"A / B / D / C (inverse bas)",      TL:"A", TR:"B", BR:"D", BL:"C" },
  rot180:   { name:"Rotation 180¬∞",                    TL:"C", TR:"D", BR:"A", BL:"B" },
  roles:    { name:"Par r√¥les (HA, HB, BA, BB)",       TL:"HA",TR:"HB",BR:"BB",BL:"BA" }
};


// mode actif
let footSchemeKey = "standard";






// retourne l'√©tiquette (texte) √† afficher pour un coin
function cornerLabel(corner){
  return FOOT_SCHEMES[footSchemeKey][corner];
}

// retourne la valeur softfoot (mils) pour un coin, peu importe le mode
function sfVal(corner){
  const key = cornerLabel(corner);           // ex: "A" ou "D" ou "HA"
  return Number(state.softFoot[key] || 0);
}
let dialSign = 1;   // +1 = CW normal,  -1 = CW invers√©
let correctionMode = "add";  // "add" | "remove"
let currentView = "top"; // "top" | "side"
let blinkPhase = true;
let visualGain = 6;
const FOOT_NORMAL = "#0070c0";   // bleu fonc√© visible
// ============================
// ORIENTATION / √âTIQUETTES PATTES (affichage seulement)
// ============================
let footLayout = "ABCD";

// mapping: lettre interne -> texte affich√©
const footLabelMap = {
  // Interne : A B C D (A=haut-gauche, B=haut-droite, C=bas-droite, D=bas-gauche)
  "ABCD": { A:"A", B:"B", C:"C", D:"D" },

  // Exemple demand√©: A/B/D/C
  "ABDC": { A:"A", B:"B", C:"D", D:"C" },

  // Rotation 180¬∞ (haut-gauche devient bas-droite, etc.)
  "R180": { A:"C", B:"D", C:"A", D:"B" },

  // Mode r√¥les (HA/HB/BA/BB)
  // HA = Haut Arri√®re, HB = Haut Avant, BA = Bas Arri√®re, BB = Bas Avant
  // ‚ö†Ô∏è Ici, on ASSUME que "haut" = c√¥t√© arbre vers pompe (en haut de ton dessin TopView),
  // et "avant" = c√¥t√© accouplement (√† droite dans ton dessin). Tu peux changer ces mots ensuite.
  "ROLE": { A:"HA", B:"HB", C:"BB", D:"BA" },
};

function labelFoot(letter){
  return footLabelMap[footLayout]?.[letter] || letter;
}

// utilitaire: transforme ["A","C"] en "HA + BA" (ou autre)
function labelFeet(arr){
  return arr.map(labelFoot).join(" + ");
}

const gainSlider = document.getElementById("gainSlider");
if(gainSlider){
  gainSlider.addEventListener("input", () => {
    visualGain = parseFloat(gainSlider.value) || 1;
    drawSideView();
    drawTopView();
  });
}
setInterval(() => {
  blinkPhase = !blinkPhase;

  // ‚ùå ne jamais redessiner TRAINING ici
  if(!trainingMode){
    drawTopView();
    drawSideView();
  }
}, 600);
const GEOM = {
  motorW: 200,
  motorH: 80,

  pumpW: 130,
  pumpH: 80,

  gap: 70,

  shaftH: 12,
  coupH: 56,
  coupW: 10
  };
/* =====================================================
   √âTAT GLOBAL (mils)
===================================================== */
const state = {
  step: 0,
  measureStep: 0,
  
  runout: 0,
  runoutTol: 2,

  softFoot: { A:0, B:0, C:0, D:0, HA:0, HB:0, BA:0, BB:0 },
  softFootTol: 3,
  
  footScheme: "standard",

  angV: 0,
  angVTol: 2,

  parV: 0,
  parVTol: 2,

  angH: 0,
  angHTol: 2,

  parH: 0,
  parHTol: 2,
  
  // üå°Ô∏è Dilatation thermique ‚Äî mod√®le comparatif
tempAmb: 68,

motor: {
  material: "aluminium",
  axisHeight: 6,
  tempOp: 90
},

pump: {
  material: "inox",
  axisHeight: 10,
  tempOp: 200
},
};
/* =====================================================
   PARAM√àTRES G√âOM√âTRIQUES (pouces)
===================================================== */
const geometry = {
  couplingDiameter: 3, // D (po)
  A: 6,                // centre ‚Üí pattes AVANT (po)
  B: 16                // centre ‚Üí pattes ARRI√àRE (po)
};

/* =====================================================
   D√âFINITION DES √âTAPES
===================================================== */
const STEPS = [
  { id:"runout",  label:"1 ‚Äî Voilage" },
  { id:"softfoot",label:"2 ‚Äî Pied boiteux" },
  { id:"measures",label:"3 ‚Äî Mesures g√©om√©triques" },

  { id:"angV",    label:"4 ‚Äî Angularit√© verticale" },
  { id:"parV",    label:"5 ‚Äî Parall√©lisme vertical" },

  { id:"angH",    label:"6 ‚Äî Angularit√© horizontale" },
  { id:"parH",    label:"7 ‚Äî Parall√©lisme horizontal" },

  { id:"thermal", label:"8 ‚Äî Dilatation thermique" }
];
/* =====================================================
   UTILITAIRES
===================================================== */
const abs = Math.abs;
const ok = (v,t) => abs(v) <= t;
function mapFeetByScheme(A, B, C, D, scheme){
  switch(scheme){
    case "standard":
      return { A, B, C, D };

    case "invBottom":   // A / B / D / C
      return { A, B, C: D, D: C };

    case "rot180":      // rotation 180¬∞
      return { A: C, B: D, C: A, D: B };

    case "roles":       // futur (non utilis√© encore)
      return { A, B, C, D };

    default:
      return { A, B, C, D };
  }
}

function updateNote(stepId){
  const note = document.getElementById("noteBox");
  if(!note) return;

  // reset visuel
  note.classList.remove("note-blink");

  switch(stepId){

    case "softfoot":
      note.textContent =
        "Corriger le pied boiteux AVANT tout autre ajustement.";
      break;

    case "angV":
      note.textContent =
        "Angularit√© verticale : correction par ajout ou retrait de cales selon le signe.";
      break;

    case "parV":
      note.textContent =
        "‚ö†Ô∏è Parall√©lisme vertical : En parall√©lisme, le comparateur lit le double du d√©placement r√©el, car une seule machine est corrig√©e. La correction r√©elle √† appliquer est la lecture √∑ 2, r√©partie uniform√©ment sur les 4 pattes (A + B + C + D).";
      note.classList.add("note-blink");
      break;

    case "angH":
      note.textContent =
        "Angularit√© horizontale : correction par d√©placement diff√©rentiel des pattes selon le sens.";
      break;

    case "parH":
      note.textContent =
        "‚ö†Ô∏è Parall√©lisme horizontal : la correction r√©elle du moteur est la lecture √∑ 2 (on corrige une seule machine).";
      note.classList.add("note-blink");
      break;
      
    case "thermal":
      note.textContent =
        "La dilatation thermique se calcule APR√àS l‚Äôalignement √† froid. Elle ne modifie pas les lectures au cadran.";
      break;
      
    default:
      note.textContent = "‚Äî";
  }
}

function mapFeetToCorners(){

  const { A, B, C, D, HA, HB, BA, BB } = state.softFoot;

  const scheme = FOOT_SCHEMES[footSchemeKey];

  return {
    TL: Number(state.softFoot[scheme.TL] || 0),
    TR: Number(state.softFoot[scheme.TR] || 0),
    BR: Number(state.softFoot[scheme.BR] || 0),
    BL: Number(state.softFoot[scheme.BL] || 0)
  };
}
/* =====================================================
   PIED BOITEUX ‚Äî DIAGONALES
   AC vs BD
===================================================== */
function computeSoftFoot(){

  const feet = mapFeetToCorners();

  const diag1 = feet.TL + feet.BR;   // diagonale TL ‚Üî BR
  const diag2 = feet.TR + feet.BL;   // diagonale TR ‚Üî BL

  const delta = Math.abs(diag1 - diag2);
  const correction = delta * 0.8;

  let faulty = null;

  if(diag1 > diag2) faulty = ["TL","BR"];
  if(diag2 > diag1) faulty = ["TR","BL"];

  return {
    diagAC: diag1,
    diagBD: diag2,
    delta,
    correction,
    faulty
  };
}
/* =====================================================
   ANGULARIT√â VERTICALE ‚Äî PAIRES
   Avant = BC
   Arri√®re = AD
===================================================== */



/* =====================================================
   PARALL√âLISME VERTICAL ‚Äî 4 PATTES
===================================================== */
function computeParallelVertical(){
  if(state.parV > 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop bas" };
  }
  if(state.parV < 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop haut" };
  }
  return null;
}
/* =====================================================
   ANGULARIT√â HORIZONTALE ‚Äî TOP VIEW
===================================================== */

/* =====================================================
   PARALL√âLISME HORIZONTAL ‚Äî PAIRES
===================================================== */
/* =====================================================
   ANGULARIT√â VERTICALE ‚Äî PATTES AFFECT√âES
===================================================== */
function computeAngularVertical(){

  const v = state.angV * dialSign;
  if(v === 0) return null;

  // m√™me logique que les corrections p√©dagogiques
  if(v > 0){
    // avant trop haut ‚Üí corriger BC
    return { pair:["B","C"] };
  }else{
    // arri√®re trop haut ‚Üí corriger AD
    return { pair:["A","D"] };
  }
}


/* =====================================================
   ANGULARIT√â HORIZONTALE ‚Äî PATTES AFFECT√âES
===================================================== */
function computeAngularHorizontal(){

  const v = state.angH * dialSign;
  if(v === 0) return null;

  if(v > 0){
    // inclin√© droite
    return { pair:["B","D"] };
  }else{
    // inclin√© gauche
    return { pair:["A","C"] };
  }
}
function computeParallelHorizontal(){
  if(state.parH > 0){
    return {
      pair:["C","D"],
      direction:"Moteur trop √† droite ‚Üí d√©placer vers la GAUCHE"
    };
  }
  if(state.parH < 0){
    return {
      pair:["A","B"],
      direction:"Moteur trop √† gauche ‚Üí d√©placer vers la DROITE"
    };
  }
  return null;
}


function buildThermalStep(){

  const r = calcRelativeThermalShim(
    state.motor,
    state.pump,
    state.tempAmb
  );

  if(!r){
    return "‚ùå Donn√©es invalides pour la dilatation thermique.";
  }

  let msg = "üå°Ô∏è Comparaison de dilatation thermique\n\n";

  msg += "MOTEUR\n";
  msg += `‚Ä¢ Mat√©riau : ${state.motor.material}\n`;
  msg += `‚Ä¢ ŒîH moteur = ${r.motorGrowth.toFixed(2)} mil\n\n`;

  msg += "POMPE\n";
  msg += `‚Ä¢ Mat√©riau : ${state.pump.material}\n`;
  msg += `‚Ä¢ ŒîH pompe = ${r.pumpGrowth.toFixed(2)} mil\n\n`;

  msg += "COMPARAISON\n";
  msg += `ŒîH relatif = ${r.relative.toFixed(2)} mil\n\n`;

  msg += "üîß CORRECTION √Ä FROID\n";

  if(r.action === "ADD"){
    msg += `üëâ Ajouter +${r.shim.toFixed(2)} mil de cales sous le moteur\n\n`;
  }else{
    msg += `üëâ Retirer ${r.shim.toFixed(2)} mil de cales sous le moteur\n\n`;
  }

  msg += "‚ö†Ô∏è NOTE IMPORTANTE :\n";
  msg += "Cette correction ne modifie PAS les lectures au cadran.\n";
  msg += "Elle s‚Äôapplique APR√àS l‚Äôalignement √† froid.\n";

  return msg;
}
/* =====================================================
   CALCUL CORRECTION ANGULAIRE (mils r√©els)
   B √ó C / A
===================================================== */
function computeAngularShimsVertical(){
  const v = state.angV;                // mils
  const D = geometry.couplingDiameter; // po
  const A = geometry.A;                // po (centre‚Üíavant)
  const B = geometry.B;                // po (centre‚Üíarri√®re)

  if(D <= 0) return { front:0, rear:0 };

  const slope = v / D;     // mil/po

  const front = slope * A; // mil
  const rear  = slope * B; // mil  ‚úÖ (PAS A+B)

  return { front, rear };
}

function computeAngularShimsHorizontal(){
  const v = state.angH;                // mils
  const D = geometry.couplingDiameter; // po
  const A = geometry.A;                // po
  const B = geometry.B;                // po

  if(D <= 0) return { front:0, rear:0 };

  const slope = v / D;

  const front = slope * A;
  const rear  = slope * B;

  return { front, rear };
}
/* =====================================================
   VALIDATION PAR √âTAPE
===================================================== */
function isStepOK(stepIndex){
  const id = STEPS[stepIndex].id;

  if(id === "measures"){
  return geometry.couplingDiameter > 0 &&
         geometry.A > 0 &&
         geometry.B > 0;
}

  if(id === "runout")  return ok(state.runout, state.runoutTol);
  if(id === "softfoot")return computeSoftFoot().delta <= state.softFootTol;

  if(id === "angV")    return ok(state.angV, state.angVTol);
  if(id === "parV")    return ok(state.parV, state.parVTol);

  if(id === "angH")    return ok(state.angH, state.angHTol);
  if(id === "parH")    return ok(state.parH, state.parHTol);
  
  if(id === "thermal") return true;
  return true;
}
/* =====================================================
   MESSAGE TEXTE (ZONE INFO)
===================================================== */
function buildMessage(){
  const step = STEPS[state.step];
  let txt = `√âtape ${step.label}\n\n`;

  if(!isStepOK(state.step)){
    txt += "‚ö†Ô∏è Hors tol√©rance\n\n";
  }else{
    txt += "‚úÖ Dans la tol√©rance\n\n";
  }

  if(step.id === "softfoot"){
    const sf = computeSoftFoot();
    txt += `Diag AC = ${sf.diagAC}\n`;
    txt += `Diag BD = ${sf.diagBD}\n`;
    txt += `Œî = ${sf.delta}\n`;
    txt += `Correction ‚âà ${sf.correction}\n`;
    if(sf.faulty){
      txt += `Pattes √† corriger : ${labelFeet(sf.faulty)}`;
    }
  }

  return txt;
}


/* =====================================================
   UI ‚Äî DOM
===================================================== */
const ui = {
  stepTitle: document.getElementById("stepTitle"),
  stepBadge: document.getElementById("stepBadge"),
  inputsArea: document.getElementById("inputsArea"),
  infoBox: document.getElementById("infoBox"),
  btnPrev: document.getElementById("btnPrev"),
  btnNext: document.getElementById("btnNext"),
    formulaBox: document.getElementById("formulaBox"),
};

/* =====================================================
   MESSAGES DE CORRECTION P√âDAGOGIQUES
===================================================== */

function buildCorrectionMessage(){
  const stepId = STEPS[state.step].id;

  // ---------- PIED BOITEUX ----------
  if(stepId === "softfoot"){
    const sf = computeSoftFoot();

    if(sf.delta <= state.softFootTol){
      return "‚úîÔ∏è Pied boiteux corrig√© ‚Äî aucune cale requise.";
    }

    const each = (sf.correction / 2).toFixed(1);

    let msg = "ü¶∂ Pied boiteux\n\n";
    msg += "‚ö†Ô∏è Hors tol√©rance\n\n";
    msg += `Diag AC = ${sf.diagAC}\n`;
    msg += `Diag BD = ${sf.diagBD}\n`;
    msg += `Œî = ${sf.delta}\n`;
    msg += `Correction ‚âà ${sf.correction}\n\n`;

    msg += "üë£ Pied boiteux d√©tect√©\n\n";
    msg += `‚ûï Ajouter +${each} mil sous :\n`;
    msg += `üëâ ${labelFeet(sf.faulty)}\n`;
    msg += "\n‚ö†Ô∏è Toujours corriger en DIAGONALE";

    return msg;
  }

  // ---------- ANGULARIT√â VERTICALE ----------
  if(stepId === "angV"){
    if(ok(state.angV, state.angVTol)){
      return "‚úîÔ∏è Angularit√© verticale conforme.";
    }

    const D = geometry.couplingDiameter;
    const A = geometry.A;
    const B = geometry.B;

    const res = computeAngularShimsVertical();
    const front = res.front;
    const rear  = res.rear;

    const v = state.angV * dialSign;

    let msg = "üìê Angularit√© verticale\n\n";
    msg += "üßÆ Calcul de pente\n";
    msg += `Pente = Lecture / √ò = ${Math.abs(v).toFixed(2)} / ${D}\n\n`;
    msg += "Corrections :\n";
    msg += `Avant  = pente √ó A = ${front} mil\n`;
    msg += `Arri√®re = pente √ó B = ${rear} mil\n\n`;

    if(v > 0){
      msg += "Lecture POSITIVE ‚Üí Avant trop haut\n";
      msg += `‚ûñ Enlever ${front} mil sous ${labelFeet(["B","C"])}\n`;
      msg += "OU\n";
      msg += `‚ûï Ajouter ${rear} mil sous ${labelFeet(["A","D"])}`;
    }else if(v < 0){
      msg += "Lecture N√âGATIVE ‚Üí Arri√®re trop haut\n";
      msg += `‚ûñ Enlever ${rear} mil sous ${labelFeet(["A","D"])}\n`;
      msg += "OU\n";
      msg += `‚ûï Ajouter ${front} mil sous ${labelFeet(["B","C"])}`;
    }

    return msg;
  }

  // ---------- PARALL√âLISME VERTICAL ----------
  if(stepId === "parV"){
    if(ok(state.parV, state.parVTol)){
      return "‚úîÔ∏è Parall√©lisme vertical conforme.";
    }

    const v = state.parV;
    const realMove = Math.abs(v) / 2;

    let msg = "‚¨ÜÔ∏è Parall√©lisme vertical\n\n";
    msg += `Lecture = ${v.toFixed(2)} mil\n`;
    msg += `Correction r√©elle = Lecture √∑ 2 = ${realMove.toFixed(2)} mil\n\n`;

    if(v > 0){
      msg += "Moteur trop bas\n";
      msg += `üëâ Ajouter ${realMove.toFixed(2)} mil sous A+B+C+D`;
    }else{
      msg += "Moteur trop haut\n";
      msg += `üëâ Retirer ${realMove.toFixed(2)} mil sous A+B+C+D`;
    }

    return msg;
  }

  // ---------- ANGULARIT√â HORIZONTALE ----------
  if(stepId === "angH"){
    if(ok(state.angH, state.angHTol)){
      return "‚úîÔ∏è Angularit√© horizontale conforme.";
    }

    const D = geometry.couplingDiameter;

    const res = computeAngularShimsHorizontal();
    const front = res.front;
    const rear  = res.rear;

    const v = state.angH * dialSign;

    let msg = "‚ÜîÔ∏è Angularit√© horizontale\n\n";
    msg += "üßÆ Calcul de pente\n";
    msg += `Pente = Lecture / √ò = ${Math.abs(v).toFixed(2)} / ${D}\n\n`;
    msg += "Corrections :\n";
    msg += `Avant  = ${front} mil\n`;
    msg += `Arri√®re = ${rear} mil\n\n`;

    if(v > 0){
      msg += "Inclin√© vers la droite\n";
      msg += `üëâ Tirer ${labelFeet(["B","D"])}\n`;
      msg += `OU pousser ${labelFeet(["A","C"])}`;
    }else{
      msg += "Inclin√© vers la gauche\n";
      msg += `üëâ Tirer ${labelFeet(["A","C"])}\n`;
      msg += `OU pousser ${labelFeet(["B","D"])}`;
    }

    return msg;
  }

  // ---------- PARALL√âLISME HORIZONTAL ----------
  if(stepId === "parH"){
    if(ok(state.parH, state.parHTol)){
      return "‚úîÔ∏è Parall√©lisme horizontal conforme.";
    }

    const v = state.parH;
    const realMove = Math.abs(v) / 2;

    let msg = "‚ÜîÔ∏è Parall√©lisme horizontal\n\n";
    msg += `Lecture = ${v.toFixed(2)} mil\n`;
    msg += `Correction r√©elle = ${realMove.toFixed(2)} mil\n\n`;

    if(v > 0){
      msg += `üëâ Tirer ${labelFeet(["A","B"])}\n`;
      msg += `OU pousser ${labelFeet(["C","D"])}`;
    }else{
      msg += `üëâ Tirer ${labelFeet(["C","D"])}\n`;
      msg += `OU pousser ${labelFeet(["A","B"])}`;
    }

    return msg;
  }

  // ---------- DILATATION ----------
  if(stepId === "thermal"){
    return buildThermalStep();
  }

  // d√©faut
  return "";
}
/* =====================================================
   UI ‚Äî Inputs par √©tape (avec IDs)
===================================================== */
function renderInputsForCurrentStep(){
  const id = STEPS[state.step].id;
  updateNote(id);

  // IMPORTANT: valeurs par d√©faut = 0, tol√©rances ‚â† 0
  if(id === "runout"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Voilage (mils)</label>
          <input id="in_runout" type="number" step="0.1" value="${state.runout}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_runoutTol" type="number" step="0.1" value="${state.runoutTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_runout", v => state.runout = v],
      ["in_runoutTol", v => state.runoutTol = Math.max(0, v)],
    ]);
    return;
  }




  if(id === "softfoot"){
    ui.inputsArea.innerHTML = `
    
  
    
      <div class="row">
        <div>
          <label>Patte A (haut gauche)</label>
          <input id="in_sfA" type="number" step="0.1" value="${state.softFoot.A}">
        </div>
        <div>
          <label>Patte B (haut droite)</label>
          <input id="in_sfB" type="number" step="0.1" value="${state.softFoot.B}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Patte C (bas droite)</label>
          <input id="in_sfC" type="number" step="0.1" value="${state.softFoot.C}">
        </div>
        <div>
          <label>Patte D (bas gauche)</label>
          <input id="in_sfD" type="number" step="0.1" value="${state.softFoot.D}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Tol√©rance soft foot (mils)</label>
          <input id="in_sfTol" type="number" step="0.1" value="${state.softFootTol}">
        </div>
      
      </div>
    `;
    wireInputs([
   ["in_sfA", v => state.softFoot.A = Math.max(0,v)],
["in_sfB", v => state.softFoot.B = Math.max(0,v)],
["in_sfC", v => state.softFoot.C = Math.max(0,v)],
["in_sfD", v => state.softFoot.D = Math.max(0,v)],
      ["in_sfTol", v => state.softFootTol = Math.max(0, v)],
      ["in_footScheme", v => {
  footSchemeKey = v;
}]
    ]);
    return;
  }

if(id === "measures"){

  let html = "";

  // ===== SOUS-√âTAPE 1 ‚Äî √ò ACCOUPLEMENT =====
  if(state.measureStep === 0){
    html = `
      <div class="row">
        <div>
          <label style="color:#00a2ff;">√ò accouplement (po)</label>
          <input id="in_diam" class="c-blue" type="number" step="0.1"
                 value="${geometry.couplingDiameter}">
        </div>
      </div>

   
    `;
  }

  // ===== SOUS-√âTAPE 2 ‚Äî CENTRE ‚Üí AVANT =====
  if(state.measureStep === 1){
    html = `
      <div class="row">
        <div>
          <label style="color:#4caf50;">Centre ‚Üí pattes AVANT (po)</label>
          <input id="in_centerFront" class="c-green" type="number" step="0.1"
                 value="${geometry.A}">
        </div>
      </div>

      
    `;
  }

  // ===== SOUS-√âTAPE 3 ‚Äî AVANT ‚Üí ARRI√àRE =====
  if(state.measureStep === 2){
    html = `
      <div class="row">
        <div>
         <label style="color:#ff9800;">Centre ‚Üí pattes ARRI√àRE (po)</label>
<input id="in_centerRear" class="c-orange" type="number" step="0.1"
       value="${geometry.B}">
        </div>
      </div>

 
    `;
  }

  ui.inputsArea.innerHTML = html;

  if(state.measureStep === 0){
    wireInputs([["in_diam", v => geometry.couplingDiameter = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 1){
    wireInputs([["in_centerFront", v => geometry.A = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 2){
    wireInputs([["in_centerRear", v => geometry.B = Math.max(0.1, v)]]);
  }

  return;
}




  // =====================================================
  // ANGULARIT√â VERTICALE
  // =====================================================
  if(id === "angV"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Lecture cadran 12‚Äì6 (mils)</label>
        <input id="in_angV" type="number" step="0.1" value="${state.angV}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_angVTol" type="number" step="0.1" value="${state.angVTol}">
      </div>
    </div>

 
  `;

  wireInputs([
    ["in_angV", v => state.angV = v],
    ["in_angVTol", v => state.angVTol = Math.max(0, v)]
  ]);
  return;
}

if(id === "parV"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Parall√©lisme vertical (mils)</label>
        <input id="in_parV" type="number" step="0.1" value="${state.parV}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_parVTol" type="number" step="0.1" value="${state.parVTol}">
      </div>
    </div>

    
  `;

  wireInputs([
    ["in_parV", v => state.parV = v],
    ["in_parVTol", v => state.parVTol = Math.max(0, v)]
  ]);
  return;
}


  // =====================================================
  // ANGULARIT√â HORIZONTALE
  // =====================================================
  if(id === "angH"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Lecture cadran 3‚Äì9 (mils)</label>
        <input id="in_angH" type="number" step="0.1" value="${state.angH}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_angHTol" type="number" step="0.1" value="${state.angHTol}">
      </div>
    </div>

  
  `;

  wireInputs([
    ["in_angH", v => state.angH = v],
    ["in_angHTol", v => state.angHTol = Math.max(0, v)]
  ]);
  return;
}
  if(id === "parH"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Parall√©lisme horizontal (mils)</label>
          <input id="in_parH" type="number" step="0.1" value="${state.parH}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_parHTol" type="number" step="0.1" value="${state.parHTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_parH", v => state.parH = v],
      ["in_parHTol", v => state.parHTol = Math.max(0, v)],
    ]);
    return;
  }
else if(id === "thermal"){
  ui.inputsArea.innerHTML = `

  <!-- Temp√©rature ambiante -->
  <div class="card">
    <label>Temp√©rature ambiante (¬∞F)</label>
    <input type="number"
           value="${state.tempAmb}"
           oninput="state.tempAmb = Number(this.value)">
  </div>

  <!-- MOTEUR -->
  <div class="card">
    <h3>Moteur</h3>

    <div class="row">
      <div>
        <label>Temp√©rature d‚Äôop√©ration (¬∞F)</label>
        <input type="number"
               value="${state.motor.tempOp}"
               oninput="state.motor.tempOp = Number(this.value)">
      </div>

      <div>
        <label>Hauteur d‚Äôaxe (po)</label>
        <input type="number"
               value="${state.motor.axisHeight}"
               oninput="state.motor.axisHeight = Number(this.value)">
      </div>
    </div>

  <label style="display:flex; justify-content:space-between; align-items:center;">
  <span>Mat√©riau</span>
  <span style="font-size:12px; color:rgba(234,241,255,.75);">
    Coeff : <b>${formatCoefficient(MATERIAL_COEFF[state.motor.material])}</b> /¬∞F
  </span>
</label>

<select onchange="
  state.motor.material = this.value;
  renderAll();
">
  ${materialOptions(state.motor.material)}
</select>
  </div>

  <!-- POMPE -->
  <div class="card">
    <h3>Pompe</h3>

    <div class="row">
      <div>
        <label>Temp√©rature d‚Äôop√©ration (¬∞F)</label>
        <input type="number"
               value="${state.pump.tempOp}"
               oninput="state.pump.tempOp = Number(this.value)">
      </div>

      <div>
        <label>Hauteur d‚Äôaxe (po)</label>
        <input type="number"
               value="${state.pump.axisHeight}"
               oninput="state.pump.axisHeight = Number(this.value)">
      </div>
    </div>

 <label style="display:flex; justify-content:space-between; align-items:center;">
  <span>Mat√©riau</span>
  <span style="font-size:12px; color:rgba(234,241,255,.75);">
    Coeff : <b>${formatCoefficient(MATERIAL_COEFF[state.pump.material])}</b> /¬∞F
  </span>
</label>

<select onchange="
  state.pump.material = this.value;
  renderAll();
">
  ${materialOptions(state.pump.material)}
</select>
  </div>
  `;
  return;
}

}
function buildFormulaSoftFoot(){
  const sf = computeSoftFoot();

  // Valeurs entr√©es
  const A = state.softFoot.A;
  const B = state.softFoot.B;
  const C = state.softFoot.C;
  const D = state.softFoot.D;

  // Calculs
  const diagAC = sf.diagAC;
  const diagBD = sf.diagBD;
  const delta  = sf.delta;

  const corr   = sf.correction;      // 80% du delta
  const each   = corr / 2;           // r√©parti sur 2 pattes

  // Quelle diagonale est fautive?
  let faultyTxt = "Aucune (diagonales √©gales)";
  if(sf.faulty) faultyTxt = sf.faulty.join(" + ");

  return (
`Pied boiteux ‚Äî Diagonales

Diag AC = A + C
       = ${A} + ${C}
       = ${diagAC.toFixed(2)} mil

Diag BD = B + D
       = ${B} + ${D}
       = ${diagBD.toFixed(2)} mil

Œî = |Diag AC ‚àí Diag BD|
  = |${diagAC.toFixed(2)} ‚àí ${diagBD.toFixed(2)}|
  = ${delta.toFixed(2)} mil

Correction ‚âà 0.8 √ó Œî
          = 0.8 √ó ${delta.toFixed(2)}
          = ${corr.toFixed(2)} mil

Par patte (2 pattes) = Correction / 2
                     = ${corr.toFixed(2)} / 2
                     = ${each.toFixed(2)} mil

Pattes √† corriger : ${faultyTxt}`
  );
}

/* =====================================================
   Wire inputs (lecture -> state -> redraw)
===================================================== */
function wireInputs(pairs){
  pairs.forEach(([inputId, setter]) => {
    const input = document.getElementById(inputId);
    if(!input) return;

    const isSelect = input.tagName === "SELECT";

    input.addEventListener("input", () => {
      // saisie libre
    });

    input.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        input.blur();
      }
    });

    input.addEventListener("blur", () => {
      let raw = input.value;

      // üü¢ CAS SELECT (mat√©riau)
      if(isSelect){
        setter(raw);
        refreshUI();
        drawTopView();
        drawSideView();
        return;
      }

      // üîµ CAS NUM√âRIQUE
      raw = raw.trim();
      if(raw === ""){
        raw = "0";
        input.value = "0";
      }

      const v = parseFloat(raw);
      setter(Number.isFinite(v) ? v : 0);

      refreshUI();
      drawTopView();
      drawSideView();
    });
  });
}
/* =====================================================
   UI sync
===================================================== */
function refreshUI(){
  ui.stepTitle.textContent = `√âtape ${STEPS[state.step].label}`;

  const okNow = isStepOK(state.step);
  ui.stepBadge.textContent = okNow ? "OK" : "NOT OK";
  ui.stepBadge.classList.toggle("ok", okNow);
  ui.stepBadge.classList.toggle("bad", !okNow);

  renderInputsForCurrentStep();

  ui.infoBox.textContent =
    buildMessage() + "\n\n" + buildCorrectionMessage();

  // ===== FORMULES (PC) ‚Äî √âTAPE 2 SEULEMENT =====
  if(ui.formulaBox){
    if(STEPS[state.step].id === "softfoot"){
      ui.formulaBox.textContent = buildFormulaSoftFoot();
    }else{
      ui.formulaBox.textContent = "";
    }
  }
}
/* =====================================================
   Navigation
===================================================== */
function nextStep(){
  // Sous-√©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep < 2){
      state.measureStep++;
      renderAll();
      return;
    }else{
      state.measureStep = 0;
      state.step++;
      renderAll();
      return;
    }
  }

  if(isStepOK(state.step) && state.step < STEPS.length - 1){
    state.step++;
    renderAll();
  }
}

function prevStep(){
  // Sous-√©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep > 0){
      state.measureStep--;
      renderAll();
      return;
    }else{
      // revenir √† l'√©tape pr√©c√©dente
      state.step--;
      renderAll();
      return;
    }
  }

  if(state.step > 0){
    state.step--;
    renderAll();
  }
}
ui.btnPrev.addEventListener("click", prevStep);
ui.btnNext.addEventListener("click", nextStep);
/* =====================================================
   BLOC 3 ‚Äî DESSINS & SYNCHRO
===================================================== */

const topCanvas = document.getElementById("topView");
const sideCanvas = document.getElementById("sideView");
const topCtx = topCanvas.getContext("2d");
const sideCtx = sideCanvas.getContext("2d");

// ===== CONTEXTES ZONE TEST =====


function resizeCanvas(canvas, ctx){
  const rect = canvas.getBoundingClientRect();

  // üõë PROTECTION CRITIQUE
  const w = Math.max(1, Math.floor(rect.width));
  const h = Math.max(1, Math.floor(rect.height));

  if (canvas.width !== w) canvas.width = w;
  if (canvas.height !== h) canvas.height = h;

  return { w, h };
}
/* =====================================================
   UTILITAIRES DESSIN
===================================================== */

function forceResizeTrainingCanvases(){
  if(window.topCanvasTest && window.topCtxTest){
    const r = window.topCanvasTest.getBoundingClientRect();
    window.topCanvasTest.width  = Math.max(1, Math.floor(r.width));
    window.topCanvasTest.height = Math.max(1, Math.floor(r.height));
  }

  if(window.sideCanvasTest && window.sideCtxTest){
    const r = window.sideCanvasTest.getBoundingClientRect();
    window.sideCanvasTest.width  = Math.max(1, Math.floor(r.width));
    window.sideCanvasTest.height = Math.max(1, Math.floor(r.height));
  }
}

function clear(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,w,h);
}

function drawDimOnly(ctx, x1, x2, y){
  ctx.beginPath();
  ctx.moveTo(x1, y);
  ctx.lineTo(x2, y);
  ctx.stroke();

  // petites barres aux extr√©mit√©s
  ctx.beginPath();
  ctx.moveTo(x1, y - 8);
  ctx.lineTo(x1, y + 8);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y - 8);
  ctx.lineTo(x2, y + 8);
  ctx.stroke();
}



function drawShimValue(ctx, x, y, value){
  if(value <= 0) return;

  ctx.fillStyle = "#ff5252";
  ctx.font = blinkPhase ? "bold 13px Arial" : "12px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`+${value.toFixed(2)} mil`, x + 14, y + 4);
}

function isBlinking(){
  return blinkPhase ? "#ff5252" : "#000";
}
function footColor(letter){
  const step = STEPS[state.step].id;
  const bad = !isStepOK(state.step);

  if(step === "softfoot" && currentView === "side"){
    return FOOT_NORMAL;
  }

  if(step === "softfoot"){
    const sf = computeSoftFoot();
    if(bad && sf.faulty && sf.faulty.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "angV"){
    const r = computeAngularVertical();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "parV" && bad){
    return isBlinking();
  }

  if(step === "angH"){
    const r = computeAngularHorizontal();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  return FOOT_NORMAL;
}
function drawFoot(ctx,x,y,label){
  ctx.fillStyle = footColor(label);
  ctx.fillRect(x-10,y-5,20,10);
  ctx.fillStyle="#fff";
  ctx.font="12px Arial";
  ctx.textAlign="center";
  ctx.fillText(label,x,y+18);
}

function drawArrow(ctx, x1, y1, x2, y2, color="#ff5252"){
  const head = 12;
  const angle = Math.atan2(y2-y1, x2-x1);

  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 3;

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(
    x2 - head * Math.cos(angle - Math.PI/6),
    y2 - head * Math.sin(angle - Math.PI/6)
  );
  ctx.lineTo(
    x2 - head * Math.cos(angle + Math.PI/6),
    y2 - head * Math.sin(angle + Math.PI/6)
  );
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawMathBlock(ctx, x, y, lines){
  ctx.save();
  ctx.font = "13px Consolas, monospace";
  ctx.fillStyle = "rgba(255,255,255,.95)";
  ctx.textAlign = "left";

  // petit fond discret
  const pad = 10;
  const lineH = 18;
  const boxW = 360;
  const boxH = pad*2 + lines.length*lineH;

  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.fillRect(x-pad, y-pad, boxW, boxH);

  ctx.fillStyle = "rgba(255,255,255,.95)";
  let dy = 0;
  for(const l of lines){
    ctx.fillText(l, x, y + dy);
    dy += lineH;
  }

  ctx.restore();
}


function drawDimLine(ctx, x1, x2, y, label){
  const left = Math.min(x1, x2);
  const right = Math.max(x1, x2);

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.fillStyle   = "rgba(255,255,255,.90)";
  ctx.lineWidth = 2;

  // ligne principale
  ctx.beginPath();
  ctx.moveTo(left, y);
  ctx.lineTo(right, y);
  ctx.stroke();

  // "ticks" aux extr√©mit√©s
  ctx.beginPath();
  ctx.moveTo(left, y-8);  ctx.lineTo(left, y+8);
  ctx.moveTo(right, y-8); ctx.lineTo(right, y+8);
  ctx.stroke();

  // texte centr√©
  ctx.font = "12px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText(label, (left + right)/2, y - 10);

  ctx.restore();
}




function drawCouplingDiameter(ctx, cx, cy, diam){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.lineWidth = 2;

  // petit cercle indicatif (pas √† l'√©chelle)
  ctx.beginPath();
  ctx.arc(cx, cy, 18, 0, Math.PI*2);
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,.90)";
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  ctx.fillText(`√ò = ${diam} po`, cx + 24, cy);

  ctx.restore();
}

function blinkColor(col){
  const t = Math.floor(Date.now() / 350) % 2;
  return t ? "#ff5252" : col;
}

function drawTopViewGeneric(ctxTarget){

  currentView = "top";

  const canvas = ctxTarget.canvas;
  const { w, h } = resizeCanvas(canvas, ctxTarget);
  if(w < 10 || h < 10) return;

  const ctx = ctxTarget;
  clear(ctx, w, h);

  const scale   = trainingMode ? visualGain * 0.08 : visualGain;
  const rotGain = visualGain * 0.00035;

  // ====================================================
  // SOURCE UNIQUE DE V√âRIT√â
  // ====================================================
  const parH = trainingMode ? (trainState.parH || 0) : (state.parH || 0);
  const angH = trainingMode ? (trainState.angH || 0) : (state.angH || 0);

  // ====================================================
  // R√âF√âRENCES FIXES (POMPE + SOCLE)
  // ====================================================
  const baseCx = w * 0.30;
  const baseCy = h * 0.5;

  const { motorW, motorH, pumpW, pumpH, gap, shaftH, coupW, coupH } = GEOM;

  // ====================================================
  // TOP VIEW : PARALL√âLISME H = D√âPLACEMENT EN Y ‚úÖ
  // ====================================================
  const maxShift = 60;
  const shiftY = Math.max(-maxShift, Math.min(maxShift, parH * scale));

  const motorCx = baseCx;          // X fixe (axe arbre)
  const motorCy = baseCy + shiftY; // Y bouge (lat√©ral)

  // ====================================================
  // SEMELLE COMMUNE (FIXE)
  // ====================================================
  const baseMargin = 40;
  ctx.fillStyle = "#1a235a";
  ctx.fillRect(
    baseCx - motorW/2 - baseMargin,
    baseCy - motorH/2 - baseMargin,
    motorW + gap + pumpW + baseMargin*2,
    motorH + baseMargin*2
  );

  // ====================================================
  // PATTES (position moteur)
  // ====================================================
  const P = {
    A:{ x: motorCx - motorW/2 + 24, y: motorCy - motorH/2 + 18 }, // TL
    B:{ x: motorCx + motorW/2 - 24, y: motorCy - motorH/2 + 18 }, // TR
    C:{ x: motorCx + motorW/2 - 24, y: motorCy + motorH/2 - 18 }, // BR
    D:{ x: motorCx - motorW/2 + 24, y: motorCy + motorH/2 - 18 }, // BL
  };

  // mapping soft-foot (ordre TL/TR/BR/BL)
  const scheme = FOOT_SCHEMES[footSchemeKey] || FOOT_SCHEMES.standard;
  const PM = {
    A: P[scheme.TL],
    B: P[scheme.TR],
    C: P[scheme.BR],
    D: P[scheme.BL],
  };

  // ====================================================
  // ANGULARIT√â H (TOP VIEW) = ROTATION
  // ====================================================
  const ang = (angH * dialSign * rotGain);

  // pivot r√©aliste : coin ext√©rieur
  let pivot = { x: motorCx, y: motorCy };
  if(ang > 0) pivot = PM.C;
  if(ang < 0) pivot = PM.D;

  // ====================================================
  // DESSIN DU MOTEUR (BLOC ROTATIF)
  // ====================================================
  const footW = 24;
  const footH = 12;

  ctx.save();
  ctx.translate(pivot.x, pivot.y);
  ctx.rotate(ang);
  ctx.translate(-pivot.x, -pivot.y);

  // moteur
  ctx.fillStyle = "#00a2ff";
  ctx.fillRect(motorCx - motorW/2, motorCy - motorH/2, motorW, motorH);

  // pattes (dans le bloc rotatif)
  function drawPad(letter){
    const pt = PM[letter];
    if(!pt) return;
    ctx.fillStyle = footColor(letter);
    ctx.fillRect(pt.x - footW/2, pt.y - footH/2, footW, footH);
  }
  drawPad("A"); drawPad("B"); drawPad("C"); drawPad("D");

  // arbre moteur
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    motorCx + motorW/2,
    motorCy - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // demi-accouplement moteur
  const coupX = motorCx + motorW/2 + gap/2;
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(coupX - 14, motorCy - coupH/2, coupW, coupH);

  // axe moteur (dans le bloc rotatif)
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.setLineDash([5,4]);
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(motorCx - motorW/2 - 90, motorCy);
  ctx.lineTo(motorCx + motorW/2 + gap/2, motorCy);
  ctx.stroke();
  ctx.restore();

  ctx.restore(); // ‚úÖ FIN DU BLOC ROTATIF (UN SEUL restore)

  // ====================================================
  // ANGULARIT√â H ‚Äî FL√àCHES (HORS ROTATION, PREMIER PLAN)
  // ====================================================
  if(Math.abs(angH) > 0){
    const v = angH * dialSign;
    const len = 60;

    if(v > 0){
      drawArrow(ctx, PM.A.x, PM.A.y - len, PM.A.x, PM.A.y);
      drawArrow(ctx, PM.C.x, PM.C.y + len, PM.C.x, PM.C.y);
    }else{
      drawArrow(ctx, PM.B.x, PM.B.y - len, PM.B.x, PM.B.y);
      drawArrow(ctx, PM.D.x, PM.D.y + len, PM.D.x, PM.D.y);
    }
  }

  // ====================================================
  // POMPE (FIXE)
  // ====================================================
  const pumpX = baseCx + motorW/2 + gap;

  // pompe
  ctx.fillStyle="#ff9800";
  ctx.fillRect(pumpX, baseCy - pumpH/2, pumpW, pumpH);

  // arbre pompe
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    baseCx + motorW/2 + gap/2 + 14,
    baseCy - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // demi-accouplement pompe
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(
    baseCx + motorW/2 + gap/2 + 4,
    baseCy - coupH/2,
    coupW,
    coupH
  );

  // axe pompe
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.setLineDash([5,4]);
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(baseCx + motorW/2 + gap/2, baseCy);
  ctx.lineTo(baseCx + motorW/2 + gap + pumpW + 90, baseCy);
  ctx.stroke();
  ctx.restore();

  // ====================================================
  // LETTRES + TITRES (hors rotation)
  // ====================================================
  ctx.fillStyle = "#fff";
  ctx.font = "14px Arial";
  ctx.textAlign = "center";

  const labelOffset = 26;
  ctx.fillText(labelFoot("A"), PM.A.x, PM.A.y - labelOffset);
  ctx.fillText(labelFoot("B"), PM.B.x, PM.B.y - labelOffset);
  ctx.fillText(labelFoot("D"), PM.D.x, PM.D.y + labelOffset + 6);
  ctx.fillText(labelFoot("C"), PM.C.x, PM.C.y + labelOffset + 6);

  ctx.fillText("MOTEUR (mobile)", motorCx, motorCy - motorH/2 - 18);
  ctx.fillText("POMPE (fixe)", pumpX + pumpW/2, baseCy - pumpH/2 - 18);
}
function calcThermalGrowth(heightIn, material, tOp, tAmb){
  const coeff = MATERIAL_COEFF[material];

  if(!coeff || isNaN(heightIn) || isNaN(tOp) || isNaN(tAmb)){
    return 0;
  }

  const deltaIn = heightIn * coeff * (tOp - tAmb);
  return deltaIn * 1000; // pouces ‚Üí mils
}

function calcRelativeThermalShim(motor, pump, tempAmb){
  const motorCoeff = MATERIAL_COEFF[motor.material];
  const pumpCoeff  = MATERIAL_COEFF[pump.material];

  if(!motorCoeff || !pumpCoeff){
    return null;
  }

  const dH_motor =
    motor.axisHeight * motorCoeff * (motor.tempOp - tempAmb) * 1000;

  const dH_pump =
    pump.axisHeight * pumpCoeff * (pump.tempOp - tempAmb) * 1000;

  const deltaRelative = dH_motor - dH_pump;

  return {
    motorGrowth: dH_motor,        // mil
    pumpGrowth:  dH_pump,         // mil
    relative:    deltaRelative,   // mil
    action: deltaRelative < 0 ? "ADD" : "REMOVE",
    shim: Math.abs(deltaRelative)
  };
}

function drawSideViewGeneric(ctxTarget){

  currentView = "side";

  const canvas = ctxTarget.canvas;
  const { w, h } = resizeCanvas(canvas, ctxTarget);
  if (w < 10 || h < 10) return;

  const ctx = ctxTarget;
  clear(ctx, w, h);

  const scale   = trainingMode ? visualGain * 0.08 : visualGain;
  const rotGain = visualGain * 0.00035;

  // ====================================================
  // MODE TRAINING ‚Äî SOURCE UNIQUE DE V√âRIT√â
  // ====================================================
  let parV = trainingMode ? trainState.parV : state.parV;
  let angV = trainingMode ? trainState.angV : state.angV;

  
  // ====================================================
  // R√âF√âRENCES FIXES
  // ====================================================
  const bottomSafeMargin = 40;
  const baseCy = (h - bottomSafeMargin) * 0.55;
  const baseCx = w * 0.30;

  const cy = baseCy + (parV * scale); // ‚úÖ parV = d√©placement vertical
  const cx = baseCx;

  const axisPumpY  = baseCy; // FIXE
  const axisMotorY = cy;     // MOBILE

  const { motorW, motorH, pumpW, pumpH, gap, shaftH, coupW, coupH } = GEOM;

  const footW = 24;
  const footH = 10;

  const rearFootX  = cx - motorW / 2 + footW / 2;
  const frontFootX = cx + motorW / 2 - footW / 2;

  // ====================================================
  // SEMELLE COMMUNE
  // ====================================================
  const baseMargin = 40;
  const baseTop = baseCy + pumpH / 2 + footH - 2;

  ctx.fillStyle = "#1a235a";
  ctx.fillRect(
    cx - motorW / 2 - baseMargin,
    baseTop,
    motorW + gap + pumpW + baseMargin * 2,
    16
  );

  // ====================================================
  // PARAM√àTRE ANGULAIRE (ANGULARIT√â VERTICALE)
  // ====================================================
  const ang = -(angV * dialSign * rotGain);

  // ====================================================
  // POMPE FIXE
  // ====================================================
  const pumpX = cx + motorW / 2 + gap;
  const coupX = cx + motorW / 2 + gap / 2;

  ctx.fillStyle = "#ff9800";
  ctx.fillRect(pumpX, baseCy - pumpH / 2, pumpW, pumpH);

  ctx.fillRect(pumpX + 12, baseCy + pumpH / 2 - 2, footW, footH);
  ctx.fillRect(pumpX + pumpW - 12 - footW, baseCy + pumpH / 2 - 2, footW, footH);

  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    coupX + 14,
    axisPumpY - shaftH / 2,
    (gap / 2) - 8,
    shaftH
  );

  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(
    coupX + 4,
    axisPumpY - coupH / 2,
    coupW,
    coupH
  );

  // ====================================================
  // MOTEUR ‚Äî BLOC SOLIDAIRE (PIVOT R√âALISTE)
  // ====================================================
  const pivotX = cx + motorW/2 + gap/2; // centre accouplement
const pivotY = cy;

ctx.save();
ctx.translate(pivotX, pivotY);
ctx.rotate(ang);
ctx.translate(-pivotX, -pivotY);
  // ---- moteur ----
  ctx.fillStyle = "#00a2ff";
  ctx.fillRect(cx - motorW / 2, cy - motorH / 2, motorW, motorH);

  // pattes moteur
  ctx.fillRect(rearFootX - footW / 2,  cy + motorH / 2 - 2, footW, footH);
  ctx.fillRect(frontFootX - footW / 2, cy + motorH / 2 - 2, footW, footH);

  // lettres (mapping respect√©)
  ctx.fillStyle = "#fff";
  ctx.font = "14px Arial";
  ctx.textAlign = "center";

  const labelY = Math.min(cy + motorH / 2 + 24, h - 12);
  ctx.fillText(labelFoot("D"), rearFootX + 12, labelY);
  ctx.fillText(labelFoot("C"), frontFootX, labelY);

  // arbre moteur
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    cx + motorW / 2,
    cy - shaftH / 2,
    (gap / 2) - 8,
    shaftH
  );

  // demi-accouplement moteur
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(
    cx + motorW / 2 + gap / 2 - 14,
    cy - coupH / 2,
    coupW,
    coupH
  );

  // axe moteur
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.setLineDash([5,4]);
  ctx.lineWidth = 2.5;

  ctx.beginPath();
  ctx.moveTo(cx - motorW / 2 - 90, cy);
  ctx.lineTo(cx + motorW / 2 + gap / 2, cy);
  ctx.stroke();
  ctx.restore();

  ctx.restore();

  // axe pompe (fixe)
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.setLineDash([5,6]);
  ctx.lineWidth = 2;

  ctx.beginPath();
  ctx.moveTo(cx + motorW / 2 + gap / 2, axisPumpY);
  ctx.lineTo(cx + motorW / 2 + gap + pumpW + 100, axisPumpY);
  ctx.stroke();
  ctx.restore();

  // ====================================================
  // TITRES
  // ====================================================
  ctx.fillStyle = "#fff";
  ctx.font = "14px Arial";
  ctx.textAlign = "center";

  ctx.fillText("MOTEUR (mobile)", cx, cy - motorH / 2 - 14);
  ctx.fillText("POMPE (fixe)", pumpX + pumpW / 2, baseCy - pumpH / 2 - 14);
}
// ===== WRAPPERS PRINCIPAUX =====
function drawTopView(){
  drawTopViewGeneric(topCtx);
}

function drawSideView(){
  drawSideViewGeneric(sideCtx);
}

function drawTrainingViews(){
  if(!trainingMode) return;

  if(window.topCtxTest){
    drawTopViewGeneric(window.topCtxTest);
  }

  if(window.sideCtxTest){
    drawSideViewGeneric(window.sideCtxTest);

    
  }
}
function renderAll(){
  refreshUI();
  drawTopView();
  drawSideView();
}
window.addEventListener("load", () => {

  // ===== ORIENTATION =====
  const layoutSelect = document.getElementById("footLayout");
  if(layoutSelect){
    layoutSelect.value = footLayout;

    layoutSelect.addEventListener("change", () => {
      footLayout = layoutSelect.value;
      renderAll();
    });
  }

  // ===== ‚ÑπÔ∏è AIDE / FORMULES =====
  const btnHelp = document.getElementById("btnHelp");
  const btnHelpClose = document.getElementById("btnHelpClose");
  const btnHelpPrint = document.getElementById("btnHelpPrint");
  const helpBackdrop = document.getElementById("helpBackdrop");

  if(btnHelp) btnHelp.addEventListener("click", openHelp);
  if(btnHelpClose) btnHelpClose.addEventListener("click", closeHelp);
  if(btnHelpPrint) btnHelpPrint.addEventListener("click", printHelp);
  if(helpBackdrop) helpBackdrop.addEventListener("click", closeHelp);

  document.addEventListener("keydown", (e) => {
    if(e.key === "Escape"){
      closeHelp();
      closeTraining();
    }
  });

  // ===== üéì TRAINING =====
  const btnTraining = document.getElementById("btnTraining");
  const btnTrainingClose = document.getElementById("btnTrainingClose");
  const trainingBackdrop = document.getElementById("trainingBackdrop");

  if(btnTraining) btnTraining.addEventListener("click", openTraining);
  if(btnTrainingClose) btnTrainingClose.addEventListener("click", closeTraining);
  if(trainingBackdrop) trainingBackdrop.addEventListener("click", closeTraining);


  

  renderAll();
});
// ============================================
// üì± iOS / Safari ‚Äî FIX ORIENTATION TRAINING
// ============================================
window.addEventListener("orientationchange", () => {
  if(trainingMode){
    setTimeout(() => {
      forceResizeTrainingCanvases();
      updateTraining();
    }, 150);
  }
});

</script>
</body>
</html>
