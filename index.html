<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement ‚Äì Comparateur invers√© (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.75);
  --ok:#4caf50;
  --bad:#ff5252;
  --accent:#00a2ff;
  --warn:#ffb300;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{ margin:0; background:var(--bg); color:var(--text); font-family:Arial,system-ui,sans-serif; }

header{
  padding:14px 14px 10px;
  text-align:center;
  font-size:18px;
  font-weight:800;
}
.sub{
  text-align:center;
  opacity:.85;
  margin:-6px 0 10px;
  font-size:12px;
}

.wrap{
  padding:0 12px 18px;
  max-width:980px;
  margin:0 auto;
}

.grid{
  display:grid;
  gap:12px;
}
@media (min-width: 860px){
  .grid{ grid-template-columns: 1.05fr 0.95fr; align-items:start; }
}

.card{
  background:var(--card);
  border-radius:14px;
  padding:14px;
}

h2{
  margin:0 0 8px;
  font-size:16px;
}
p{
  margin:6px 0 10px;
  font-size:13px;
  color:var(--muted);
  line-height:1.35;
}

.step{
  border:1px solid rgba(255,255,255,.08);
  border-radius:14px;
  padding:12px;
  margin-top:10px;
  background:rgba(255,255,255,.03);
}
.stepHead{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
}
.stepTitle{
  font-weight:800;
  font-size:14px;
}
.badge{
  font-size:12px;
  font-weight:800;
  padding:4px 8px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
  color:var(--muted);
}
.badge.ok{ background:rgba(76,175,80,.15); color:#bff3c1; }
.badge.bad{ background:rgba(255,82,82,.15); color:#ffc2c2; }
.badge.warn{ background:rgba(255,179,0,.16); color:#ffe6b0; }

.row{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px;
}
.row3{
  display:grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap:8px;
}

label{
  display:block;
  font-size:12px;
  color:var(--muted);
  margin-bottom:4px;
}

input, select{
  width:100%;
  padding:10px 10px;
  font-size:16px;
  border-radius:12px;
  border:none;
  outline:none;
}

.smallNote{
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
  line-height:1.35;
}

.btnRow{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:10px;
}
button{
  flex:1;
  min-width:140px;
  padding:12px;
  font-size:16px;
  border:none;
  border-radius:12px;
  background:var(--accent);
  color:#fff;
  font-weight:800;
}
button.secondary{
  background:rgba(255,255,255,.12);
}

.hr{
  height:1px;
  background:rgba(255,255,255,.08);
  margin:12px 0;
}

/* ====== CANVAS AREA ====== */
.canvasGrid{
  display:grid;
  gap:12px;
}
@media (min-width: 860px){
  .canvasGrid{
    grid-template-columns: 1fr 1fr;
  }
}
.canvasCard{
  background:#000;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.canvasHeader{
  padding:10px 12px;
  font-size:13px;
  font-weight:800;
  background:rgba(0,0,0,.35);
  color:#eaf1ff;
  border-bottom:1px solid rgba(255,255,255,.08);
}
canvas{
  width:100%;
  height:240px;
  display:block;
  background:#000;
}
@media (min-width: 860px){
  canvas{ height:280px; }
}

.legend{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:10px;
  font-size:12px;
  color:var(--muted);
}
.dot{
  width:10px;height:10px;border-radius:999px;display:inline-block;margin-right:6px;
}
.dot.motor{ background:#00a2ff; }
.dot.pump{ background:#ff9800; }

.kpi{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px;
  margin-top:10px;
}
.kpi .box{
  padding:10px;
  border-radius:12px;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.08);
}
.kpi b{ color:#cfe2ff; }
.kpi .v{ font-size:14px; font-weight:800; margin-top:4px; }

.mono{
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  font-size:12px;
}

.infoBtn{
  position:absolute;
  right:14px;
  top:10px;
  font-size:20px;
  background:none;
  border:none;
  color:#eaf1ff;
}
.infoModal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.65);
  z-index:9999;
  display:flex;
  align-items:center;
  justify-content:center;
}

.infoBox{
  background:#121c4a;
  width:min(92vw,520px);
  max-height:88vh;
  border-radius:16px;
  padding:16px;
  display:flex;
  flex-direction:column;
}

.infoScroll{
  overflow:auto;
  font-size:13px;
  line-height:1.45;
  margin:10px 0;
}

.hidden{ display:none; }

.headerBar{
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:14px;
  font-size:18px;
  font-weight:800;
}

.headerBar span{
  pointer-events:none;
}

.infoBtn{
  position:absolute;
  right:14px;
  top:50%;
  transform:translateY(-50%);
  font-size:20px;
  background:none;
  border:none;
  color:#eaf1ff;
}
details{
  border:1px solid rgba(255,255,255,.12);
  border-radius:10px;
  padding:8px 10px;
  margin-bottom:8px;
  background:rgba(255,255,255,.03);
}

summary{
  cursor:pointer;
  font-weight:700;
  font-size:14px;
  list-style:none;
}

summary::-webkit-details-marker{
  display:none;
}

details[open] summary{
  color:#cfe2ff;
}
</style>
</head>

<body>
<header style="position:relative;">
  Alignement ‚Äì Comparateur invers√© (mils)
  <button id="infoBtn"
          aria-label="Informations"
          class="infoBtn"
          style="position:absolute; right:14px; top:10px;">
    ‚ÑπÔ∏è
  </button>
</header>
<div class="sub">
  iPhone-first ‚Ä¢ 2 vues (dessus + profil) ‚Ä¢ corrections visibles (exag√©r√©es) ‚Ä¢ pas de blocage d‚Äô√©tapes
</div>
<div class="wrap">
  <div class="grid">

    <!-- ===== LEFT: STEPS / INPUTS ===== -->
    <div class="card" id="panelInputs">
      <h2>Entr√©es & √©tapes</h2>
      <p>
        Signe standard : <b>+</b> = <b>monte / va √† droite</b>, <b>‚àí</b> = <b>descend / va √† gauche</b>.
        Les d√©placements sont <b>exag√©r√©s visuellement</b> pour √™tre perceptibles.
      </p>

      <div class="step" id="step1">
        <div class="stepHead">
          <div class="stepTitle">1) Voilage (runout)</div>
          <div class="badge" id="b1">Info</div>
        </div>
        <p>Entrer le voilage max (mils). (Ce n‚Äôest pas bloquant; on indique seulement l‚Äô√©tat.)</p>
        <div class="row">
          <div>
            <label>Voilage (mils)</label>
            <input id="runout" type="number" inputmode="decimal" step="0.1" value="0.8">
          </div>
          <div>
            <label>Tol√©rance voilage (mils)</label>
            <input id="runoutTol" type="number" inputmode="decimal" step="0.1" value="2.0">
          </div>
        </div>
      </div>

      <div class="step" id="step2">
        <div class="stepHead">
          <div class="stepTitle">2) Pied boiteux (soft foot)</div>
          <div class="badge" id="b2">Info</div>
        </div>
        <p>Entrer les 4 lectures (mils) par patte (diff√©rence max-min). Le logiciel retient la pire patte.</p>

        <div class="row">
          <div>
            <label>Patte AV-G (mils)</label>
            <input id="sfFL" type="number" inputmode="decimal" step="0.1" value="2.0">
          </div>
          <div>
            <label>Patte AV-D (mils)</label>
            <input id="sfFR" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <div>
            <label>Patte AR-G (mils)</label>
            <input id="sfRL" type="number" inputmode="decimal" step="0.1" value="0.5">
          </div>
          <div>
            <label>Patte AR-D (mils)</label>
            <input id="sfRR" type="number" inputmode="decimal" step="0.1" value="3.5">
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <div>
            <label>Tol√©rance pied boiteux (mils)</label>
            <input id="sfTol" type="number" inputmode="decimal" step="0.1" value="3.0">
          </div>
          <div>
            <label>Patte affect√©e</label>
            <select id="sfFoot">
              <option value="auto" selected>Auto (pire patte)</option>
              <option value="FL">AV-G</option>
              <option value="FR">AV-D</option>
              <option value="RL">AR-G</option>
              <option value="RR">AR-D</option>
            </select>
          </div>
        </div>

        <div class="smallNote">
          Astuce : en vrai, on corrige par cales (shims). Ici, la vue de profil montre une patte plus basse pour comprendre l‚Äôeffet.
        </div>
      </div>

      <div class="step" id="step3">
        <div class="stepHead">
          <div class="stepTitle">3) Angularit√© verticale</div>
          <div class="badge" id="b3">Info</div>
        </div>
        <p>Entrer l‚Äôangularit√© verticale (mils). (+) = nez du moteur ‚Äúmonte‚Äù c√¥t√© pompe (visuel).</p>
        <div class="row">
          <div>
            <label>Angularit√© V (mils)</label>
            <input id="angV" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tol√©rance (mils)</label>
            <input id="angVTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <div class="step" id="step4">
        <div class="stepHead">
          <div class="stepTitle">4) Parall√©lisme vertical</div>
          <div class="badge" id="b4">Info</div>
        </div>
        <p>Entrer le parall√©lisme vertical (mils). (+) = moteur ‚Äúmonte‚Äù globalement.</p>
        <div class="row">
          <div>
            <label>Parall√©lisme V (mils)</label>
            <input id="parV" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tol√©rance (mils)</label>
            <input id="parVTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <div class="step" id="step5">
        <div class="stepHead">
          <div class="stepTitle">5) Angularit√© horizontale</div>
          <div class="badge" id="b5">Info</div>
        </div>
        <p>Entrer l‚Äôangularit√© horizontale (mils). (+) = nez du moteur ‚Äúva √† droite‚Äù.</p>
        <div class="row">
          <div>
            <label>Angularit√© H (mils)</label>
            <input id="angH" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tol√©rance (mils)</label>
            <input id="angHTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <div class="step" id="step6">
        <div class="stepHead">
          <div class="stepTitle">6) Parall√©lisme horizontal</div>
          <div class="badge" id="b6">Info</div>
        </div>
        <p>Entrer le parall√©lisme horizontal (mils). (+) = moteur ‚Äúse d√©cale‚Äù √† droite.</p>
        <div class="row">
          <div>
            <label>Parall√©lisme H (mils)</label>
            <input id="parH" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tol√©rance (mils)</label>
            <input id="parHTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <h2>Affichage (p√©dagogique)</h2>
      <p>Le gain visuel amplifie les mils en pixels pour voir les corrections.</p>
      <div class="row">
        <div>
          <label>Gain visuel (px par mil)</label>
          <input id="gain" type="number" inputmode="decimal" step="1" value="25">
        </div>
        <div>
          <label>R√©initialiser</label>
          <button class="secondary" id="btnReset" type="button">Reset valeurs</button>
        </div>
      </div>

      <div class="kpi">
        <div class="box">
          <b>R√©sum√© vertical</b>
          <div class="v mono" id="kpiV">‚Äî</div>
        </div>
        <div class="box">
          <b>R√©sum√© horizontal</b>
          <div class="v mono" id="kpiH">‚Äî</div>
        </div>
      </div>

      <div class="legend">
        <div><span class="dot motor"></span>Moteur (mobile)</div>
        <div><span class="dot pump"></span>Pompe (fixe)</div>
      </div>

      <div class="smallNote">
        Les tol√©rances ici sont des valeurs p√©dagogiques par d√©faut. On pourra les ajuster √† ta m√©thode (et plus tard: calculs complets ‚Äúcomparateur invers√©‚Äù).
      </div>
    </div>

    <!-- ===== RIGHT: CANVAS VIEWS ===== -->
    <div class="card">
      <h2>Vues synchronis√©es</h2>
      <p>Les deux vues changent en temps r√©el √† chaque modification.</p>

      <div class="canvasGrid">
        <div class="canvasCard">
          <div class="canvasHeader">Vue de dessus (horizontal)</div>
          <canvas id="topView"></canvas>
        </div>
        <div class="canvasCard">
          <div class="canvasHeader">Vue de profil (vertical)</div>
          <canvas id="sideView"></canvas>
        </div>
      </div>
    </div>

  </div>
</div>
<script>
/* ===== CALCULS OFFICIELS ‚Äì COMPARATEUR INVERSE ===== */

function calculPiedBoiteux(A, B, C, D){
  const diagAC = Math.abs(A - C);
  const diagBD = Math.abs(B - D);

  if(diagAC < 0.001 && diagBD < 0.001){
    return {
      diagFautive: "AUCUNE",
      Z: 0,
      correction80: 0,
      lettres: [],
      pattes: [],
      repartition: {}
    };
  }

  const Z = Math.abs(diagAC - diagBD);
  const correction80 = Z * 0.8;

  if(diagAC > diagBD){
    return {
      diagFautive: "AC",
      Z,
      correction80,
      lettres: ["A","C"],
      pattes: ["FL","RL"],
      repartition: {
        A: correction80 / 2,
        C: correction80 / 2
      }
    };
  } else {
    return {
      diagFautive: "BD",
      Z,
      correction80,
      lettres: ["B","D"],
      pattes: ["FR","RR"],
      repartition: {
        B: correction80 / 2,
        D: correction80 / 2
      }
    };
  }
}
function calculAngulariteVerticale(diametre, distance, TIR){
  return (TIR / distance) * diametre;
}

function calculParalleleVertical(TIR){
  return TIR / 2;
}

function calculAngulariteHorizontale(TIR){
  return TIR / 2;
}

function calculParalleleHorizontal(TIR){
  return TIR;
}
</script>

<script>
(() => {
  "use strict";

  /* ===================== √âTAT (mils) ===================== */
  const align = {
    runout: 0.8,
    runoutTol: 2.0,

    sf: { FL:2.0, FR:1.0, RL:0.5, RR:3.5 },
    sfTol: 3.0,
    sfFoot: "auto", // auto|FL|FR|RL|RR

    angV: 0.0,
    angVTol: 1.0,

    parV: 0.0,
    parVTol: 1.0,

    angH: 0.0,
    angHTol: 1.0,

    parH: 0.0,
    parHTol: 1.0,

    gain: 25
  };

  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
  const isNum = (x)=>Number.isFinite(x);

  /* ===================== DOM ===================== */
  const el = (id)=>document.getElementById(id);

  const runout    = el("runout");
  const runoutTol = el("runoutTol");

  const sfFL = el("sfFL");
  const sfFR = el("sfFR");
  const sfRL = el("sfRL");
  const sfRR = el("sfRR");
  const sfTol = el("sfTol");
  const sfFoot = el("sfFoot");

  const angV = el("angV");
  const angVTol = el("angVTol");

  const parV = el("parV");
  const parVTol = el("parVTol");

  const angH = el("angH");
  const angHTol = el("angHTol");

  const parH = el("parH");
  const parHTol = el("parHTol");

  const gain = el("gain");
  const btnReset = el("btnReset");

  const kpiV = el("kpiV");
  const kpiH = el("kpiH");

  const b1 = el("b1");
  const b2 = el("b2");
  const b3 = el("b3");
  const b4 = el("b4");
  const b5 = el("b5");
  const b6 = el("b6");

  const topCanvas = el("topView");
  const topCtx = topCanvas.getContext("2d");

  const sideCanvas = el("sideView");
  const sideCtx = sideCanvas.getContext("2d");

  /* ===================== LECTURE / MAJ ===================== */
  function readFloat(inputEl, fallback){
    const v = parseFloat(inputEl.value);
    return isNum(v) ? v : fallback;
  }

  function syncFromInputs(){
    align.runout = readFloat(runout, align.runout);
    align.runoutTol = Math.max(0, readFloat(runoutTol, align.runoutTol));

    align.sf.FL = Math.abs(readFloat(sfFL, align.sf.FL));
    align.sf.FR = Math.abs(readFloat(sfFR, align.sf.FR));
    align.sf.RL = Math.abs(readFloat(sfRL, align.sf.RL));
    align.sf.RR = Math.abs(readFloat(sfRR, align.sf.RR));

    align.sfTol = Math.max(0, readFloat(sfTol, align.sfTol));
    align.sfFoot = sfFoot.value || "auto";

    align.angV = readFloat(angV, align.angV);
    align.angVTol = Math.max(0, readFloat(angVTol, align.angVTol));

    align.parV = readFloat(parV, align.parV);
    align.parVTol = Math.max(0, readFloat(parVTol, align.parVTol));

    align.angH = readFloat(angH, align.angH);
    align.angHTol = Math.max(0, readFloat(angHTol, align.angHTol));

    align.parH = readFloat(parH, align.parH);
    align.parHTol = Math.max(0, readFloat(parHTol, align.parHTol));

    align.gain = clamp(readFloat(gain, align.gain), 1, 120);
  }

  /* ===================== STATUTS (non bloquant) ===================== */
  function setBadge(badgeEl, kind, txt){
    badgeEl.classList.remove("ok","bad","warn");
    badgeEl.classList.add(kind);
    badgeEl.textContent = txt;
  }

  function computeWorstSoftFoot(){
    const entries = Object.entries(align.sf); // [ [FL,val], ... ]
    entries.sort((a,b)=>b[1]-a[1]);
    return { foot: entries[0][0], val: entries[0][1] };
  }

  function getActiveSoftFoot(){
    if(align.sfFoot && align.sfFoot !== "auto"){
      return { foot: align.sfFoot, val: align.sf[align.sfFoot] ?? 0 };
    }
    return computeWorstSoftFoot();
  }
  
  const FOOT_MAP = {
  A: "FL", // AV-G
  B: "FR", // AV-D
  C: "RL", // AR-G
  D: "RR"  // AR-D
};
  
function updateBadges(){

  // ===== BADGES =====
  setBadge(b1, Math.abs(align.runout)<=align.runoutTol ? "ok":"bad", "Info");
  setBadge(b2, getActiveSoftFoot().val<=align.sfTol ? "ok":"bad", "Info");
  setBadge(b3, Math.abs(align.angV)<=align.angVTol ? "ok":"bad", "Info");
  setBadge(b4, Math.abs(align.parV)<=align.parVTol ? "ok":"bad", "Info");
  setBadge(b5, Math.abs(align.angH)<=align.angHTol ? "ok":"bad", "Info");
  setBadge(b6, Math.abs(align.parH)<=align.parHTol ? "ok":"bad", "Info");

  // ===== PIED BOITEUX =====
  const pb = calculPiedBoiteux(
    align.sf.FL,
    align.sf.FR,
    align.sf.RL,
    align.sf.RR
  );

  let pbText = "";

  if(pb.diagFautive === "AUCUNE"){
    pbText = "Pied boiteux : OK";
  } else {
    pbText =
      `Pied boiteux d√©tect√©\n` +
      `Diag fautive : ${pb.diagFautive}\n` +
      `Z = ${pb.Z.toFixed(3)} mil\n` +
      `Correction (80%) = ${pb.correction80.toFixed(3)} mil`;
  }

  // ===== VERTICAL =====
  const corrAngV = calculAngulariteVerticale(6,12,Math.abs(align.angV));
  const corrParV = calculParalleleVertical(Math.abs(align.parV));

  const vertText =
    `Angularit√© V : ${align.angV.toFixed(2)} mil\n` +
    `‚Üí AR moteur : ${corrAngV.toFixed(3)} mil\n\n` +
    `Parall√©lisme V : ${align.parV.toFixed(2)} mil\n` +
    `‚Üí 4 pattes : ${corrParV.toFixed(3)} mil`;

  // ===== HORIZONTAL =====
  const corrAngH = calculAngulariteHorizontale(Math.abs(align.angH));
  const corrParH = calculParalleleHorizontal(Math.abs(align.parH));

  const horiText =
    `Angularit√© H : ${align.angH.toFixed(2)} mil\n` +
    `‚Üí Pivot AR : ${corrAngH.toFixed(3)} mil\n\n` +
    `Parall√©lisme H : ${align.parH.toFixed(2)} mil\n` +
    `‚Üí D√©placement : ${corrParH.toFixed(3)} mil`;

  // ===== AFFICHAGE =====
  kpiV.textContent = pbText + "\n\n" + vertText;
  kpiH.textContent = horiText;
}
  /* ===================== CANVAS UTILS ===================== */
  function dprNow(){ return Math.min(3, window.devicePixelRatio || 1); }

  function resizeCanvas(c, ctx){
    const dpr = dprNow();
    const w = c.clientWidth || 300;
    const h = c.clientHeight || 240;
    c.width  = Math.round(w * dpr);
    c.height = Math.round(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return { W: w, H: h };
  }

  function clear(ctx, W, H){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);
  }

  function drawGrid(ctx, W, H){
    ctx.strokeStyle="rgba(255,255,255,.06)";
    ctx.lineWidth=1;
    const step = 24;
    for(let x=0; x<=W; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for(let y=0; y<=H; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
  }

  function drawCoupling(ctx, x, y, r){
    ctx.strokeStyle="rgba(255,255,255,.25)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(x,y,r*0.55,0,Math.PI*2); ctx.stroke();
  }

  function drawFoot(ctx, x, y, w, h, highlight=false){
  ctx.fillStyle = highlight ? "#ff5252" : ctx.fillStyle;
  ctx.fillRect(x, y, w, h);
}
  /* ===================== RENDU ‚Äì VUE DESSUS (HORIZONTAL) ===================== */
  function drawTopView(){

  // 1Ô∏è‚É£ Pr√©parer la surface de dessin
  const { W, H } = resizeCanvas(topCanvas, topCtx);
  clear(topCtx, W, H);
  drawGrid(topCtx, W, H); // grille pour voir les d√©placements

  // 2Ô∏è‚É£ Position g√©n√©rale des machines
  const midY = H * 0.55;        // ligne centrale
  const baseX = 40;             // marge gauche
  const unitLen = Math.min(160, (W - 120) * 0.45); // longueur moteur/pompe
  const gap = Math.min(90, (W - 120) * 0.18);      // espace accouplement

  // Dimensions des pattes
  const fw = 16;
  const fh = 8;

  // Gain visuel (exag√©ration)
  const g = align.gain;

  // 3Ô∏è‚É£ D√©tection du pied boiteux
  // Si une patte est fautive ‚Üí elle sera color√©e en rouge
  const pb = calculPiedBoiteux(
    align.sf.FL,
    align.sf.FR,
    align.sf.RL,
    align.sf.RR
  );

  const patteDefectueuse = (p) =>
    pb.pattes && pb.pattes.includes(p);

  // ======================
  // üü† POMPE (FIXE)
  // ======================
  const pumpX = baseX + unitLen + gap;
  const pumpY = midY;
  const pumpW = unitLen;
  const pumpH = 42;

  topCtx.fillStyle = "#ff9800";
  topCtx.fillRect(pumpX, pumpY - pumpH/2, pumpW, pumpH);

  // Pattes pompe (toujours correctes)
  topCtx.fillStyle = "#d98200";
  drawFoot(topCtx, pumpX+10, pumpY-pumpH/2-fh-2, fw, fh);
  drawFoot(topCtx, pumpX+pumpW-26, pumpY-pumpH/2-fh-2, fw, fh);
  drawFoot(topCtx, pumpX+10, pumpY+pumpH/2+2, fw, fh);
  drawFoot(topCtx, pumpX+pumpW-26, pumpY+pumpH/2+2, fw, fh);

  // ======================
  // üîµ MOTEUR (MOBILE)
  // ======================
  const motorX0 = baseX;
  const motorY0 = midY;
  const motorW  = unitLen;
  const motorH  = 42;

  // Parall√©lisme horizontal :
  // + mil ‚Üí moteur se d√©place vers la droite
  const dx = align.parH * g;

  // Angularit√© horizontale :
  // le moteur pivote (nez √† droite ou gauche)
  const ang = align.angH * 0.0025;

  const cx = motorX0 + motorW/2;
  const cy = motorY0;

  topCtx.save();
  topCtx.translate(cx + dx, cy);
  topCtx.rotate(ang);
  topCtx.translate(-cx, -cy);

  // Corps moteur
  topCtx.fillStyle = "#00a2ff";
  topCtx.fillRect(motorX0, motorY0-motorH/2, motorW, motorH);

  // Pattes moteur
  drawFoot(topCtx, motorX0+10, motorY0-motorH/2-fh-2, fw, fh, patteDefectueuse("FL"));
  drawFoot(topCtx, motorX0+motorW-26, motorY0-motorH/2-fh-2, fw, fh, patteDefectueuse("FR"));
  drawFoot(topCtx, motorX0+10, motorY0+motorH/2+2, fw, fh, patteDefectueuse("RL"));
  drawFoot(topCtx, motorX0+motorW-26, motorY0+motorH/2+2, fw, fh, patteDefectueuse("RR"));

  // Arbre entre moteur et pompe
  topCtx.strokeStyle = "rgba(255,255,255,.55)";
  topCtx.lineWidth = 3;
  topCtx.beginPath();
  topCtx.moveTo(motorX0+motorW, motorY0);
  topCtx.lineTo(pumpX, pumpY);
  topCtx.stroke();

  // Accouplement
  drawCoupling(topCtx, motorX0+motorW+gap/2, motorY0, 12);

  topCtx.restore();
}
  /* ===================== RENDU ‚Äì VUE PROFIL (VERTICAL) ===================== */
  function drawSideView(){
    const { W, H } = resizeCanvas(sideCanvas, sideCtx);
    clear(sideCtx, W, H);
    drawGrid(sideCtx, W, H);

    const midY = H * 0.60;
    const baseX = 40;
    const unitLen = Math.min(150, (W - 120) * 0.45);
    const gap = Math.min(90, (W - 120) * 0.18);

    // pompe fixe
    const pumpX = baseX + unitLen + gap;
    const pumpW = unitLen;
    const pumpH = 42;

    // moteur mobile
    const motorX0 = baseX;
    const motorW = unitLen;
    const motorH = 42;

    const g = align.gain;

    // parV: translation verticale (haut = +, donc Y diminue)
    const dy = -align.parV * g;

    // angV: rotation (profil)
    const ang = -(align.angV * 0.0025); // rad par mil (tweak)

    // soft foot: patte affect√©e est ‚Äúplus basse‚Äù (descend) => +val => patte baisse
    const sf = getActiveSoftFoot();
    const sfDrop = sf.val * g * 0.35; // drop visuel mod√©r√©
    const footSel = sf.foot;

    // pompe (fixe)
    const pumpY = midY;
    sideCtx.fillStyle="#ff9800";
    sideCtx.fillRect(pumpX, pumpY - pumpH/2, pumpW, pumpH);

    // pattes pompe (profil = 2 pattes visibles)
    sideCtx.fillStyle="#d98200";
    const fw=20, fh=10;
    // avant
    drawFoot(sideCtx, pumpX+16, pumpY + pumpH/2 + 2, fw, fh);
    // arri√®re
    drawFoot(sideCtx, pumpX+pumpW-36, pumpY + pumpH/2 + 2, fw, fh);

    sideCtx.fillStyle="#eaf1ff";
    sideCtx.font="12px Arial";
    sideCtx.textAlign="center";
    sideCtx.fillText("Pompe (fixe)", pumpX + pumpW/2, pumpY - pumpH/2 - 16);

    // moteur transform√©
    const motorY0 = midY + dy;
    const cx = motorX0 + motorW/2;
    const cy = motorY0;

    sideCtx.save();
    sideCtx.translate(cx, cy);
    sideCtx.rotate(ang);
    sideCtx.translate(-cx, -cy);

    // corps moteur
    sideCtx.fillStyle="#00a2ff";
    sideCtx.fillRect(motorX0, motorY0 - motorH/2, motorW, motorH);

    // pattes moteur (profil=2 pattes visibles) + soft foot drop (si patte AV ou AR)
    sideCtx.fillStyle="#0086d6";
    // avant (FL/FR)
    const frontDrop = (footSel === "FL" || footSel === "FR") ? sfDrop : 0;
    // arri√®re (RL/RR)
    const rearDrop  = (footSel === "RL" || footSel === "RR") ? sfDrop : 0;

    drawFoot(sideCtx, motorX0+16,         motorY0 + motorH/2 + 2 + frontDrop, fw, fh);
    drawFoot(sideCtx, motorX0+motorW-36,  motorY0 + motorH/2 + 2 + rearDrop,  fw, fh);

    // arbre / ligne centre
    sideCtx.strokeStyle="rgba(255,255,255,.55)";
    sideCtx.lineWidth=3;
    sideCtx.beginPath();
    sideCtx.moveTo(motorX0+motorW, motorY0);
    sideCtx.lineTo(pumpX, pumpY);
    sideCtx.stroke();

    // accouplement
    const coupX = motorX0 + motorW + gap/2;
    const coupY = motorY0;
    drawCoupling(sideCtx, coupX, coupY, 12);

    // label moteur
    sideCtx.fillStyle="#eaf1ff";
    sideCtx.font="12px Arial";
    sideCtx.textAlign="center";
    sideCtx.fillText("Moteur (mobile)", motorX0 + motorW/2, motorY0 - motorH/2 - 16);

    sideCtx.restore();

    // annotation soft foot
    sideCtx.fillStyle="rgba(255,255,255,.80)";
    sideCtx.font="12px Arial";
    sideCtx.textAlign="left";
    sideCtx.fillText(`SF: patte ${sf.foot} = ${sf.val.toFixed(1)} mil (affich√© exag√©r√©)`, 12, H - 28);
    sideCtx.fillText(`parV=${align.parV.toFixed(1)} mil, angV=${align.angV.toFixed(1)} mil`, 12, H - 12);
  }

  /* ===================== RENDER GLOBAL ===================== */
  function render(){
    syncFromInputs();
    updateBadges();
    drawTopView();
    drawSideView();
  }

  /* ===================== RESET (valeurs) ===================== */
  function resetValues(){
    runout.value = "0.8";
    runoutTol.value = "2.0";

    sfFL.value = "2.0";
    sfFR.value = "1.0";
    sfRL.value = "0.5";
    sfRR.value = "3.5";
    sfTol.value = "3.0";
    sfFoot.value = "auto";

    angV.value = "0.0";
    angVTol.value = "1.0";

    parV.value = "0.0";
    parVTol.value = "1.0";

    angH.value = "0.0";
    angHTol.value = "1.0";

    parH.value = "0.0";
    parHTol.value = "1.0";

    gain.value = "25";

    render();
  }

  /* ===================== EVENTS ===================== */
  const allInputs = [
    runout, runoutTol,
    sfFL, sfFR, sfRL, sfRR, sfTol, sfFoot,
    angV, angVTol,
    parV, parVTol,
    angH, angHTol,
    parH, parHTol,
    gain
  ];

  allInputs.forEach(x => {
    x.addEventListener("input", render, { passive:true });
    x.addEventListener("change", render, { passive:true });
  });

  btnReset.addEventListener("click", resetValues);

  window.addEventListener("resize", render);
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", render);
  }

  /* ===================== INIT ===================== */
  render();

})();

document.addEventListener("DOMContentLoaded", () => {
  const infoBtn = document.getElementById("infoBtn");
  const infoModal = document.getElementById("infoModal");

  if (!infoBtn || !infoModal) return;

  infoBtn.addEventListener("click", () => {
    infoModal.classList.remove("hidden");
  });

  window.closeInfo = function(){
    infoModal.classList.add("hidden");
  };
});
function toNumber(v){
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : 0;
}

</script>


<div id="infoModal" class="infoModal hidden">
  <div class="infoBox">
    <h2>‚ÑπÔ∏è M√©thode d‚Äôalignement</h2>

    <div class="infoScroll">
   <details open>
  <summary><b>Principe g√©n√©ral ‚Äì Comparateur invers√© (TIR)</b></summary>
  <p>
    Cette application utilise la m√©thode du <b>comparateur invers√©</b>,
    une m√©thode industrielle standard pour l‚Äôalignement des arbres.
  </p>
  <p class="mono">
    TIR = Lecture MAX ‚àí Lecture MIN
  </p>
  <p>
    Le TIR mesure un <b>d√©faut</b>, jamais une correction.
  </p>
</details>

<details>
  <summary><b>Voilage (runout)</b></summary>
  <p>
    Le voilage correspond au faux-rond d‚Äôun arbre ou d‚Äôun accouplement.
  </p>
  <p>
    Un voilage excessif invalide toutes les mesures d‚Äôalignement.
  </p>
</details>

<details>
  <summary><b>Pied boiteux (soft foot)</b></summary>
  <p>
    Un pied boiteux est pr√©sent lorsque les pattes ne reposent pas
    uniform√©ment sur la base.
  </p>
  <p class="mono">
    Pied boiteux = Lecture MAX ‚àí Lecture MIN
  </p>
  <p>
    En pratique, on corrige environ <b>80 %</b> de la valeur mesur√©e
    avec des cales, puis on rev√©rifie.
  </p>
</details>

<details>
  <summary><b>Angularit√© verticale</b></summary>
  <p>
    Inclinaison entre les axes (vue de profil).
  </p>
  <p class="mono">
    Correction ‚àù TIR √∑ distance
  </p>
</details>

<details>
  <summary><b>Parall√©lisme vertical</b></summary>
  <p>
    D√©calage vertical uniforme entre les axes.
  </p>
</details>

<details>
  <summary><b>Angularit√© horizontale</b></summary>
  <p>
    Inclinaison gauche / droite visible en vue de dessus.
  </p>
</details>

<details>
  <summary><b>Parall√©lisme horizontal</b></summary>
  <p>
    D√©calage horizontal uniforme entre les axes.
  </p>
</details>

<details>
  <summary><b>‚ö†Ô∏è Ordre obligatoire des corrections</b></summary>
  <ol>
    <li>Voilage</li>
    <li>Pied boiteux</li>
    <li>Angularit√© verticale</li>
    <li>Parall√©lisme vertical</li>
    <li>Angularit√© horizontale</li>
    <li>Parall√©lisme horizontal</li>
  </ol>
  <p>
    Changer cet ordre rend les r√©sultats <b>math√©matiquement faux</b>.
  </p>
</details>
    </div>

    <button onclick="closeInfo()">Fermer</button>
  </div>
</div>


</body>
</html>