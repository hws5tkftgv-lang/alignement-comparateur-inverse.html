<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement ‚Äì Comparateur invers√© (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.75);
  --ok:#4caf50;
  --bad:#ff5252;
  --accent:#00a2ff;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:Arial,system-ui,sans-serif;
}

/* ===== HEADER ===== */
.headerBar{
  position:sticky;
  top:0;
  z-index:50;
  background:linear-gradient(to bottom, rgba(11,20,54,.98), rgba(11,20,54,.88));
  border-bottom:1px solid rgba(255,255,255,.08);
  padding:12px;
  text-align:center;
  font-weight:900;
  font-size:16px;
}

/* ===== LAYOUT ===== */
.wrap{
  padding:12px;
  max-width:1100px;
  margin:0 auto;
}
.grid{
  display:grid;
  gap:12px;
}
@media (min-width:900px){
  .grid{ grid-template-columns:1fr 1fr; }
}

/* ===== CARDS ===== */
.card{
  background:var(--card);
  border-radius:14px;
  padding:12px;
  border:1px solid rgba(255,255,255,.06);
}
h2{
  margin:0 0 8px;
  font-size:15px;
}
p{
  margin:6px 0;
  font-size:13px;
  color:var(--muted);
}

/* ===== √âTAPES ===== */
.step{
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:12px;
  background:rgba(255,255,255,.03);
}
.stepHead{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:6px;
}
.stepTitle{
  font-weight:900;
  font-size:14px;
}
.badge{
  font-size:12px;
  font-weight:900;
  padding:4px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
}
.badge.ok{ background:rgba(76,175,80,.15); }
.badge.bad{ background:rgba(255,82,82,.15); }

/* ===== INPUTS ===== */
.row{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
}
@media(max-width:420px){
  .row{ grid-template-columns:1fr; }
}
label{
  font-size:12px;
  color:var(--muted);
}
input{
  width:100%;
  padding:10px;
  font-size:16px;
  border-radius:12px;
  border:none;
}

/* ===== NAV ===== */
.navRow{
  display:flex;
  gap:10px;
  margin-top:10px;
}
button{
  flex:1;
  padding:12px;
  font-size:16px;
  border:none;
  border-radius:12px;
  background:var(--accent);
  color:#fff;
  font-weight:900;
}
button.secondary{
  background:rgba(255,255,255,.15);
}

/* ===== CANVAS ===== */
.canvasGrid{
  display:grid;
  gap:12px;
}
@media(min-width:900px){
  .canvasGrid{ grid-template-columns:1fr 1fr; }
}
.canvasCard{
  background:#000;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.canvasHeader{
  padding:8px 12px;
  font-size:13px;
  font-weight:900;
  background:rgba(0,0,0,.35);
}
canvas{
  width:100%;
  height:260px;
  display:block;
}
@media(min-width:900px){
  canvas{ height:320px; }
}

/* ===== INFO ===== */
.infoBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.2);
  font-size:12px;
  white-space:pre-line;
}
</style>
</head>

<body>

<div class="headerBar">
  Alignement d‚Äôarbres ‚Äî Comparateur invers√© (mils)
</div>

<div class="wrap">
  <div class="grid">

    <!-- ===== √âTAPES ===== -->
    <div class="card">
      <h2>√âtapes d‚Äôalignement</h2>

      <div class="step" id="stepCard">
  <div class="stepHead">
    <div class="stepTitle" id="stepTitle">‚Äî</div>
    <div class="badge" id="stepBadge">Info</div>
  </div>

  <!-- Inputs g√©n√©r√©s par JS selon l'√©tape -->
  <div id="inputsArea"></div>

  <div class="navRow">
    <button class="secondary" id="btnPrev" type="button">‚óÄ Pr√©c√©dent</button>
    <button id="btnNext" type="button">Suivant ‚ñ∂</button>
  </div>

  <div class="infoBox" id="infoBox">‚Äî</div>
</div>
    </div>

    <!-- ===== DESSINS ===== -->
    <div class="card">
      <h2>Dessins p√©dagogiques</h2>
      <p>
Vue de dessus (horizontal) et vue de profil (vertical).
Les pattes A / B / C / D seront affich√©es ici.
      </p>

      <div class="canvasGrid">
        <div class="canvasCard">
          <div class="canvasHeader">Vue de dessus (TopView)</div>
          <canvas id="topView"></canvas>
        </div>
        <div class="canvasCard">
          <div class="canvasHeader">Vue de profil (SideView)</div>
          <canvas id="sideView"></canvas>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
"use strict";
let currentView = "top"; // "top" | "side"
let blinkPhase = true;
setInterval(() => {
  blinkPhase = !blinkPhase;

  // ‚ö†Ô∏è JAMAIS toucher √† l‚ÄôUI ici
  drawTopView();
  drawSideView();
}, 600);

/* =====================================================
   √âTAT GLOBAL (mils)
===================================================== */
const state = {
  step: 0,

  runout: 0,
  runoutTol: 2,

  softFoot: { A:0, B:0, C:0, D:0 },
  softFootTol: 3,

  angV: 0,
  angVTol: 1,

  parV: 0,
  parVTol: 1,

  angH: 0,
  angHTol: 1,

  parH: 0,
  parHTol: 1
};

/* =====================================================
   D√âFINITION DES √âTAPES
===================================================== */
const STEPS = [
  { id:"runout", label:"1 ‚Äî Voilage" },
  { id:"softfoot", label:"2 ‚Äî Pied boiteux" },
  { id:"angV", label:"3 ‚Äî Angularit√© verticale" },
  { id:"parV", label:"4 ‚Äî Parall√©lisme vertical" },
  { id:"angH", label:"5 ‚Äî Angularit√© horizontale" },
  { id:"parH", label:"6 ‚Äî Parall√©lisme horizontal" }
];

/* =====================================================
   UTILITAIRES
===================================================== */
const abs = Math.abs;
const ok = (v,t) => abs(v) <= t;

/* =====================================================
   PIED BOITEUX ‚Äî DIAGONALES
   AC vs BD
===================================================== */
function computeSoftFoot(){
  const {A,B,C,D} = state.softFoot;
  const diagAC = A + C;
  const diagBD = B + D;
  const delta = abs(diagAC - diagBD);
  const correction = delta * 0.8;

  let faulty = null;
  if(diagAC > diagBD) faulty = ["A","C"];
  if(diagBD > diagAC) faulty = ["B","D"];

  return {
    diagAC,
    diagBD,
    delta,
    correction,
    faulty
  };
}

/* =====================================================
   ANGULARIT√â VERTICALE ‚Äî PAIRES
   Avant = BC
   Arri√®re = AD
===================================================== */
function computeAngularVertical(){
  if(state.angV > 0){
    return { pair:["A","D"], direction:"ARRI√àRE trop bas" };
  }
  if(state.angV < 0){
    return { pair:["B","C"], direction:"AVANT trop bas" };
  }
  return null;
}

/* =====================================================
   PARALL√âLISME VERTICAL ‚Äî 4 PATTES
===================================================== */
function computeParallelVertical(){
  if(state.parV !== 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop bas" };
  }
  return null;
}

/* =====================================================
   ANGULARIT√â HORIZONTALE ‚Äî TOP VIEW
===================================================== */
function computeAngularHorizontal(){
  if(state.angH > 0){
    return { pair:["B","D"], direction:"Inclin√© droite" };
  }
  if(state.angH < 0){
    return { pair:["A","C"], direction:"Inclin√© gauche" };
  }
  return null;
}

/* =====================================================
   PARALL√âLISME HORIZONTAL ‚Äî PAIRES
===================================================== */
function computeParallelHorizontal(){
  if(state.parH > 0){
    return { pair:["A","B"], direction:"D√©cal√© droite" };
  }
  if(state.parH < 0){
    return { pair:["D","C"], direction:"D√©cal√© gauche" };
  }
  return null;
}

/* =====================================================
   VALIDATION PAR √âTAPE
===================================================== */
function isStepOK(step){
  switch(step){
    case 0: return ok(state.runout, state.runoutTol);
    case 1: return computeSoftFoot().delta <= state.softFootTol;
    case 2: return ok(state.angV, state.angVTol);
    case 3: return ok(state.parV, state.parVTol);
    case 4: return ok(state.angH, state.angHTol);
    case 5: return ok(state.parH, state.parHTol);
    default: return true;
  }
}

/* =====================================================
   MESSAGE TEXTE (ZONE INFO)
===================================================== */
function buildMessage(){
  const step = STEPS[state.step];
  let txt = `√âtape ${step.label}\n\n`;

  if(!isStepOK(state.step)){
    txt += "‚ö†Ô∏è Hors tol√©rance\n\n";
  }else{
    txt += "‚úÖ Dans la tol√©rance\n\n";
  }

  if(step.id === "softfoot"){
    const sf = computeSoftFoot();
    txt += `Diag AC = ${sf.diagAC}\n`;
    txt += `Diag BD = ${sf.diagBD}\n`;
    txt += `Œî = ${sf.delta}\n`;
    txt += `Correction ‚âà ${sf.correction}\n`;
    if(sf.faulty){
      txt += `Pattes √† corriger : ${sf.faulty.join(" + ")}`;
    }
  }

  return txt;
}


/* =====================================================
   UI ‚Äî DOM
===================================================== */
const ui = {
  stepTitle: document.getElementById("stepTitle"),
  stepBadge: document.getElementById("stepBadge"),
  inputsArea: document.getElementById("inputsArea"),
  infoBox: document.getElementById("infoBox"),
  btnPrev: document.getElementById("btnPrev"),
  btnNext: document.getElementById("btnNext"),
};

/* =====================================================
   MESSAGES DE CORRECTION P√âDAGOGIQUES
===================================================== */
function buildCorrectionMessage(){
  const stepId = STEPS[state.step].id;
  let msg = "";

  // ---------- PIED BOITEUX ----------
  if(stepId === "softfoot"){
    const sf = computeSoftFoot();
    if(sf.delta <= state.softFootTol){
      return "‚úîÔ∏è Pied boiteux corrig√© ‚Äî aucune cale requise.";
    }

    const each = (sf.correction / 2).toFixed(1);
    msg += "ü¶∂ Pied boiteux d√©tect√©\n\n";
    msg += `‚ûï Ajouter **+${each} mil** sous les pattes :\n`;
    msg += `üëâ ${sf.faulty.join(" + ")}\n`;
    msg += "\n‚ö†Ô∏è Toujours corriger en DIAGONALE";
    return msg;
  }

  // ---------- ANGULARIT√â VERTICALE ----------
  if(stepId === "angV"){
    if(ok(state.angV, state.angVTol)){
      return "‚úîÔ∏è Angularit√© verticale conforme.";
    }

    const r = computeAngularVertical();
    msg += "üìê Angularit√© verticale\n\n";
    msg += `‚ûï Ajouter des cales sous :\n`;
    msg += `üëâ ${r.pair.join(" + ")}\n`;
    msg += `(${r.direction})`;
    return msg;
  }

  // ---------- PARALL√âLISME VERTICAL ----------
  if(stepId === "parV"){
    if(ok(state.parV, state.parVTol)){
      return "‚úîÔ∏è Parall√©lisme vertical conforme.";
    }

    msg += "‚¨ÜÔ∏è Parall√©lisme vertical\n\n";
    msg += "‚ûï Ajouter des cales sous :\n";
    msg += "üëâ A + B + C + D\n";
    msg += "(mont√©e uniforme du moteur)";
    return msg;
  }

  // ---------- ANGULARIT√â HORIZONTALE ----------
  if(stepId === "angH"){
    if(ok(state.angH, state.angHTol)){
      return "‚úîÔ∏è Angularit√© horizontale conforme.";
    }

    const r = computeAngularHorizontal();
    msg += "‚ÜîÔ∏è Angularit√© horizontale\n\n";
    msg += "‚ûï D√©placer / caler c√¥t√© :\n";
    msg += `üëâ ${r.pair.join(" + ")}\n`;
    msg += `(${r.direction})`;
    return msg;
  }

  // ---------- PARALL√âLISME HORIZONTAL ----------
  if(stepId === "parH"){
    if(ok(state.parH, state.parHTol)){
      return "‚úîÔ∏è Parall√©lisme horizontal conforme.";
    }

    const r = computeParallelHorizontal();
    msg += "‚ÜîÔ∏è Parall√©lisme horizontal\n\n";
    msg += "‚ûï D√©placer le moteur c√¥t√© :\n";
    msg += `üëâ ${r.pair.join(" + ")}\n`;
    msg += `(${r.direction})`;
    return msg;
  }

  return "";
}




/* =====================================================
   UI ‚Äî Inputs par √©tape (avec IDs)
===================================================== */
function renderInputsForCurrentStep(){
  const id = STEPS[state.step].id;

  // IMPORTANT: valeurs par d√©faut = 0, tol√©rances ‚â† 0
  if(id === "runout"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Voilage (mils)</label>
          <input id="in_runout" type="number" step="0.1" value="${state.runout}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_runoutTol" type="number" step="0.1" value="${state.runoutTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_runout", v => state.runout = v],
      ["in_runoutTol", v => state.runoutTol = Math.max(0, v)],
    ]);
    return;
  }

  if(id === "softfoot"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Patte A (haut gauche)</label>
          <input id="in_sfA" type="number" step="0.1" value="${state.softFoot.A}">
        </div>
        <div>
          <label>Patte B (haut droite)</label>
          <input id="in_sfB" type="number" step="0.1" value="${state.softFoot.B}">
        </div>
      </div>

   <div class="row" style="margin-top:8px;">
  <div>
    <label>Patte C (bas droite)</label>
    <input id="in_sfC" type="number" step="0.1" value="${state.softFoot.C}">
  </div>
  <div>
    <label>Patte D (bas gauche)</label>
    <input id="in_sfD" type="number" step="0.1" value="${state.softFoot.D}">
  </div>
</div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Tol√©rance soft foot (mils)</label>
          <input id="in_sfTol" type="number" step="0.1" value="${state.softFootTol}">
        </div>
        <div>
          <label>Note</label>
          <input disabled value="La plus grande diagonale est affich√©e (soft foot seulement)">
        </div>
      </div>
    `;
    wireInputs([
      ["in_sfA", v => state.softFoot.A = Math.abs(v)],
      ["in_sfB", v => state.softFoot.B = Math.abs(v)],
      ["in_sfC", v => state.softFoot.C = Math.abs(v)],
      ["in_sfD", v => state.softFoot.D = Math.abs(v)],
      ["in_sfTol", v => state.softFootTol = Math.max(0, v)],
    ]);
    return;
  }

  if(id === "angV"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Angularit√© verticale (mils)</label>
          <input id="in_angV" type="number" step="0.1" value="${state.angV}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_angVTol" type="number" step="0.1" value="${state.angVTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_angV", v => state.angV = v],
      ["in_angVTol", v => state.angVTol = Math.max(0, v)],
    ]);
    return;
  }

  if(id === "parV"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Parall√©lisme vertical (mils)</label>
          <input id="in_parV" type="number" step="0.1" value="${state.parV}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_parVTol" type="number" step="0.1" value="${state.parVTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_parV", v => state.parV = v],
      ["in_parVTol", v => state.parVTol = Math.max(0, v)],
    ]);
    return;
  }

  if(id === "angH"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Angularit√© horizontale (mils)</label>
          <input id="in_angH" type="number" step="0.1" value="${state.angH}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_angHTol" type="number" step="0.1" value="${state.angHTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_angH", v => state.angH = v],
      ["in_angHTol", v => state.angHTol = Math.max(0, v)],
    ]);
    return;
  }

  if(id === "parH"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Parall√©lisme horizontal (mils)</label>
          <input id="in_parH" type="number" step="0.1" value="${state.parH}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_parHTol" type="number" step="0.1" value="${state.parHTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_parH", v => state.parH = v],
      ["in_parHTol", v => state.parHTol = Math.max(0, v)],
    ]);
    return;
  }
}

/* =====================================================
   Wire inputs (lecture -> state -> redraw)
===================================================== */
function wireInputs(pairs){
  pairs.forEach(([inputId, setter]) => {
    const input = document.getElementById(inputId);
    if(!input) return;

    const read = () => {
  const v = parseFloat(input.value);
  setter(Number.isFinite(v) ? v : 0);

  // ‚ö†Ô∏è redraw SEULEMENT les dessins, PAS l‚ÄôUI
  drawTopView();
  drawSideView();
};

    input.addEventListener("input", read, { passive:true });
    input.addEventListener("change", read, { passive:true });
  });
}

/* =====================================================
   UI sync
===================================================== */
function refreshUI(){
  ui.stepTitle.textContent = `√âtape ${STEPS[state.step].label}`;

  const okNow = isStepOK(state.step);
  ui.stepBadge.textContent = okNow ? "OK" : "‚ö†Ô∏è √Ä corriger";
  ui.stepBadge.classList.toggle("ok", okNow);
  ui.stepBadge.classList.toggle("bad", !okNow);

  renderInputsForCurrentStep();
  ui.infoBox.textContent =
  buildMessage() + "\n\n" + buildCorrectionMessage();
}

/* =====================================================
   Navigation
===================================================== */
function nextStep(){
  if(isStepOK(state.step) && state.step < STEPS.length - 1){
    state.step++;
    renderAll();
  }
}
function prevStep(){
  if(state.step > 0){
    state.step--;
    renderAll();
  }
}

ui.btnPrev.addEventListener("click", prevStep);
ui.btnNext.addEventListener("click", nextStep);
/* =====================================================
   BLOC 3 ‚Äî DESSINS & SYNCHRO
===================================================== */

const topCanvas = document.getElementById("topView");
const sideCanvas = document.getElementById("sideView");
const topCtx = topCanvas.getContext("2d");
const sideCtx = sideCanvas.getContext("2d");

function resizeCanvas(canvas, ctx){
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return { w, h };
}

/* =====================================================
   UTILITAIRES DESSIN
===================================================== */
function clear(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,w,h);
}
function isBlinking(){
  return blinkPhase ? "#ff5252" : "#000";
}
function footColor(letter){
  const step = STEPS[state.step].id;
  const bad = !isStepOK(state.step);

  // ‚ùå Soft foot jamais en Side View
  if(step === "softfoot" && currentView === "side"){
    return "#00a2ff";
  }

  if(step === "softfoot"){
    const sf = computeSoftFoot();
    if(bad && sf.faulty && sf.faulty.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "angV"){
    const r = computeAngularVertical();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "parV" && bad){
    return isBlinking();
  }

  if(step === "angH"){
    const r = computeAngularHorizontal();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "parH"){
    const r = computeParallelHorizontal();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  return "#00a2ff";
}

function drawFoot(ctx,x,y,label){
  ctx.fillStyle = footColor(label);
  ctx.fillRect(x-10,y-5,20,10);
  ctx.fillStyle="#fff";
  ctx.font="12px Arial";
  ctx.textAlign="center";
  ctx.fillText(label,x,y+18);
}

/* =====================================================
   TOP VIEW
===================================================== */
function drawTopView(){
  currentView = "top";
  const {w,h} = resizeCanvas(topCanvas,topCtx);
  clear(topCtx,w,h);

  const cx = w*0.35;
  const cy = h*0.5;

  // moteur
  topCtx.fillStyle="#00a2ff";
  topCtx.fillRect(cx-80,cy-40,160,80);

  // pattes (ordre demand√©)
// haut gauche -> A ; haut droite -> B ; bas gauche -> D ; bas droite -> C
// --- PATTES TOP VIEW (4 rectangles visibles) ---
// Positions coins (inchang√©es)
const P = {
  A:{x:cx-70, y:cy-30},
  B:{x:cx+70, y:cy-30},
  D:{x:cx-70, y:cy+30},
  C:{x:cx+70, y:cy+30},
};

// Dessiner les petites pattes (rectangles)
function drawPad(letter){
  const {x,y} = P[letter];
  const offsetY = (letter === "C" || letter === "D") ? 10 : -10;

  const faulty = footColor(letter) !== "#00a2ff";

  topCtx.fillStyle = footColor(letter);
  topCtx.fillRect(
    x - (faulty ? 14 : 12),
    y + offsetY - (faulty ? 7 : 6),
    faulty ? 28 : 24,
    faulty ? 14 : 12
  );
}
drawPad("A"); drawPad("B"); drawPad("D"); drawPad("C");

// --- LETTRES TOP VIEW (zone noire, PAS dans le moteur) ---
topCtx.fillStyle = "#fff";
topCtx.font = "14px Arial";
topCtx.textAlign = "center";

// A & B : AU-DESSUS du moteur
topCtx.fillText("A", P.A.x, P.A.y - 18);
topCtx.fillText("B", P.B.x, P.B.y - 18);

// C & D : EN DESSOUS du moteur
topCtx.fillText("D", P.D.x, P.D.y + 28);
topCtx.fillText("C", P.C.x, P.C.y + 28);
  // pompe
  topCtx.fillStyle="#ff9800";
  topCtx.fillRect(cx+120,cy-40,160,80);

  topCtx.fillStyle="#fff";
  topCtx.font="13px Arial";
  topCtx.textAlign="center";
  topCtx.fillText("MOTEUR (mobile)", cx, cy-110);
topCtx.fillText("POMPE (fixe)",    cx+200, cy-110);

  // softfoot seulement : afficher la PLUS GRANDE diagonale + shims pr√®s des pattes
if(STEPS[state.step].id === "softfoot"){
  const sf = computeSoftFoot();

  // 1) diagonale la plus grande (diagAC = A+C, diagBD = B+D)
  // Mapping coins : A(hautG), B(hautD), D(basG), C(basD)
  topCtx.strokeStyle = "#ff5252";
  topCtx.lineWidth = 2;
  topCtx.beginPath();

  if(sf.diagAC >= sf.diagBD){
    // A -> C (hautG -> basD)
    topCtx.moveTo(cx-70, cy-30); // A
    topCtx.lineTo(cx+70, cy+30); // C
  }else{
    // B -> D (hautD -> basG)
    topCtx.moveTo(cx+70, cy-30); // B
    topCtx.lineTo(cx-70, cy+30); // D
  }
  topCtx.stroke();

  // 2) valeur des cales (r√©partition simple et lisible : 50/50 sur les 2 pattes fautives)
  // Si diagAC plus grande => pattes √† corriger = A et C
  // Si diagBD plus grande => pattes √† corriger = B et D
  const shimEach = sf.correction / 2;
  const shim = { A:0, B:0, C:0, D:0 };

  if(sf.diagAC > sf.diagBD){ shim.A = shimEach; shim.C = shimEach; }
  else if(sf.diagBD > sf.diagAC){ shim.B = shimEach; shim.D = shimEach; }

  // helper: √©crire valeur proche de la patte
  function drawShimText(letter, x, y){
    const v = shim[letter];
    if(v <= 0) return;
    topCtx.fillStyle = "#ff5252";
    topCtx.font = "12px Arial";
    topCtx.textAlign = "left";
    topCtx.font = blinkPhase ? "bold 13px Arial" : "12px Arial";
    topCtx.fillText(`+${v.toFixed(1)} mil`, x + 14, y + 4);
  }

  // positions coin -> texte
  drawShimText("A", cx-70, cy-30);
  drawShimText("B", cx+70, cy-30);
  drawShimText("D", cx-70, cy+30);
  drawShimText("C", cx+70, cy+30);
}
}

/* =====================================================
   SIDE VIEW
===================================================== */
function drawSideView(){
  currentView = "side";
  const {w,h} = resizeCanvas(sideCanvas,sideCtx);
  clear(sideCtx,w,h);

  const cx = w*0.35;
  const cy = h*0.55;

  // moteur
  sideCtx.fillStyle="#00a2ff";
  sideCtx.fillRect(cx-80,cy-30,160,60);

  // pattes
  
  // Pattes visibles en vue de profil (Side View)
// A et B sont cach√©es derri√®re

// D = bas gauche (arri√®re moteur)
drawFoot(sideCtx, cx-70, cy+40, "D");

// C = bas droite (c√¥t√© pompe)
drawFoot(sideCtx, cx+70, cy+40, "C");

  // pompe
  sideCtx.fillStyle="#ff9800";
  sideCtx.fillRect(cx+120,cy-30,160,60);

  sideCtx.fillStyle="#fff";
  sideCtx.font="13px Arial";
  sideCtx.textAlign="center";
  sideCtx.fillText("MOTEUR (mobile)", cx,     cy-92);
sideCtx.fillText("POMPE (fixe)",    cx+200, cy-92);
}

/* =====================================================
   RENDER GLOBAL
===================================================== */
function renderAll(){
  refreshUI();
  drawTopView();
  drawSideView();
}


renderAll();
</script>




</body>
</html>