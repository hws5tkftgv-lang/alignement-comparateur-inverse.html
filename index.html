<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement ‚Äì Comparateur invers√© (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.75);
  --ok:#4caf50;
  --bad:#ff5252;
  --accent:#00a2ff;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:Arial,system-ui,sans-serif;
}

/* ===== HEADER ===== */
.headerBar{
  position:sticky;
  top:0;
  z-index:50;
  background:linear-gradient(to bottom, rgba(11,20,54,.98), rgba(11,20,54,.88));
  border-bottom:1px solid rgba(255,255,255,.08);
  padding:12px;
  text-align:center;
  font-weight:900;
  font-size:16px;
}

/* ===== LAYOUT ===== */
.wrap{
  padding:12px;
  max-width:1100px;
  margin:0 auto;
}
.grid{
  display:grid;
  gap:12px;
}
@media (min-width:900px){
  .grid{ grid-template-columns:1fr 1fr; }
}

/* ===== CARDS ===== */
.card{
  background:var(--card);
  border-radius:14px;
  padding:12px;
  border:1px solid rgba(255,255,255,.06);
}
h2{
  margin:0 0 8px;
  font-size:15px;
}
p{
  margin:6px 0;
  font-size:13px;
  color:var(--muted);
}

/* ===== √âTAPES ===== */
.step{
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:12px;
  background:rgba(255,255,255,.03);
}
.stepHead{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:6px;
}
.stepTitle{
  font-weight:900;
  font-size:14px;
}
.badge{
  font-size:12px;
  font-weight:900;
  padding:4px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
}
.badge.ok{ background:rgba(76,175,80,.15); }
.badge.bad{ background:rgba(255,82,82,.15); }

/* ===== INPUTS ===== */
.row{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
}
@media(max-width:420px){
  .row{ grid-template-columns:1fr; }
}
label{
  font-size:12px;
  color:var(--muted);
}
input{
  width:100%;
  padding:10px;
  font-size:16px;
  border-radius:12px;
  border:none;
}

/* ===== NAV ===== */
.navRow{
  display:flex;
  gap:10px;
  margin-top:10px;
}
button{
  flex:1;
  padding:12px;
  font-size:16px;
  border:none;
  border-radius:12px;
  background:var(--accent);
  color:#fff;
  font-weight:900;
}
button.secondary{
  background:rgba(255,255,255,.15);
}

/* ===== CANVAS ===== */
.canvasGrid{
  display:grid;
  gap:12px;
}
@media(min-width:900px){
  .canvasGrid{ grid-template-columns:1fr 1fr; }
}
.canvasCard{
  background:#000;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.canvasHeader{
  padding:8px 12px;
  font-size:13px;
  font-weight:900;
  background:rgba(0,0,0,.35);
}
canvas{
  width:100%;
  height:260px;
  display:block;
}
@media(min-width:900px){
  canvas{ height:320px; }
}

/* ===== INFO ===== */
.infoBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.2);
  font-size:12px;
  white-space:pre-line;
}
/* ===== FORMULES (PC seulement) ===== */
.formulaBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.25);
  font-size:13px;
  font-family:Consolas, monospace;
  line-height:1.45;
  white-space:pre-line;
  display:none; /* cach√© par d√©faut (mobile) */
}
@media (min-width:900px){
  .formulaBox{ display:block; } /* visible PC */
}

.c-blue{ border:2px solid #00a2ff !important; }
.c-green{ border:2px solid #4caf50 !important; }
.c-orange{ border:2px solid #ff9800 !important; }

.noteBox{
  background:rgba(255,255,255,.10);
  border-radius:12px;
  padding:10px 12px;
  font-size:13px;
  color:rgba(234,241,255,.9);
  line-height:1.4;
}

.btnActive{
  background:#00a2ff !important;
  color:white !important;
}
/* =========================
   MODAL AIDE / FORMULES
========================= */
#helpModal{
  position:fixed;
  inset:0;
  z-index:9999;
}

#helpBackdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.65);
}

#helpPanel{
  position:relative;
  width:min(920px, calc(100% - 24px));
  max-height:calc(100% - 24px);
  margin:12px auto;
  background:#0b1436;
  border:1px solid rgba(255,255,255,.12);
  border-radius:14px;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  box-shadow:0 10px 40px rgba(0,0,0,.35);
}

.helpHeader{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  padding:12px;
  background:rgba(255,255,255,.06);
  border-bottom:1px solid rgba(255,255,255,.10);
}

.helpTitle{
  font-weight:900;
  font-size:14px;
}

.helpActions{
  display:flex;
  gap:10px;
}

.helpBtn{
  padding:10px 12px;
  border:none;
  border-radius:10px;
  background:var(--accent);
  color:#fff;
  font-weight:900;
  cursor:pointer;
}

.helpBtn.secondary{
  background:rgba(255,255,255,.15);
}

.helpContent{
  padding:14px;
  overflow:auto;
  font-size:13px;
  line-height:1.45;
  color:rgba(234,241,255,.95);
  white-space:pre-wrap;
}

/* Titres internes */
.helpContent h3{
  margin:14px 0 6px;
  font-size:14px;
}
.helpContent .box{
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.04);
  border-radius:12px;
  padding:10px 12px;
  margin:8px 0;
}
.helpContent code{
  font-family:Consolas, monospace;
  background:rgba(0,0,0,.25);
  padding:2px 6px;
  border-radius:8px;
}

/* =========================
   IMPRESSION (imprimer seulement le panel)
========================= */
@media print{
  body *{
    visibility:hidden !important;
  }
  #helpModal, #helpModal *{
    visibility:visible !important;
  }
  #helpBackdrop{
    display:none !important;
  }
  #helpPanel{
    width:100% !important;
    max-height:none !important;
    margin:0 !important;
    border:none !important;
    border-radius:0 !important;
    box-shadow:none !important;
  }
  .helpActions{
    display:none !important; /* cache boutons √† l‚Äôimpression */
  }
}

</style>
</head>

<body>

<div class="headerBar">
  <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
    <span>Alignement d‚Äôarbres ‚Äî Comparateur invers√© (mils)</span>

    <button id="btnHelp"
      type="button"
      style="flex:0; padding:6px 10px; border-radius:10px; border:none; background:rgba(255,255,255,.15); color:#fff; font-weight:900; cursor:pointer;">
      ‚ÑπÔ∏è
    </button>
  </div>
</div>

<div class="wrap">
  <div class="grid">
    
    <div class="card">
  <h2>Orientation des pattes (r√©el)</h2>

  <label>Choisir l‚Äôorientation :</label>
  <select id="footLayout" style="width:100%; padding:10px; font-size:16px; border-radius:12px; border:none;">
    <option value="ABCD">Standard (A haut-gauche, B haut-droite, C bas-droite, D bas-gauche)</option>
    <option value="ABDC">A / B / D / C (inverse bas)</option>
    <option value="R180">Rotation 180¬∞</option>
    <option value="ROLE">Par r√¥les (HA, HB, BA, BB)</option>
  </select>

  <div class="noteBox" style="margin-top:10px;">
    Cette option ne change pas les calculs, seulement les lettres affich√©es aux √©l√®ves.
  </div>
</div>

    <!-- ===== √âTAPES ===== -->
  



      <div class="step" id="stepCard">
  <div class="stepHead">
    <div class="stepTitle" id="stepTitle">‚Äî</div>
    <div class="badge" id="stepBadge">Info</div>
  </div>

  <!-- Inputs g√©n√©r√©s par JS selon l'√©tape -->
  <div id="inputsArea"></div>
  <div id="formulaBox" class="formulaBox"></div>

  <div class="navRow">
    <button class="secondary" id="btnPrev" type="button">‚óÄ Pr√©c√©dent</button>
    <button id="btnNext" type="button">Suivant ‚ñ∂</button>
  </div>

  <div class="infoBox" id="infoBox">‚Äî</div>
</div>
    </div>

    <!-- ===== DESSINS ===== -->
    <div class="card">
      <h2>Dessins p√©dagogiques</h2>
      <p>
Vue de dessus (horizontal) et vue de profil (vertical).
Les pattes A / B / C / D seront affich√©es ici.
      </p>

      <div class="canvasGrid">
        <div class="canvasCard">
          <div class="canvasHeader">Vue de dessus (TopView)</div>
          <canvas id="topView"></canvas>
        </div>
        <div class="canvasCard">
          <div class="canvasHeader">Vue de profil (SideView)</div>
          <canvas id="sideView"></canvas>
        </div>
      </div>
    </div>

  </div>
</div>
<div class="card" style="margin-top:12px;">
  <h2>Amplification du dessin</h2>

  <label>Effet visuel :</label>
  <input id="gainSlider" type="range" min="1" max="20" value="6" step="1" style="width:100%">

  <div style="display:flex; justify-content:space-between; font-size:12px; opacity:.8;">
    <span>R√©aliste</span>
    <span>P√©dagogique</span>
  </div>
</div>
<!-- =========================
     MODAL AIDE / FORMULES
========================= -->
<div id="helpModal" style="display:none;">
  <div id="helpBackdrop"></div>

  <div id="helpPanel" role="dialog" aria-modal="true" aria-label="Aide et formules">
    <div class="helpHeader">
      <div class="helpTitle">‚ÑπÔ∏è Guide ‚Äî Formules & Conventions (Alignement)</div>

      <div class="helpActions">
        <button id="btnHelpPrint" type="button" class="helpBtn">üñ®Ô∏è Imprimer</button>
        <button id="btnHelpClose" type="button" class="helpBtn secondary">Fermer ‚úï</button>
      </div>
    </div>

    <div id="helpContent" class="helpContent">
      <!-- inject√© par JS -->
    </div>
  </div>
</div>
<script>
"use strict";
/* =====================================================
   AIDE / FORMULES (BULLE ‚ÑπÔ∏è) + IMPRESSION
===================================================== */

// 1) contenu HTML de la fiche
function buildHelpHTML(){
  // ‚ö†Ô∏è Ici on √©crit LA r√©f√©rence p√©dagogique (une seule source de v√©rit√©)
  return `
    <h3>Conventions importantes</h3>

    <div class="box">
      <b>1) Comparateur invers√© = mesure RELATIVE entre 2 arbres</b><br>
      La lecture au cadran repr√©sente l‚Äô√©cart entre l‚Äôarbre mobile (moteur) et l‚Äôarbre fixe (pompe).
    </div>

    <div class="box">
      <b>2) Parall√©lisme (12‚Äì6 et 3‚Äì9) : r√®gle CRITIQUE</b><br>
      <code>Correction moteur = Lecture / 2</code><br>
      Parce que tu corriges une seule machine (le moteur).
    </div>

    <div class="box">
      <b>3) Angularit√©</b><br>
      Les valeurs <b>Avant</b> et <b>Arri√®re</b> sont des <b>magnitudes</b> (valeurs absolues de cale).<br>
      Ensuite, le <b>signe</b> (+ / ‚àí) te dit <b>quelle extr√©mit√© est plus haute/basse</b>, et ta r√®gle (ajouter/enlever) te dit <b>sur quelles pattes appliquer</b>.
    </div>

    <h3>√âtape 1 ‚Äî Voilage (Runout)</h3>
    <div class="box">
      But : valider que la lecture est dans la tol√©rance.<br>
      Condition : <code>|voilage| ‚â§ tol√©rance</code>
    </div>

    <h3>√âtape 2 ‚Äî Pied boiteux (Soft Foot)</h3>
    <div class="box">
      M√©thode diagonales :<br>
      <code>Diag 1 = TL + BR</code><br>
      <code>Diag 2 = TR + BL</code><br>
      <code>Œî = |Diag1 ‚àí Diag2|</code><br>
      <code>Correction ‚âà 0.8 √ó Œî</code><br>
      <code>Par patte (2 pattes) = Correction / 2</code><br><br>
      On corrige les 2 pattes de la diagonale la plus grande.
    </div>

    <h3>√âtape 3 ‚Äî Mesures g√©om√©triques</h3>
    <div class="box">
      <code>D</code> = √ò accouplement (po)<br>
      <code>a</code> = centre ‚Üí pattes AVANT (po)<br>
      <code>b</code> = pattes AVANT ‚Üí ARRI√àRE (po)
    </div>

    <h3>√âtape 4 ‚Äî Angularit√© verticale (12‚Äì6)</h3>
    <div class="box">
      Lecture : <code>v = |angV|</code> (mils)<br>
      Formules (magnitudes) :<br>
      <code>Avant  = (v / D) √ó a</code><br>
      <code>Arri√®re = (v / D) √ó (a + b)</code><br><br>
      Ensuite, appliquer selon le signe (+ / ‚àí) et ta r√®gle (ajouter/enlever).
    </div>

    <h3>√âtape 5 ‚Äî Parall√©lisme vertical (12‚Äì6)</h3>
    <div class="box">
      Lecture : <code>p = parV</code> (mils)<br>
      R√®gle : <code>Correction = |p| / 2</code><br>
      Application : m√™me quantit√© sur les 4 pattes (A+B+C+D), ajouter ou enlever selon le signe.
    </div>

    <h3>√âtape 6 ‚Äî Angularit√© horizontale (3‚Äì9)</h3>
    <div class="box">
      Lecture : <code>h = |angH|</code> (mils)<br>
      Formules (magnitudes) :<br>
      <code>Avant  = (h / D) √ó a</code><br>
      <code>Arri√®re = (h / D) √ó (a + b)</code><br>
      Puis appliquer selon le signe (+ / ‚àí) sur les bonnes pattes (pousser/tirer).
    </div>

    <h3>√âtape 7 ‚Äî Parall√©lisme horizontal (3‚Äì9)</h3>
    <div class="box">
      Lecture : <code>p = parH</code> (mils)<br>
      R√®gle : <code>Correction = |p| / 2</code><br>
      D√©placement r√©el du moteur = moiti√© de la lecture.
    </div>
  `;
}

// 2) ouvrir/fermer/imprimer
function openHelp(){
  const modal = document.getElementById("helpModal");
  const content = document.getElementById("helpContent");
  if(!modal || !content) return;

  content.innerHTML = buildHelpHTML();
  modal.style.display = "block";
  document.body.classList.add("modal-open");
}

function closeHelp(){
  const modal = document.getElementById("helpModal");
  if(!modal) return;
  modal.style.display = "none";
  document.body.classList.remove("modal-open");
}

function printHelp(){
  // Ouvre si jamais ferm√©, pour √™tre s√ªr d‚Äôimprimer la fiche
  const modal = document.getElementById("helpModal");
  if(modal && modal.style.display !== "block"){
    openHelp();
  }
  window.print();
}
/* =====================================================
   MAPPING PATTES (lettres ‚Üî coins)
   Coins = TL (haut-gauche), TR (haut-droite),
           BR (bas-droite), BL (bas-gauche)
===================================================== */
const FOOT_SCHEMES = {
  standard: { name:"Standard (A HG, B HD, C BD, D BG)", TL:"A", TR:"B", BR:"C", BL:"D" },
  invBottom:{ name:"A / B / D / C (inverse bas)",      TL:"A", TR:"B", BR:"D", BL:"C" },
  rot180:   { name:"Rotation 180¬∞",                    TL:"C", TR:"D", BR:"A", BL:"B" },
  roles:    { name:"Par r√¥les (HA, HB, BA, BB)",       TL:"HA",TR:"HB",BR:"BB",BL:"BA" }
};


// mode actif
let footSchemeKey = "standard";


// retourne l'√©tiquette (texte) √† afficher pour un coin
function cornerLabel(corner){
  return FOOT_SCHEMES[footSchemeKey][corner];
}

// retourne la valeur softfoot (mils) pour un coin, peu importe le mode
function sfVal(corner){
  const key = cornerLabel(corner);           // ex: "A" ou "D" ou "HA"
  return Number(state.softFoot[key] || 0);
}
let dialSign = 1;   // +1 = CW normal,  -1 = CW invers√©
let correctionMode = "add";  // "add" | "remove"
let currentView = "top"; // "top" | "side"
let blinkPhase = true;
let visualGain = 6;
const FOOT_NORMAL = "#0070c0";   // bleu fonc√© visible
// ============================
// ORIENTATION / √âTIQUETTES PATTES (affichage seulement)
// ============================
let footLayout = "ABCD";

// mapping: lettre interne -> texte affich√©
const footLabelMap = {
  // Interne : A B C D (A=haut-gauche, B=haut-droite, C=bas-droite, D=bas-gauche)
  "ABCD": { A:"A", B:"B", C:"C", D:"D" },

  // Exemple demand√©: A/B/D/C
  "ABDC": { A:"A", B:"B", C:"D", D:"C" },

  // Rotation 180¬∞ (haut-gauche devient bas-droite, etc.)
  "R180": { A:"C", B:"D", C:"A", D:"B" },

  // Mode r√¥les (HA/HB/BA/BB)
  // HA = Haut Arri√®re, HB = Haut Avant, BA = Bas Arri√®re, BB = Bas Avant
  // ‚ö†Ô∏è Ici, on ASSUME que "haut" = c√¥t√© arbre vers pompe (en haut de ton dessin TopView),
  // et "avant" = c√¥t√© accouplement (√† droite dans ton dessin). Tu peux changer ces mots ensuite.
  "ROLE": { A:"HA", B:"HB", C:"BB", D:"BA" },
};

function labelFoot(letter){
  return footLabelMap[footLayout]?.[letter] || letter;
}

// utilitaire: transforme ["A","C"] en "HA + BA" (ou autre)
function labelFeet(arr){
  return arr.map(labelFoot).join(" + ");
}

const gainSlider = document.getElementById("gainSlider");
if(gainSlider){
  gainSlider.addEventListener("input", () => {
    visualGain = parseFloat(gainSlider.value) || 1;
    drawSideView();
    drawTopView();
  });
}
setInterval(() => {
  blinkPhase = !blinkPhase;

  // ‚ö†Ô∏è JAMAIS toucher √† l‚ÄôUI ici
  drawTopView();
  drawSideView();
}, 600);


const GEOM = {
  motorW: 200,
  motorH: 80,

  pumpW: 130,
  pumpH: 80,

  gap: 70,

  shaftH: 12,
  coupH: 56,
  coupW: 10,

  // ===== DIMENSIONS G√âOM√âTRIQUES POUR CALCULS =====
  dialSpan: 12,          // D = distance entre comparateurs
  centerToFrontFeet: 6, // a = centre ‚Üí pattes avant
  frontToRearFeet: 10   // b = pattes avant ‚Üí arri√®re
};
  
/* =====================================================
   √âTAT GLOBAL (mils)
===================================================== */
const state = {
  step: 0,
  measureStep: 0,
  
  runout: 0,
  runoutTol: 2,

  softFoot: { A:0, B:0, C:0, D:0, HA:0, HB:0, BA:0, BB:0 },
  softFootTol: 3,
  
  footScheme: "standard",

  angV: 0,
  angVTol: 1,

  parV: 0,
  parVTol: 1,

  angH: 0,
  angHTol: 1,

  parH: 0,
  parHTol: 1
};
/* =====================================================
   PARAM√àTRES G√âOM√âTRIQUES (pouces)
===================================================== */
const geometry = {
  couplingDiameter: 3,      // √ò accouplement
  centerToFrontFeet: 6,    // Centre ‚Üí pattes AVANT
  frontToRearFeet: 10      // Pattes AVANT ‚Üí ARRI√àRE
};
/* =====================================================
   D√âFINITION DES √âTAPES
===================================================== */
const STEPS = [
  { id:"runout",  label:"1 ‚Äî Voilage" },
  { id:"softfoot",label:"2 ‚Äî Pied boiteux" },
  { id:"measures",label:"3 ‚Äî Mesures g√©om√©triques" },

  { id:"angV",    label:"4 ‚Äî Angularit√© verticale" },
  { id:"parV",    label:"5 ‚Äî Parall√©lisme vertical" },

  { id:"angH",    label:"6 ‚Äî Angularit√© horizontale" },
  { id:"parH",    label:"7 ‚Äî Parall√©lisme horizontal" }
];
/* =====================================================
   UTILITAIRES
===================================================== */
const abs = Math.abs;
const ok = (v,t) => abs(v) <= t;
function mapFeetByScheme(A, B, C, D, scheme){
  switch(scheme){
    case "standard":
      return { A, B, C, D };

    case "invBottom":   // A / B / D / C
      return { A, B, C: D, D: C };

    case "rot180":      // rotation 180¬∞
      return { A: C, B: D, C: A, D: B };

    case "roles":       // futur (non utilis√© encore)
      return { A, B, C, D };

    default:
      return { A, B, C, D };
  }
}
function mapFeetToCorners(){

  const { A, B, C, D, HA, HB, BA, BB } = state.softFoot;

  const scheme = FOOT_SCHEMES[footSchemeKey];

  return {
    TL: Number(state.softFoot[scheme.TL] || 0),
    TR: Number(state.softFoot[scheme.TR] || 0),
    BR: Number(state.softFoot[scheme.BR] || 0),
    BL: Number(state.softFoot[scheme.BL] || 0)
  };
}
/* =====================================================
   PIED BOITEUX ‚Äî DIAGONALES
   AC vs BD
===================================================== */
function computeSoftFoot(){

  const feet = mapFeetToCorners();

  const diag1 = feet.TL + feet.BR;   // diagonale TL ‚Üî BR
  const diag2 = feet.TR + feet.BL;   // diagonale TR ‚Üî BL

  const delta = Math.abs(diag1 - diag2);
  const correction = delta * 0.8;

  let faulty = null;

  if(diag1 > diag2) faulty = ["TL","BR"];
  if(diag2 > diag1) faulty = ["TR","BL"];

  return {
    diagAC: diag1,
    diagBD: diag2,
    delta,
    correction,
    faulty
  };
}
/* =====================================================
   ANGULARIT√â VERTICALE ‚Äî PAIRES
   Avant = BC
   Arri√®re = AD
===================================================== */
function computeAngularVertical(){

  const v = state.angV * dialSign;

  // POSITIF ‚Üí ARRI√àRE trop bas
  if(v > 0){

    if(correctionMode === "add"){
      return {
        pair:["A","D"],
        direction:"ARRI√àRE trop bas ‚Äî AJOUTER sous A + D"
      };
    }else{
      return {
        pair:["B","C"],
        direction:"ARRI√àRE trop bas ‚Äî ENLEVER sous B + C"
      };
    }

  }

  // N√âGATIF ‚Üí AVANT trop bas
  if(v < 0){

    if(correctionMode === "add"){
      return {
        pair:["B","C"],
        direction:"AVANT trop bas ‚Äî AJOUTER sous B + C"
      };
    }else{
      return {
        pair:["A","D"],
        direction:"AVANT trop bas ‚Äî ENLEVER sous A + D"
      };
    }

  }

  return null;
}



/* =====================================================
   PARALL√âLISME VERTICAL ‚Äî 4 PATTES
===================================================== */
function computeParallelVertical(){
  if(state.parV > 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop bas" };
  }
  if(state.parV < 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop haut" };
  }
  return null;
}
/* =====================================================
   ANGULARIT√â HORIZONTALE ‚Äî TOP VIEW
===================================================== */
function computeAngularHorizontal(){

  const v = state.angH * dialSign;

  // Lecture POSITIVE ‚Üí moteur inclin√© vers la DROITE
  if(v > 0){
    return {
      pair:["B","D"],
      direction:"Moteur inclin√© vers la DROITE ‚Üí corriger B + D"
    };
  }

  // Lecture N√âGATIVE ‚Üí moteur inclin√© vers la GAUCHE
  if(v < 0){
    return {
      pair:["A","C"],
      direction:"Moteur inclin√© vers la GAUCHE ‚Üí corriger A + C"
    };
  }

  return null;
}
/* =====================================================
   PARALL√âLISME HORIZONTAL ‚Äî PAIRES
===================================================== */
function computeParallelHorizontal(){
  if(state.parH > 0){
    return {
      pair:["C","D"],
      direction:"Moteur trop √† droite ‚Üí d√©placer vers la GAUCHE"
    };
  }
  if(state.parH < 0){
    return {
      pair:["A","B"],
      direction:"Moteur trop √† gauche ‚Üí d√©placer vers la DROITE"
    };
  }
  return null;
}
/* =====================================================
   CALCUL CORRECTION ANGULAIRE (mils r√©els)
   B √ó C / A
===================================================== */
function computeAngularShim(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const C = Math.abs(state.angV); // lecture cadran (mils)

  if(A <= 0) return 0;

  return (B * C) / A;
}

function computeAngularShimH(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const C = Math.abs(state.angH); // lecture cadran horizontale (mils)

  if(A <= 0) return 0;
  return (B * C) / A;
}



function computeAngularShimsVertical(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const D = geometry.frontToRearFeet;
  const C = Math.abs(state.angV * dialSign);

  if(A <= 0) return { front:0, rear:0 };

  return {
    front: (B * C) / A,
    rear: ((B + D) * C) / A
  };
}

function computeAngularShimsHorizontal(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const D = geometry.frontToRearFeet;
  const C = Math.abs(state.angH * dialSign);

  if(A <= 0) return { front:0, rear:0 };

  return {
    front: (B * C) / A,
    rear: ((B + D) * C) / A
  };
}
/* =====================================================
   VALIDATION PAR √âTAPE
===================================================== */
function isStepOK(stepIndex){
  const id = STEPS[stepIndex].id;

  if(id === "measures"){
    return geometry.couplingDiameter > 0 &&
           geometry.centerToFrontFeet > 0 &&
           geometry.frontToRearFeet > 0;
  }

  if(id === "runout")  return ok(state.runout, state.runoutTol);
  if(id === "softfoot")return computeSoftFoot().delta <= state.softFootTol;

  if(id === "angV")    return ok(state.angV, state.angVTol);
  if(id === "parV")    return ok(state.parV, state.parVTol);

  if(id === "angH")    return ok(state.angH, state.angHTol);
  if(id === "parH")    return ok(state.parH, state.parHTol);

  return true;
}
/* =====================================================
   MESSAGE TEXTE (ZONE INFO)
===================================================== */
function buildMessage(){
  const step = STEPS[state.step];
  let txt = `√âtape ${step.label}\n\n`;

  if(!isStepOK(state.step)){
    txt += "‚ö†Ô∏è Hors tol√©rance\n\n";
  }else{
    txt += "‚úÖ Dans la tol√©rance\n\n";
  }

  if(step.id === "softfoot"){
    const sf = computeSoftFoot();
    txt += `Diag AC = ${sf.diagAC}\n`;
    txt += `Diag BD = ${sf.diagBD}\n`;
    txt += `Œî = ${sf.delta}\n`;
    txt += `Correction ‚âà ${sf.correction}\n`;
    if(sf.faulty){
      txt += `Pattes √† corriger : ${labelFeet(sf.faulty)}`;
    }
  }

  return txt;
}


/* =====================================================
   UI ‚Äî DOM
===================================================== */
const ui = {
  stepTitle: document.getElementById("stepTitle"),
  stepBadge: document.getElementById("stepBadge"),
  inputsArea: document.getElementById("inputsArea"),
  infoBox: document.getElementById("infoBox"),
  btnPrev: document.getElementById("btnPrev"),
  btnNext: document.getElementById("btnNext"),
    formulaBox: document.getElementById("formulaBox"),
};

/* =====================================================
   MESSAGES DE CORRECTION P√âDAGOGIQUES
===================================================== */

function buildCorrectionMessage(){
  const stepId = STEPS[state.step].id;
  let msg = "";

  // ---------- PIED BOITEUX ----------
  if(stepId === "softfoot"){
    const sf = computeSoftFoot();

    if(sf.delta <= state.softFootTol){
      return "‚úîÔ∏è Pied boiteux corrig√© ‚Äî aucune cale requise.";
    }

    const each = (sf.correction / 2).toFixed(1);

    msg += "ü¶∂ Pied boiteux\n\n";
    msg += "‚ö†Ô∏è Hors tol√©rance\n\n";
    msg += `Diag AC = ${sf.diagAC}\n`;
    msg += `Diag BD = ${sf.diagBD}\n`;
    msg += `Œî = ${sf.delta}\n`;
    msg += `Correction ‚âà ${sf.correction}\n\n`;

    msg += "üë£ Pied boiteux d√©tect√©\n\n";
    msg += `‚ûï Ajouter **+${each} mil** sous :\n`;
    msg += `üëâ ${labelFeet(sf.faulty)}\n`;
    msg += "\n‚ö†Ô∏è Toujours corriger en DIAGONALE";

    return msg;
  }

  // ---------- ANGULARIT√â VERTICALE ----------
  if(stepId === "angV"){
    if(ok(state.angV, state.angVTol)){
      return "‚úîÔ∏è Angularit√© verticale conforme.";
    }

    const v = state.angV * dialSign;
    const a = geometry.centerToFrontFeet;  // centre ‚Üí pattes AVANT
const b = geometry.frontToRearFeet;    // pattes AVANT ‚Üí ARRI√àRE
const D = geometry.couplingDiameter;   // diam√®tre accouplement
    const shims = computeAngularShimsVertical();
    const front = shims.front.toFixed(2);
    const rear  = shims.rear.toFixed(2);
    
    msg += "üßÆ CALCUL ‚Äî Angularit√© verticale\n\n";

msg += `v = ${Math.abs(v).toFixed(2)} mil\n`;
msg += `a = ${a} po (centre ‚Üí pattes AVANT)\n`;
msg += `b = ${b} po (pattes AVANT ‚Üí ARRI√àRE)\n`;
msg += `D = ${D} po (√ò accouplement)\n\n`;

msg += "Formules :\n";
msg += "Avant  = (v / D) √ó a\n";
msg += "Arri√®re = (v / D) √ó (a + b)\n\n";

msg += `Avant  = (${Math.abs(v).toFixed(2)} / ${D}) √ó ${a} = ${front} mil\n`;
msg += `Arri√®re = (${Math.abs(v).toFixed(2)} / ${D}) √ó ${a + b} = ${rear} mil\n\n`;

    msg += "üìê Angularit√© verticale\n\n";

    if(v > 0){
      msg += "Lecture POSITIVE ‚Üí AVANT plus haut que l‚Äôarri√®re\n";
      msg += "(moteur inclin√© vers l‚Äôarri√®re)\n\n";
      msg += "Action m√©canique : abaisser l‚Äôavant\n\n";
      msg += "Corrections possibles :\n";
      msg += `‚ûñ Enlever ${front} mil sous : ${labelFeet(["B","C"])}\n`;
      msg += `OU\n`;
      msg += `‚ûï Ajouter ${rear} mil sous : ${labelFeet(["A","D"])}`;
    }

    if(v < 0){
      msg += "Lecture N√âGATIVE ‚Üí ARRI√àRE plus haut que l‚Äôavant\n";
      msg += "(moteur inclin√© vers l‚Äôavant)\n\n";
      msg += "Action m√©canique : abaisser l‚Äôarri√®re\n\n";
      msg += "Corrections possibles :\n";
      msg += `‚ûñ Enlever ${rear} mil sous : ${labelFeet(["A","D"])}\n`;
      msg += `OU\n`;
      msg += `‚ûï Ajouter ${front} mil sous : ${labelFeet(["B","C"])}`;
    }

    return msg;
  }

  // ---------- PARALL√âLISME VERTICAL ----------
  if(stepId === "parV"){
    if(ok(state.parV, state.parVTol)){
      return "‚úîÔ∏è Parall√©lisme vertical conforme.";
    }

    const v   = state.parV;
    const amt = Math.abs(v).toFixed(2);

    msg += "‚ÜïÔ∏è Parall√©lisme vertical\n\n";

    if(v > 0){
      msg += "Lecture N√âGATIVE ‚Üí moteur trop BAS\n\n";
      msg += "Action m√©canique : remonter le moteur\n\n";
      msg += "Correction :\n";
      msg += `‚ûï Ajouter +${amt} mil sous :\n`;
      msg += "üëâ A + B + C + D\n";
      msg += "(m√™me quantit√© sur les 4 pattes)";
    }

    if(v < 0){
      msg += "Lecture POSITIVE ‚Üí moteur trop HAUT\n\n";
      msg += "Action m√©canique : abaisser le moteur\n\n";
      msg += "Correction :\n";
      msg += `‚ûñ Enlever ${amt} mil sous :\n`;
      msg += "üëâ A + B + C + D\n";
      msg += "(m√™me quantit√© sur les 4 pattes)";
    }

    return msg;
  }

  // ---------- ANGULARIT√â HORIZONTALE ----------
// ---------- ANGULARIT√â HORIZONTALE ----------
// ---------- ANGULARIT√â HORIZONTALE ----------
if(stepId === "angH"){

  if(ok(state.angH, state.angHTol)){
    return "‚úîÔ∏è Angularit√© horizontale conforme.";
  }

  const v = state.angH * dialSign;
  const D = GEOM.dialSpan;
  const a = GEOM.centerToFrontFeet;
  const b = GEOM.frontToRearFeet;

  const front = (Math.abs(v) * a / D).toFixed(2);
  const rear  = (Math.abs(v) * (a + b) / D).toFixed(2);

  msg += "‚ÜîÔ∏è Angularit√© horizontale\n\n";

  msg += "üßÆ CALCUL :\n\n";
  msg += `v = ${v.toFixed(2)} mil\n`;
  msg += `D = ${D} po\n`;
  msg += `a = ${a} po\n`;
  msg += `b = ${b} po\n\n`;

  msg += "Formules :\n";
  msg += "Avant   = (v √ó a) / D\n";
  msg += "Arri√®re = (v √ó (a+b)) / D\n\n";

  msg += `Avant   = (${Math.abs(v).toFixed(2)} √ó ${a}) / ${D} = ${front} mil\n`;
  msg += `Arri√®re = (${Math.abs(v).toFixed(2)} √ó ${a+b}) / ${D} = ${rear} mil\n\n`;

  if(v > 0){
    msg += "üìà Lecture POSITIVE ‚Üí moteur inclin√© vers la DROITE\n\n";
    msg += "Correction m√©canique :\n";
    msg += `üëâ Tirer sur ${labelFeet(["B","D"])}\n`;
    msg += "OU\n";
    msg += `üëâ Pousser sur ${labelFeet(["A","C"])}\n`;
  }

  if(v < 0){
    msg += "üìâ Lecture N√âGATIVE ‚Üí moteur inclin√© vers la GAUCHE\n\n";
    msg += "Correction m√©canique :\n";
    msg += `üëâ Tirer sur ${labelFeet(["A","C"])}\n`;
    msg += "OU\n";
    msg += `üëâ Pousser sur ${labelFeet(["B","D"])}\n`;
  }

  return msg;
}
return "";
}
/* =====================================================
   UI ‚Äî Inputs par √©tape (avec IDs)
===================================================== */
function renderInputsForCurrentStep(){
  const id = STEPS[state.step].id;

  // IMPORTANT: valeurs par d√©faut = 0, tol√©rances ‚â† 0
  if(id === "runout"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Voilage (mils)</label>
          <input id="in_runout" type="number" step="0.1" value="${state.runout}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_runoutTol" type="number" step="0.1" value="${state.runoutTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_runout", v => state.runout = v],
      ["in_runoutTol", v => state.runoutTol = Math.max(0, v)],
    ]);
    return;
  }

  if(id === "softfoot"){
    ui.inputsArea.innerHTML = `
    
    <div style="margin-bottom:10px;">
  <label>Disposition des pattes</label>
  <select id="in_footScheme" style="width:100%; padding:10px; border-radius:12px; border:none;">
    <option value="standard">Standard (A HG, B HD, C BD, D BG)</option>
    <option value="invBottom">A / B / D / C (inverse bas)</option>
    <option value="rot180">Rotation 180¬∞</option>
    <option value="roles">Par r√¥les (HA, HB, BA, BB)</option>
  </select>
</div>
    
    
      <div class="row">
        <div>
          <label>Patte A (haut gauche)</label>
          <input id="in_sfA" type="number" step="0.1" value="${state.softFoot.A}">
        </div>
        <div>
          <label>Patte B (haut droite)</label>
          <input id="in_sfB" type="number" step="0.1" value="${state.softFoot.B}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Patte C (bas droite)</label>
          <input id="in_sfC" type="number" step="0.1" value="${state.softFoot.C}">
        </div>
        <div>
          <label>Patte D (bas gauche)</label>
          <input id="in_sfD" type="number" step="0.1" value="${state.softFoot.D}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Tol√©rance soft foot (mils)</label>
          <input id="in_sfTol" type="number" step="0.1" value="${state.softFootTol}">
        </div>
        <div>
          <label>Note</label>
          <div class="noteBox">La plus grande diagonale est affich√©e (soft foot seulement)
        </div>
      </div>
      </div>
    `;
    wireInputs([
      ["in_sfA", v => state.softFoot.A = Math.abs(v)],
      ["in_sfB", v => state.softFoot.B = Math.abs(v)],
      ["in_sfC", v => state.softFoot.C = Math.abs(v)],
      ["in_sfD", v => state.softFoot.D = Math.abs(v)],
      ["in_sfTol", v => state.softFootTol = Math.max(0, v)],
      ["in_footScheme", v => {
  footSchemeKey = v;
}]
    ]);
    return;
  }

if(id === "measures"){

  let html = "";

  // ===== SOUS-√âTAPE 1 ‚Äî √ò ACCOUPLEMENT =====
  if(state.measureStep === 0){
    html = `
      <div class="row">
        <div>
          <label style="color:#00a2ff;">√ò accouplement (po)</label>
          <input id="in_diam" class="c-blue" type="number" step="0.1"
                 value="${geometry.couplingDiameter}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <div class="noteBox">Mesurer le diam√®tre ext√©rieur de l‚Äôaccouplement
        </div>
      </div>
        </div>
    `;
  }

  // ===== SOUS-√âTAPE 2 ‚Äî CENTRE ‚Üí AVANT =====
  if(state.measureStep === 1){
    html = `
      <div class="row">
        <div>
          <label style="color:#4caf50;">Centre ‚Üí pattes AVANT (po)</label>
          <input id="in_centerFront" class="c-green" type="number" step="0.1"
                 value="${geometry.centerToFrontFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <div class="noteBox">Mesurer du centre de l‚Äôaccouplement jusqu‚Äôaux pattes avant du moteur
        </div>
      </div>
        </div>
    `;
  }

  // ===== SOUS-√âTAPE 3 ‚Äî AVANT ‚Üí ARRI√àRE =====
  if(state.measureStep === 2){
    html = `
      <div class="row">
        <div>
          <label style="color:#ff9800;">Pattes AVANT ‚Üí ARRI√àRE (po)</label>
          <input id="in_frontRear" class="c-orange" type="number" step="0.1"
                 value="${geometry.frontToRearFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <div class="noteBox">Mesurer la distance entre pattes avant et arri√®re du moteur
        </div>
      </div>
        </div>
    `;
  }

  ui.inputsArea.innerHTML = html;

  if(state.measureStep === 0){
    wireInputs([["in_diam", v => geometry.couplingDiameter = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 1){
    wireInputs([["in_centerFront", v => geometry.centerToFrontFeet = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 2){
    wireInputs([["in_frontRear", v => geometry.frontToRearFeet = Math.max(0.1, v)]]);
  }

  return;
}

  // =====================================================
  // ANGULARIT√â VERTICALE
  // =====================================================
  if(id === "angV"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Lecture cadran 12‚Äì6 (mils)</label>
        <input id="in_angV" type="number" step="0.1" value="${state.angV}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_angVTol" type="number" step="0.1" value="${state.angVTol}">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Note</label>
        <div class="noteBox">
          Les distances g√©om√©triques proviennent de l‚Äô√©tape 3
        </div>
      </div>
    </div>
  `;

  wireInputs([
    ["in_angV", v => state.angV = v],
    ["in_angVTol", v => state.angVTol = Math.max(0, v)]
  ]);
  return;
}

if(id === "parV"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Parall√©lisme vertical (mils)</label>
        <input id="in_parV" type="number" step="0.1" value="${state.parV}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_parVTol" type="number" step="0.1" value="${state.parVTol}">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Note</label>
        <div class="noteBox">
          Correction uniforme sur les 4 pattes
        </div>
      </div>
    </div>
  `;

  wireInputs([
    ["in_parV", v => state.parV = v],
    ["in_parVTol", v => state.parVTol = Math.max(0, v)]
  ]);
  return;
}


  // =====================================================
  // ANGULARIT√â HORIZONTALE
  // =====================================================
  if(id === "angH"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Lecture cadran 3‚Äì9 (mils)</label>
        <input id="in_angH" type="number" step="0.1" value="${state.angH}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_angHTol" type="number" step="0.1" value="${state.angHTol}">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Note</label>
        <div class="noteBox">
          Les distances g√©om√©triques proviennent de l‚Äô√©tape 3
        </div>
      </div>
    </div>
  `;

  wireInputs([
    ["in_angH", v => state.angH = v],
    ["in_angHTol", v => state.angHTol = Math.max(0, v)]
  ]);
  return;
}
  if(id === "parH"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Parall√©lisme horizontal (mils)</label>
          <input id="in_parH" type="number" step="0.1" value="${state.parH}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_parHTol" type="number" step="0.1" value="${state.parHTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_parH", v => state.parH = v],
      ["in_parHTol", v => state.parHTol = Math.max(0, v)],
    ]);
    return;
  }
}
function buildFormulaSoftFoot(){
  const sf = computeSoftFoot();

  // Valeurs entr√©es
  const A = state.softFoot.A;
  const B = state.softFoot.B;
  const C = state.softFoot.C;
  const D = state.softFoot.D;

  // Calculs
  const diagAC = sf.diagAC;
  const diagBD = sf.diagBD;
  const delta  = sf.delta;

  const corr   = sf.correction;      // 80% du delta
  const each   = corr / 2;           // r√©parti sur 2 pattes

  // Quelle diagonale est fautive?
  let faultyTxt = "Aucune (diagonales √©gales)";
  if(sf.faulty) faultyTxt = sf.faulty.join(" + ");

  return (
`Pied boiteux ‚Äî Diagonales

Diag AC = A + C
       = ${A} + ${C}
       = ${diagAC.toFixed(2)} mil

Diag BD = B + D
       = ${B} + ${D}
       = ${diagBD.toFixed(2)} mil

Œî = |Diag AC ‚àí Diag BD|
  = |${diagAC.toFixed(2)} ‚àí ${diagBD.toFixed(2)}|
  = ${delta.toFixed(2)} mil

Correction ‚âà 0.8 √ó Œî
          = 0.8 √ó ${delta.toFixed(2)}
          = ${corr.toFixed(2)} mil

Par patte (2 pattes) = Correction / 2
                     = ${corr.toFixed(2)} / 2
                     = ${each.toFixed(2)} mil

Pattes √† corriger : ${faultyTxt}`
  );
}

/* =====================================================
   Wire inputs (lecture -> state -> redraw)
===================================================== */
function wireInputs(pairs){
  pairs.forEach(([inputId, setter]) => {
    const input = document.getElementById(inputId);
    if(!input) return;

    // Autoriser la saisie libre sans calcul imm√©diat
    input.addEventListener("input", () => {
      // Ne rien faire ici ‚Üí saisie fluide
    });

    // Validation sur ENTER
    input.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        input.blur();   // force validation
      }
    });

    // Validation finale quand on quitte le champ
    input.addEventListener("blur", () => {
      let raw = input.value.trim();

      if(raw === ""){
        raw = "0";
        input.value = "0";
      }

      const v = parseFloat(raw);
      setter(Number.isFinite(v) ? v : 0);

      refreshUI();
      drawTopView();
      drawSideView();
    });
  });
}
/* =====================================================
   UI sync
===================================================== */
function refreshUI(){
  ui.stepTitle.textContent = `√âtape ${STEPS[state.step].label}`;

  const okNow = isStepOK(state.step);
  ui.stepBadge.textContent = okNow ? "OK" : "NOT OK";
  ui.stepBadge.classList.toggle("ok", okNow);
  ui.stepBadge.classList.toggle("bad", !okNow);

  renderInputsForCurrentStep();

  ui.infoBox.textContent =
    buildMessage() + "\n\n" + buildCorrectionMessage();

  // ===== FORMULES (PC) ‚Äî √âTAPE 2 SEULEMENT =====
  if(ui.formulaBox){
    if(STEPS[state.step].id === "softfoot"){
      ui.formulaBox.textContent = buildFormulaSoftFoot();
    }else{
      ui.formulaBox.textContent = "";
    }
  }
}
/* =====================================================
   Navigation
===================================================== */
function nextStep(){
  // Sous-√©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep < 2){
      state.measureStep++;
      renderAll();
      return;
    }else{
      state.measureStep = 0;
      state.step++;
      renderAll();
      return;
    }
  }

  if(isStepOK(state.step) && state.step < STEPS.length - 1){
    state.step++;
    renderAll();
  }
}

function prevStep(){
  // Sous-√©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep > 0){
      state.measureStep--;
      renderAll();
      return;
    }else{
      // revenir √† l'√©tape pr√©c√©dente
      state.step--;
      renderAll();
      return;
    }
  }

  if(state.step > 0){
    state.step--;
    renderAll();
  }
}
ui.btnPrev.addEventListener("click", prevStep);
ui.btnNext.addEventListener("click", nextStep);
/* =====================================================
   BLOC 3 ‚Äî DESSINS & SYNCHRO
===================================================== */

const topCanvas = document.getElementById("topView");
const sideCanvas = document.getElementById("sideView");
const topCtx = topCanvas.getContext("2d");
const sideCtx = sideCanvas.getContext("2d");

function resizeCanvas(canvas, ctx){
  const dpr = window.devicePixelRatio || 1;

  const rect = canvas.getBoundingClientRect();

  const w = Math.max(200, rect.width);
  const h = Math.max(200, rect.height);

  canvas.width  = w * dpr;
  canvas.height = h * dpr;

  ctx.setTransform(dpr,0,0,dpr,0,0);

  return { w, h };
}
/* =====================================================
   UTILITAIRES DESSIN
===================================================== */
function clear(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,w,h);
}

function drawDimOnly(ctx, x1, x2, y){
  ctx.beginPath();
  ctx.moveTo(x1, y);
  ctx.lineTo(x2, y);
  ctx.stroke();

  // petites barres aux extr√©mit√©s
  ctx.beginPath();
  ctx.moveTo(x1, y - 8);
  ctx.lineTo(x1, y + 8);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y - 8);
  ctx.lineTo(x2, y + 8);
  ctx.stroke();
}



function drawShimValue(ctx, x, y, value){
  if(value <= 0) return;

  ctx.fillStyle = "#ff5252";
  ctx.font = blinkPhase ? "bold 13px Arial" : "12px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`+${value.toFixed(2)} mil`, x + 14, y + 4);
}

function isBlinking(){
  return blinkPhase ? "#ff5252" : "#000";
}
function footColor(letter){
  const step = STEPS[state.step].id;
  const bad = !isStepOK(state.step);

  if(step === "softfoot" && currentView === "side"){
    return FOOT_NORMAL;
  }

  if(step === "softfoot"){
    const sf = computeSoftFoot();
    if(bad && sf.faulty && sf.faulty.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "angV"){
    const r = computeAngularVertical();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "parV" && bad){
    return isBlinking();
  }

  if(step === "angH"){
    const r = computeAngularHorizontal();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  return FOOT_NORMAL;
}
function drawFoot(ctx,x,y,label){
  ctx.fillStyle = footColor(label);
  ctx.fillRect(x-10,y-5,20,10);
  ctx.fillStyle="#fff";
  ctx.font="12px Arial";
  ctx.textAlign="center";
  ctx.fillText(label,x,y+18);
}

function drawArrow(ctx, x1, y1, x2, y2, color="#ff5252"){
  const head = 12;
  const angle = Math.atan2(y2-y1, x2-x1);

  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 3;

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(
    x2 - head * Math.cos(angle - Math.PI/6),
    y2 - head * Math.sin(angle - Math.PI/6)
  );
  ctx.lineTo(
    x2 - head * Math.cos(angle + Math.PI/6),
    y2 - head * Math.sin(angle + Math.PI/6)
  );
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawMathBlock(ctx, x, y, lines){
  ctx.save();
  ctx.font = "13px Consolas, monospace";
  ctx.fillStyle = "rgba(255,255,255,.95)";
  ctx.textAlign = "left";

  // petit fond discret
  const pad = 10;
  const lineH = 18;
  const boxW = 360;
  const boxH = pad*2 + lines.length*lineH;

  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.fillRect(x-pad, y-pad, boxW, boxH);

  ctx.fillStyle = "rgba(255,255,255,.95)";
  let dy = 0;
  for(const l of lines){
    ctx.fillText(l, x, y + dy);
    dy += lineH;
  }

  ctx.restore();
}


function drawDimLine(ctx, x1, x2, y, label){
  const left = Math.min(x1, x2);
  const right = Math.max(x1, x2);

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.fillStyle   = "rgba(255,255,255,.90)";
  ctx.lineWidth = 2;

  // ligne principale
  ctx.beginPath();
  ctx.moveTo(left, y);
  ctx.lineTo(right, y);
  ctx.stroke();

  // "ticks" aux extr√©mit√©s
  ctx.beginPath();
  ctx.moveTo(left, y-8);  ctx.lineTo(left, y+8);
  ctx.moveTo(right, y-8); ctx.lineTo(right, y+8);
  ctx.stroke();

  // texte centr√©
  ctx.font = "12px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText(label, (left + right)/2, y - 10);

  ctx.restore();
}




function drawCouplingDiameter(ctx, cx, cy, diam){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.lineWidth = 2;

  // petit cercle indicatif (pas √† l'√©chelle)
  ctx.beginPath();
  ctx.arc(cx, cy, 18, 0, Math.PI*2);
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,.90)";
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  ctx.fillText(`√ò = ${diam} po`, cx + 24, cy);

  ctx.restore();
}

function blinkColor(col){
  const t = Math.floor(Date.now() / 350) % 2;
  return t ? "#ff5252" : col;
}

function drawTopView(){

  currentView = "top";

  const {w,h} = resizeCanvas(topCanvas, topCtx);
  const ctx = topCtx;
  clear(ctx,w,h);

  const scale   = visualGain;
  const rotGain = visualGain * 0.00035;

  // ====================================================
  //   R√âF√âRENCES FIXES (POMPE + SOCLE)
  // ====================================================
  const baseCy = h * 0.5;
  const baseCx = w * 0.30;

  // ====================================================
//   MOTEUR MOBILE ‚Äî PARALL√âLISME HORIZONTAL (D√âPLACEMENT EN X)
// ====================================================
const maxShift = 60;
const shift = Math.max(-maxShift, Math.min(maxShift, state.parH * scale));

const motorCx = baseCx;

const motorCy = baseCy + (
  STEPS[state.step].id === "parH"
    ? shift
    : 0
);

  const { motorW, motorH, pumpW, pumpH, gap, shaftH, coupW, coupH } = GEOM;
  // ====================================================
//   PATTES √Ä POUSSER ‚Äî PARALL√âLISME HORIZONTAL
// ====================================================
let flashFeet = [];

if(STEPS[state.step].id === "parH"){
  if(state.parH > 0) flashFeet = ["C","D"];
  if(state.parH < 0) flashFeet = ["A","B"];
}

  const footW = 24;
  const footH = 12;

  // ====================================================
  //   SEMELLE COMMUNE (FIXE ‚Äì R√âF√âRENCE)
  // ====================================================
  const baseMargin = 40;

  ctx.fillStyle = "#1a235a";
  ctx.fillRect(
    baseCx - motorW/2 - baseMargin,
    baseCy - motorH/2 - baseMargin,
    motorW + gap + pumpW + baseMargin*2,
    motorH + baseMargin*2
  );

  // ====================================================
  //   PARAM√àTRE ANGULAIRE (ANGULARIT√â HORIZONTALE)
  // ====================================================
  const ang =
    STEPS[state.step].id === "angH"
      ? state.angH * dialSign * rotGain
      : 0;

  // ====================================================
  //   COORDONN√âES DES PATTES (EN POSITION MOTEUR)
  //   IMPORTANT: utiliser motorCx / motorCy (pas baseCy)
  // ====================================================
  const P = {
    A:{x: motorCx - motorW/2 + 24, y: motorCy - motorH/2 + 18},
    B:{x: motorCx + motorW/2 - 24, y: motorCy - motorH/2 + 18},
    D:{x: motorCx - motorW/2 + 24, y: motorCy + motorH/2 - 18},
    C:{x: motorCx + motorW/2 - 24, y: motorCy + motorH/2 - 18},
  };

  // ====================================================
  //   PIVOT M√âCANIQUE (OPTIONNEL)
  //   - ang > 0  => pivot coin ext√©rieur C
  //   - ang < 0  => pivot coin ext√©rieur D
  //   - ang = 0  => pivot centre
  // ====================================================
  let pivot = {x: motorCx, y: motorCy};
  if(ang > 0) pivot = P.C;
  if(ang < 0) pivot = P.D;

  // ====================================================
  //   BLOC MOTEUR (MOBILE) : MOTEUR + ARBRE + ¬Ω ACCOUPLEMENT + AXE
  // ====================================================
  ctx.save();
  ctx.translate(pivot.x, pivot.y);
  ctx.rotate(ang);
  ctx.translate(-pivot.x, -pivot.y);

  // ---- moteur ----
  ctx.fillStyle = "#00a2ff";
  ctx.fillRect(motorCx - motorW/2, motorCy - motorH/2, motorW, motorH);

  function drawPad(letter){
  const {x,y} = P[letter];
  let col = footColor(letter);

  if(flashFeet.includes(letter)){
    if(typeof blinkColor === "function"){
      col = blinkColor(col);
    }
  }

  ctx.fillStyle = col;
  ctx.fillRect(x - footW/2, y - footH/2, footW, footH);
}
  drawPad("A"); drawPad("B"); drawPad("C"); drawPad("D");

  // ---- arbre moteur ----
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    motorCx + motorW/2,
    motorCy - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // ---- demi-accouplement moteur ----
  const coupX = motorCx + motorW/2 + gap/2;
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(coupX - 14, motorCy - coupH/2, coupW, coupH);

  // ---- AXE MOTEUR (AU PREMIER PLAN, DANS LE BLOC ROTATIF) ----
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.setLineDash([5,4]);
  ctx.lineWidth = 2.5;

  ctx.beginPath();
  ctx.moveTo(motorCx - motorW/2 - 90, motorCy);
  ctx.lineTo(motorCx + motorW/2 + gap/2, motorCy);
  ctx.stroke();
  ctx.restore();

  ctx.restore(); // FIN BLOC ROTATIF MOTEUR
// ====================================================
//   ANGULARIT√â HORIZONTALE ‚Äî FL√àCHES + CALCUL EXPLICITE
//   (AU PREMIER PLAN)
// ====================================================
// ====================================================
//   ANGULARIT√â HORIZONTALE ‚Äî FL√àCHES = POUSSER (SENS R√âEL)
// ====================================================
if(STEPS[state.step].id === "angH"){

  const v = state.angH * dialSign;
  const len = 60;

  // POSITIF ‚Üí moteur inclin√© DROITE ‚Üí pousser A + C
  if(v > 0){

    // A ‚Üí pousser vers le BAS
    drawArrow(ctx,
      P.A.x, P.A.y - len,
      P.A.x, P.A.y
    );

    // C ‚Üí pousser vers le HAUT
    drawArrow(ctx,
      P.C.x, P.C.y + len,
      P.C.x, P.C.y
    );
  }

  // N√âGATIF ‚Üí moteur inclin√© GAUCHE ‚Üí pousser B + D
  if(v < 0){

    // B ‚Üí pousser vers le BAS
    drawArrow(ctx,
      P.B.x, P.B.y - len,
      P.B.x, P.B.y
    );

    // D ‚Üí pousser vers le HAUT
    drawArrow(ctx,
      P.D.x, P.D.y + len,
      P.D.x, P.D.y
    );
  }
}
  // ====================================================
  //   BLOC POMPE (FIXE) : POMPE + ARBRE + ¬Ω ACCOUPLEMENT + AXE
  // ====================================================
  const pumpX = baseCx + motorW/2 + gap;

  // ---- pompe ----
  ctx.fillStyle="#ff9800";
  ctx.fillRect(pumpX, baseCy - pumpH/2, pumpW, pumpH);

  // ---- arbre pompe ----
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    baseCx + motorW/2 + gap/2 + 14,
    baseCy - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // ---- demi-accouplement pompe ----
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(
    baseCx + motorW/2 + gap/2 + 4,
    baseCy - coupH/2,
    coupW,
    coupH
  );

  // ---- AXE POMPE (FIXE) ----
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.setLineDash([5,4]);
  ctx.lineWidth = 2.5;

  ctx.beginPath();
  ctx.moveTo(baseCx + motorW/2 + gap/2, baseCy);
  ctx.lineTo(baseCx + motorW/2 + gap + pumpW + 90, baseCy);
  ctx.stroke();
  ctx.restore();

  // ====================================================
  //   LETTRES (UTILISER LES COORDONN√âES MOTEUR P)
  // ====================================================
  ctx.fillStyle = "#fff";
  ctx.font = "14px Arial";
  ctx.textAlign = "center";

  const labelOffset = 26;
  ctx.fillText(labelFoot("A"), P.A.x, P.A.y - labelOffset);
ctx.fillText(labelFoot("B"), P.B.x, P.B.y - labelOffset);
ctx.fillText(labelFoot("D"), P.D.x, P.D.y + labelOffset + 6);
ctx.fillText(labelFoot("C"), P.C.x, P.C.y + labelOffset + 6);
  // ====================================================
  //   TITRES
  // ====================================================
  ctx.fillText("MOTEUR (mobile)", motorCx, motorCy - motorH/2 - 18);
  ctx.fillText("POMPE (fixe)", pumpX + pumpW/2, baseCy - pumpH/2 - 18);
}

function drawSideView(){

  currentView = "side";

  const {w,h} = resizeCanvas(sideCanvas, sideCtx);
  const ctx = sideCtx;
  clear(ctx,w,h);

  const scale   = visualGain;
  const rotGain = visualGain * 0.00035;

  let baseCy = h * 0.55;
  let baseCx = w * 0.30;

  let cy = baseCy + (
    STEPS[state.step].id === "parV"
      ? state.parV * scale
      : 0
  );

  let cx = baseCx;

  const axisPumpY  = baseCy;   // axe pompe = FIXE
  const axisMotorY = cy;       // axe moteur = MOBILE

  const { motorW, motorH, pumpW, pumpH, gap, shaftH, coupW, coupH } = GEOM;

  const footW = 24;
  const footH = 10;

  const rearFootX  = cx - motorW/2 + footW/2;
  const frontFootX = cx + motorW/2 - footW/2;

  // ====================================================
  //   SEMELLE COMMUNE
  // ====================================================
  const baseMargin = 40;
  const baseTop = baseCy + pumpH/2 + footH - 2;

  ctx.fillStyle = "#1a235a";
  ctx.fillRect(
    cx - motorW/2 - baseMargin,
    baseTop,
    motorW + gap + pumpW + baseMargin*2,
    16
  );

  // ====================================================
  //   PARAM√àTRE ANGULAIRE
  // ====================================================
  const ang =
    STEPS[state.step].id === "angV"
      ? -state.angV * dialSign * rotGain
      : 0;

  // ====================================================
  //   POMPE FIXE + ARBRE + ¬Ω ACCOUPLEMENT
  // ====================================================
  const pumpX = cx + motorW/2 + gap;
  const coupX = cx + motorW/2 + gap/2;

  // pompe
  ctx.fillStyle = "#ff9800";
  ctx.fillRect(pumpX, baseCy - pumpH/2, pumpW, pumpH);

  // pattes pompe
  ctx.fillRect(pumpX + 12, baseCy + pumpH/2 - 2, footW, footH);
  ctx.fillRect(pumpX + pumpW - 12 - footW, baseCy + pumpH/2 - 2, footW, footH);

  // arbre pompe
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    coupX + 14,
    axisPumpY - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // demi-accouplement pompe
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(
    coupX + 4,
    axisPumpY - coupH/2,
    coupW,
    coupH
  );

// ====================================================
//   MOTEUR + ARBRE + ¬Ω ACCOUPLEMENT + AXE
//   BLOC SOLIDAIRE ‚Äî PIVOT M√âCANIQUE R√âALISTE
// ====================================================

// pivots m√©caniques r√©els
const pivotDX = rearFootX;
const pivotCX = frontFootX;
const pivotY  = cy + motorH/2;

// choix automatique du pied porteur
const pivotX = (ang >= 0) ? pivotCX : pivotDX;

ctx.save();
ctx.translate(pivotX, pivotY);
ctx.rotate(ang);
ctx.translate(-pivotX, -pivotY);

// ---- MOTEUR ----
ctx.fillStyle = "#00a2ff";
ctx.fillRect(cx - motorW/2, cy - motorH/2, motorW, motorH);

// pattes moteur
ctx.fillRect(rearFootX - footW/2,  cy + motorH/2 - 2, footW, footH);
ctx.fillRect(frontFootX - footW/2, cy + motorH/2 - 2, footW, footH);

// lettres
ctx.fillStyle = "#fff";
ctx.font = "14px Arial";
ctx.textAlign = "center";
ctx.fillText("D", rearFootX,  cy + motorH/2 + 24);
ctx.fillText("C", frontFootX, cy + motorH/2 + 24);

// ---- ARBRE MOTEUR ----
ctx.fillStyle = "#bbbbbb";
ctx.fillRect(
  cx + motorW/2,
  cy - shaftH/2,
  (gap/2) - 8,
  shaftH
);

// ---- DEMI-ACCOUPLEMENT MOTEUR ----
ctx.fillStyle = "#cfcfcf";
ctx.fillRect(
  cx + motorW/2 + gap/2 - 14,
  cy - coupH/2,
  coupW,
  coupH
);

// ---- AXE MOTEUR (DERNIER = PREMIER PLAN) ----
ctx.save();
ctx.strokeStyle = "rgba(255,255,255,0.95)";
ctx.setLineDash([5,4]);
ctx.lineWidth = 2.5;

ctx.beginPath();
ctx.moveTo(cx - motorW/2 - 90, cy);
ctx.lineTo(cx + motorW/2 + gap/2, cy);
ctx.stroke();
ctx.restore();

ctx.restore();
  // ---- AXE POMPE (FIXE) ----
ctx.save();
ctx.strokeStyle = "rgba(255,255,255,0.95)";
ctx.setLineDash([5,6]);
ctx.lineWidth = 2;
ctx.shadowColor = "rgba(255,255,255,0.6)";
ctx.shadowBlur = 3;

ctx.beginPath();
ctx.moveTo(cx + motorW/2 + gap/2, axisPumpY);
ctx.lineTo(cx + motorW/2 + gap + pumpW + 100, axisPumpY);
ctx.stroke();
ctx.restore();
  // ====================================================
  //   TITRES
  // ====================================================
  ctx.fillStyle="#fff";
  ctx.font="14px Arial";
  ctx.textAlign="center";
  ctx.fillText("MOTEUR (mobile)", cx, cy - motorH/2 - 14);
  ctx.fillText("POMPE (fixe)", pumpX + pumpW/2, baseCy - pumpH/2 - 14);

  // ===============================
  //   MESURES G√âOM√âTRIQUES
  // ===============================
  if(STEPS[state.step].id === "measures"){

    const sub = state.measureStep;
    const color = ["#00a2ff","#4caf50","#ff9800"][sub];

    ctx.strokeStyle = color;
    ctx.lineWidth = 3;

    // 0 ‚Üí √ò ACCOUPLEMENT
    if(sub === 0){
      const r = 26;
      const x = baseCx + motorW/2 + gap/2;

      ctx.beginPath();
      ctx.moveTo(x, baseCy - r);
      ctx.lineTo(x, baseCy + r);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x - 8, baseCy - r);
      ctx.lineTo(x + 8, baseCy - r);
      ctx.moveTo(x - 8, baseCy + r);
      ctx.lineTo(x + 8, baseCy + r);
      ctx.stroke();
      return;
    }

    // 1 ‚Üí CENTRE ‚Üí PATTES AVANT
    if(sub === 1){
      const x1 = coupX;
      const x2 = frontFootX;
      const y  = cy + motorH/2 + 30;

      ctx.beginPath();
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x1, y - 8);
      ctx.lineTo(x1, y + 8);
      ctx.moveTo(x2, y - 8);
      ctx.lineTo(x2, y + 8);
      ctx.stroke();
      return;
    }

    // 2 ‚Üí AVANT ‚Üí ARRI√àRE
    if(sub === 2){
      const x1 = rearFootX;
      const x2 = frontFootX;
      const y  = cy + motorH/2 + 52;

      ctx.beginPath();
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x1, y - 8);
      ctx.lineTo(x1, y + 8);
      ctx.moveTo(x2, y - 8);
      ctx.lineTo(x2, y + 8);
      ctx.stroke();
      return;
    }
  }
}
function renderAll(){
  refreshUI();
  drawTopView();
  drawSideView();
}


window.addEventListener("load", () => {

  // ===== ORIENTATION =====
  const layoutSelect = document.getElementById("footLayout");
  if(layoutSelect){
    layoutSelect.value = footLayout;

    layoutSelect.addEventListener("change", () => {
      footLayout = layoutSelect.value;
      renderAll();
    });
  }

  // ===== ‚ÑπÔ∏è AIDE / FORMULES =====
  const btnHelp = document.getElementById("btnHelp");
  const btnHelpClose = document.getElementById("btnHelpClose");
  const btnHelpPrint = document.getElementById("btnHelpPrint");
  const backdrop = document.getElementById("helpBackdrop");

  if(btnHelp) btnHelp.addEventListener("click", openHelp);
  if(btnHelpClose) btnHelpClose.addEventListener("click", closeHelp);
  if(btnHelpPrint) btnHelpPrint.addEventListener("click", printHelp);
  if(backdrop) backdrop.addEventListener("click", closeHelp);

  document.addEventListener("keydown", (e) => {
    if(e.key === "Escape") closeHelp();
  });

  renderAll();
});
  }

  renderAll();
});
</script>




</body>
</html>
