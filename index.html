<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement ‚Äì Comparateur invers√© (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.75);
  --ok:#4caf50;
  --bad:#ff5252;
  --accent:#00a2ff;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:Arial,system-ui,sans-serif;
}

/* ===== HEADER ===== */
.headerBar{
  position:sticky;
  top:0;
  z-index:50;
  background:linear-gradient(to bottom, rgba(11,20,54,.98), rgba(11,20,54,.88));
  border-bottom:1px solid rgba(255,255,255,.08);
  padding:12px;
  text-align:center;
  font-weight:900;
  font-size:16px;
}

/* ===== LAYOUT ===== */
.wrap{
  padding:12px;
  max-width:1100px;
  margin:0 auto;
}
.grid{
  display:grid;
  gap:12px;
}
@media (min-width:900px){
  .grid{ grid-template-columns:1fr 1fr; }
}

/* ===== CARDS ===== */
.card{
  background:var(--card);
  border-radius:14px;
  padding:12px;
  border:1px solid rgba(255,255,255,.06);
}
h2{
  margin:0 0 8px;
  font-size:15px;
}
p{
  margin:6px 0;
  font-size:13px;
  color:var(--muted);
}

/* ===== √âTAPES ===== */
.step{
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:12px;
  background:rgba(255,255,255,.03);
}
.stepHead{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:6px;
}
.stepTitle{
  font-weight:900;
  font-size:14px;
}
.badge{
  font-size:12px;
  font-weight:900;
  padding:4px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
}
.badge.ok{ background:rgba(76,175,80,.15); }
.badge.bad{ background:rgba(255,82,82,.15); }

/* ===== INPUTS ===== */
.row{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
}
@media(max-width:420px){
  .row{ grid-template-columns:1fr; }
}
label{
  font-size:12px;
  color:var(--muted);
}
input{
  width:100%;
  padding:10px;
  font-size:16px;
  border-radius:12px;
  border:none;
}

/* ===== NAV ===== */
.navRow{
  display:flex;
  gap:10px;
  margin-top:10px;
}
button{
  flex:1;
  padding:12px;
  font-size:16px;
  border:none;
  border-radius:12px;
  background:var(--accent);
  color:#fff;
  font-weight:900;
}
button.secondary{
  background:rgba(255,255,255,.15);
}

/* ===== CANVAS ===== */
.canvasGrid{
  display:grid;
  gap:12px;
}
@media(min-width:900px){
  .canvasGrid{ grid-template-columns:1fr 1fr; }
}
.canvasCard{
  background:#000;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.canvasHeader{
  padding:8px 12px;
  font-size:13px;
  font-weight:900;
  background:rgba(0,0,0,.35);
}
canvas{
  width:100%;
  height:260px;
  display:block;
}
@media(min-width:900px){
  canvas{ height:320px; }
}

/* ===== INFO ===== */
.infoBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.2);
  font-size:12px;
  white-space:pre-line;
}
/* ===== FORMULES (PC seulement) ===== */
.formulaBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.25);
  font-size:13px;
  font-family:Consolas, monospace;
  line-height:1.45;
  white-space:pre-line;
  display:none; /* cach√© par d√©faut (mobile) */
}
@media (min-width:900px){
  .formulaBox{ display:block; } /* visible PC */
}

.c-blue{ border:2px solid #00a2ff !important; }
.c-green{ border:2px solid #4caf50 !important; }
.c-orange{ border:2px solid #ff9800 !important; }

.noteBox{
  background:rgba(255,255,255,.10);
  border-radius:12px;
  padding:10px 12px;
  font-size:13px;
  color:rgba(234,241,255,.9);
  line-height:1.4;
}

.btnActive{
  background:#00a2ff !important;
  color:white !important;
}


</style>
</head>

<body>

<div class="headerBar">
  Alignement d‚Äôarbres ‚Äî Comparateur invers√© (mils)
</div>

<div class="wrap">
  <div class="grid">

    <!-- ===== √âTAPES ===== -->
  



      <div class="step" id="stepCard">
  <div class="stepHead">
    <div class="stepTitle" id="stepTitle">‚Äî</div>
    <div class="badge" id="stepBadge">Info</div>
  </div>

  <!-- Inputs g√©n√©r√©s par JS selon l'√©tape -->
  <div id="inputsArea"></div>
  <div id="formulaBox" class="formulaBox"></div>

  <div class="navRow">
    <button class="secondary" id="btnPrev" type="button">‚óÄ Pr√©c√©dent</button>
    <button id="btnNext" type="button">Suivant ‚ñ∂</button>
  </div>

  <div class="infoBox" id="infoBox">‚Äî</div>
</div>
    </div>

    <!-- ===== DESSINS ===== -->
    <div class="card">
      <h2>Dessins p√©dagogiques</h2>
      <p>
Vue de dessus (horizontal) et vue de profil (vertical).
Les pattes A / B / C / D seront affich√©es ici.
      </p>

      <div class="canvasGrid">
        <div class="canvasCard">
          <div class="canvasHeader">Vue de dessus (TopView)</div>
          <canvas id="topView"></canvas>
        </div>
        <div class="canvasCard">
          <div class="canvasHeader">Vue de profil (SideView)</div>
          <canvas id="sideView"></canvas>
        </div>
      </div>
    </div>

  </div>
</div>
<div class="card" style="margin-top:12px;">
  <h2>Amplification du dessin</h2>

  <label>Effet visuel :</label>
  <input id="gainSlider" type="range" min="1" max="20" value="6" step="1" style="width:100%">

  <div style="display:flex; justify-content:space-between; font-size:12px; opacity:.8;">
    <span>R√©aliste</span>
    <span>P√©dagogique</span>
  </div>
</div>

<script>
"use strict";
let dialSign = 1;   // +1 = CW normal,  -1 = CW invers√©
let correctionMode = "add";  // "add" | "remove"
let currentView = "top"; // "top" | "side"
let blinkPhase = true;
let visualGain = 6;
const FOOT_NORMAL = "#0070c0";   // bleu fonc√© visible


const gainSlider = document.getElementById("gainSlider");
if(gainSlider){
  gainSlider.addEventListener("input", () => {
    visualGain = parseFloat(gainSlider.value) || 1;
    drawSideView();
    drawTopView();
  });
}
setInterval(() => {
  blinkPhase = !blinkPhase;

  // ‚ö†Ô∏è JAMAIS toucher √† l‚ÄôUI ici
  drawTopView();
  drawSideView();
}, 600);


const GEOM = {
  motorW: 200,
  motorH: 80,

  pumpW: 130,
  pumpH: 80,

  gap: 70,

  shaftH: 12,   // diam√®tre visuel arbre
  coupH: 56,    // hauteur accouplement
  coupW: 10     // largeur accouplement
};
/* =====================================================
   √âTAT GLOBAL (mils)
===================================================== */
const state = {
  step: 0,
  measureStep: 0,
  
  runout: 0,
  runoutTol: 2,

  softFoot: { A:0, B:0, C:0, D:0 },
  softFootTol: 3,

  angV: 0,
  angVTol: 1,

  parV: 0,
  parVTol: 1,

  angH: 0,
  angHTol: 1,

  parH: 0,
  parHTol: 1
};
/* =====================================================
   PARAM√àTRES G√âOM√âTRIQUES (pouces)
===================================================== */
const geometry = {
  couplingDiameter: 3,      // √ò accouplement
  centerToFrontFeet: 6,    // Centre ‚Üí pattes AVANT
  frontToRearFeet: 10      // Pattes AVANT ‚Üí ARRI√àRE
};
/* =====================================================
   D√âFINITION DES √âTAPES
===================================================== */
const STEPS = [
  { id:"runout",  label:"1 ‚Äî Voilage" },
  { id:"softfoot",label:"2 ‚Äî Pied boiteux" },
  { id:"measures",label:"3 ‚Äî Mesures g√©om√©triques" },

  { id:"angV",    label:"4 ‚Äî Angularit√© verticale" },
  { id:"parV",    label:"5 ‚Äî Parall√©lisme vertical" },

  { id:"angH",    label:"6 ‚Äî Angularit√© horizontale" },
  { id:"parH",    label:"7 ‚Äî Parall√©lisme horizontal" }
];
/* =====================================================
   UTILITAIRES
===================================================== */
const abs = Math.abs;
const ok = (v,t) => abs(v) <= t;

/* =====================================================
   PIED BOITEUX ‚Äî DIAGONALES
   AC vs BD
===================================================== */
function computeSoftFoot(){
  const {A,B,C,D} = state.softFoot;
  const diagAC = A + C;
  const diagBD = B + D;
  const delta = abs(diagAC - diagBD);
  const correction = delta * 0.8;

  let faulty = null;
  if(diagAC > diagBD) faulty = ["A","C"];
  if(diagBD > diagAC) faulty = ["B","D"];

  return {
    diagAC,
    diagBD,
    delta,
    correction,
    faulty
  };
}

/* =====================================================
   ANGULARIT√â VERTICALE ‚Äî PAIRES
   Avant = BC
   Arri√®re = AD
===================================================== */
function computeAngularVertical(){

  const v = state.angV * dialSign;

  // POSITIF ‚Üí ARRI√àRE trop bas
  if(v > 0){

    if(correctionMode === "add"){
      return {
        pair:["A","D"],
        direction:"ARRI√àRE trop bas ‚Äî AJOUTER sous A + D"
      };
    }else{
      return {
        pair:["B","C"],
        direction:"ARRI√àRE trop bas ‚Äî ENLEVER sous B + C"
      };
    }

  }

  // N√âGATIF ‚Üí AVANT trop bas
  if(v < 0){

    if(correctionMode === "add"){
      return {
        pair:["B","C"],
        direction:"AVANT trop bas ‚Äî AJOUTER sous B + C"
      };
    }else{
      return {
        pair:["A","D"],
        direction:"AVANT trop bas ‚Äî ENLEVER sous A + D"
      };
    }

  }

  return null;
}
/* =====================================================
   PARALL√âLISME VERTICAL ‚Äî 4 PATTES
===================================================== */
function computeParallelVertical(){
  if(state.parV > 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop bas" };
  }
  if(state.parV < 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop haut" };
  }
  return null;
}
/* =====================================================
   ANGULARIT√â HORIZONTALE ‚Äî TOP VIEW
===================================================== */
function computeAngularHorizontal(){
  if(state.angH * dialSign > 0){
    return { pair:["B","D"], direction:"Inclin√© droite" };
  }
  if(state.angH * dialSign < 0){
    return { pair:["A","C"], direction:"Inclin√© gauche" };
  }
  return null;
}

/* =====================================================
   PARALL√âLISME HORIZONTAL ‚Äî PAIRES
===================================================== */
function computeParallelHorizontal(){
  if(state.parH > 0){
    return {
      pair:["A","B"],
      direction:"Moteur trop √† droite ‚Üí d√©placer vers la GAUCHE"
    };
  }
  if(state.parH < 0){
    return {
      pair:["C","D"],
      direction:"Moteur trop √† gauche ‚Üí d√©placer vers la DROITE"
    };
  }
  return null;
}
/* =====================================================
   CALCUL CORRECTION ANGULAIRE (mils r√©els)
   B √ó C / A
===================================================== */
function computeAngularShim(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const C = Math.abs(state.angV); // lecture cadran (mils)

  if(A <= 0) return 0;

  return (B * C) / A;
}

function computeAngularShimH(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const C = Math.abs(state.angH); // lecture cadran horizontale (mils)

  if(A <= 0) return 0;
  return (B * C) / A;
}



function computeAngularShimsVertical(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const D = geometry.frontToRearFeet;
  const C = Math.abs(state.angV * dialSign);

  if(A <= 0) return { front:0, rear:0 };

  return {
    front: (B * C) / A,
    rear: ((B + D) * C) / A
  };
}

function computeAngularShimsHorizontal(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const D = geometry.frontToRearFeet;
  const C = Math.abs(state.angH * dialSign);

  if(A <= 0) return { front:0, rear:0 };

  return {
    front: (B * C) / A,
    rear: ((B + D) * C) / A
  };
}
/* =====================================================
   VALIDATION PAR √âTAPE
===================================================== */
function isStepOK(stepIndex){
  const id = STEPS[stepIndex].id;

  if(id === "measures"){
    return geometry.couplingDiameter > 0 &&
           geometry.centerToFrontFeet > 0 &&
           geometry.frontToRearFeet > 0;
  }

  if(id === "runout")  return ok(state.runout, state.runoutTol);
  if(id === "softfoot")return computeSoftFoot().delta <= state.softFootTol;

  if(id === "angV")    return ok(state.angV, state.angVTol);
  if(id === "parV")    return ok(state.parV, state.parVTol);

  if(id === "angH")    return ok(state.angH, state.angHTol);
  if(id === "parH")    return ok(state.parH, state.parHTol);

  return true;
}
/* =====================================================
   MESSAGE TEXTE (ZONE INFO)
===================================================== */
function buildMessage(){
  const step = STEPS[state.step];
  let txt = `√âtape ${step.label}\n\n`;

  if(!isStepOK(state.step)){
    txt += "‚ö†Ô∏è Hors tol√©rance\n\n";
  }else{
    txt += "‚úÖ Dans la tol√©rance\n\n";
  }

  if(step.id === "softfoot"){
    const sf = computeSoftFoot();
    txt += `Diag AC = ${sf.diagAC}\n`;
    txt += `Diag BD = ${sf.diagBD}\n`;
    txt += `Œî = ${sf.delta}\n`;
    txt += `Correction ‚âà ${sf.correction}\n`;
    if(sf.faulty){
      txt += `Pattes √† corriger : ${sf.faulty.join(" + ")}`;
    }
  }

  return txt;
}


/* =====================================================
   UI ‚Äî DOM
===================================================== */
const ui = {
  stepTitle: document.getElementById("stepTitle"),
  stepBadge: document.getElementById("stepBadge"),
  inputsArea: document.getElementById("inputsArea"),
  infoBox: document.getElementById("infoBox"),
  btnPrev: document.getElementById("btnPrev"),
  btnNext: document.getElementById("btnNext"),
    formulaBox: document.getElementById("formulaBox"),
};

/* =====================================================
   MESSAGES DE CORRECTION P√âDAGOGIQUES
===================================================== */

function buildCorrectionMessage(){
  const stepId = STEPS[state.step].id;
  let msg = "";

  // ---------- PIED BOITEUX ----------
  if(stepId === "softfoot"){
    const sf = computeSoftFoot();
    if(sf.delta <= state.softFootTol){
      return "‚úîÔ∏è Pied boiteux corrig√© ‚Äî aucune cale requise.";
    }

    const each = (sf.correction / 2).toFixed(1);
    msg += "ü¶∂ Pied boiteux d√©tect√©\n\n";
    msg += `‚ûï Ajouter **+${each} mil** sous les pattes :\n`;
    msg += `üëâ ${sf.faulty.join(" + ")}\n`;
    msg += "\n‚ö†Ô∏è Toujours corriger en DIAGONALE";
    return msg;
  }

  // ---------- ANGULARIT√â VERTICALE ----------
  if(stepId === "angV"){

    if(ok(state.angV, state.angVTol)){
      return "‚úîÔ∏è Angularit√© verticale conforme.";
    }

    const v = state.angV * dialSign;
    const shims = computeAngularShimsVertical();

    const front = shims.front.toFixed(2);
    const rear  = shims.rear.toFixed(2);

    msg += "üìê Angularit√© verticale\n\n";
    msg += "Correction g√©om√©trique √©quivalente :\n";
    msg += `‚Ä¢ AVANT : ${front} mil\n`;
    msg += `‚Ä¢ ARRI√àRE : ${rear} mil\n\n`;

    if(v > 0){
      msg += "Diagnostic : ARRI√àRE trop bas\n\n";
      msg += "Solutions m√©caniques possibles :\n";
      msg += `‚ûï Ajouter ${rear} mil sous : A + D\n`;
      msg += `OU\n`;
      msg += `‚ûñ Enlever ${front} mil sous : B + C`;
    }

    if(v < 0){
      msg += "Diagnostic : AVANT trop bas\n\n";
      msg += "Solutions m√©caniques possibles :\n";
      msg += `‚ûï Ajouter ${front} mil sous : B + C\n`;
      msg += `OU\n`;
      msg += `‚ûñ Enlever ${rear} mil sous : A + D`;
    }

    return msg;
  }

  // ---------- PARALL√âLISME VERTICAL ----------
  if(stepId === "parV"){

    if(ok(state.parV, state.parVTol)){
      return "‚úîÔ∏è Parall√©lisme vertical conforme.";
    }

    const amt = Math.abs(state.parV).toFixed(2);

    msg += "‚¨ÜÔ∏è Parall√©lisme vertical\n\n";

    if(state.parV > 0){
      msg += "Diagnostic : moteur trop bas\n\n";
      msg += "Correction :\n";
      msg += `‚ûï Ajouter +${amt} mil sous : A + B + C + D\n`;
      msg += "(m√™me quantit√© sur les 4 pattes)";
    }else{
      msg += "Diagnostic : moteur trop haut\n\n";
      msg += "Correction :\n";
      msg += `‚ûñ Enlever ${amt} mil sous : A + B + C + D\n`;
      msg += "(m√™me quantit√© sur les 4 pattes)";
    }

    return msg;
  }

  // ---------- ANGULARIT√â HORIZONTALE ----------
  if(stepId === "angH"){

    if(ok(state.angH, state.angHTol)){
      return "‚úîÔ∏è Angularit√© horizontale conforme.";
    }

    const v = state.angH * dialSign;
    const shims = computeAngularShimsHorizontal();

    const front = shims.front.toFixed(2);
    const rear  = shims.rear.toFixed(2);

    msg += "‚ÜîÔ∏è Angularit√© horizontale\n\n";
    msg += "Correction g√©om√©trique √©quivalente :\n";
    msg += `‚Ä¢ AVANT : ${front} mil\n`;
    msg += `‚Ä¢ ARRI√àRE : ${rear} mil\n\n`;

    if(v > 0){
      msg += "Diagnostic : moteur inclin√© vers la DROITE\n\n";
      msg += "Solutions m√©caniques possibles :\n";
      msg += `‚û°Ô∏è D√©placer le moteur vers la GAUCHE\n`;
      msg += `(agir principalement sur : B + D)`;
    }

    if(v < 0){
      msg += "Diagnostic : moteur inclin√© vers la GAUCHE\n\n";
      msg += "Solutions m√©caniques possibles :\n";
      msg += `‚û°Ô∏è D√©placer le moteur vers la DROITE\n`;
      msg += `(agir principalement sur : A + C)`;
    }

    return msg;
  }

  // ---------- PARALL√âLISME HORIZONTAL ----------
  if(stepId === "parH"){

    if(ok(state.parH, state.parHTol)){
      return "‚úîÔ∏è Parall√©lisme horizontal conforme.";
    }

    const amt = Math.abs(state.parH).toFixed(2);
    const r = computeParallelHorizontal();

    msg += "‚ÜîÔ∏è Parall√©lisme horizontal\n\n";
    msg += r.direction + "\n\n";

    msg += "Correction :\n";
    msg += `‚ûï D√©placer le moteur de ${amt} mil c√¥t√© :\n`;
    msg += `üëâ ${r.pair.join(" + ")}\n`;
    msg += "(translation lat√©rale pure ‚Äî sans rotation)";

    return msg;
  }

  // ---------- PAR D√âFAUT ----------
  return "";
}



/* =====================================================
   UI ‚Äî Inputs par √©tape (avec IDs)
===================================================== */
function renderInputsForCurrentStep(){
  const id = STEPS[state.step].id;

  // IMPORTANT: valeurs par d√©faut = 0, tol√©rances ‚â† 0
  if(id === "runout"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Voilage (mils)</label>
          <input id="in_runout" type="number" step="0.1" value="${state.runout}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_runoutTol" type="number" step="0.1" value="${state.runoutTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_runout", v => state.runout = v],
      ["in_runoutTol", v => state.runoutTol = Math.max(0, v)],
    ]);
    return;
  }

  if(id === "softfoot"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Patte A (haut gauche)</label>
          <input id="in_sfA" type="number" step="0.1" value="${state.softFoot.A}">
        </div>
        <div>
          <label>Patte B (haut droite)</label>
          <input id="in_sfB" type="number" step="0.1" value="${state.softFoot.B}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Patte C (bas droite)</label>
          <input id="in_sfC" type="number" step="0.1" value="${state.softFoot.C}">
        </div>
        <div>
          <label>Patte D (bas gauche)</label>
          <input id="in_sfD" type="number" step="0.1" value="${state.softFoot.D}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Tol√©rance soft foot (mils)</label>
          <input id="in_sfTol" type="number" step="0.1" value="${state.softFootTol}">
        </div>
        <div>
          <label>Note</label>
          <div class="noteBox">La plus grande diagonale est affich√©e (soft foot seulement)
        </div>
      </div>
      </div>
    `;
    wireInputs([
      ["in_sfA", v => state.softFoot.A = Math.abs(v)],
      ["in_sfB", v => state.softFoot.B = Math.abs(v)],
      ["in_sfC", v => state.softFoot.C = Math.abs(v)],
      ["in_sfD", v => state.softFoot.D = Math.abs(v)],
      ["in_sfTol", v => state.softFootTol = Math.max(0, v)],
    ]);
    return;
  }

if(id === "measures"){

  let html = "";

  // ===== SOUS-√âTAPE 1 ‚Äî √ò ACCOUPLEMENT =====
  if(state.measureStep === 0){
    html = `
      <div class="row">
        <div>
          <label style="color:#00a2ff;">√ò accouplement (po)</label>
          <input id="in_diam" class="c-blue" type="number" step="0.1"
                 value="${geometry.couplingDiameter}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <div class="noteBox">Mesurer le diam√®tre ext√©rieur de l‚Äôaccouplement
        </div>
      </div>
        </div>
    `;
  }

  // ===== SOUS-√âTAPE 2 ‚Äî CENTRE ‚Üí AVANT =====
  if(state.measureStep === 1){
    html = `
      <div class="row">
        <div>
          <label style="color:#4caf50;">Centre ‚Üí pattes AVANT (po)</label>
          <input id="in_centerFront" class="c-green" type="number" step="0.1"
                 value="${geometry.centerToFrontFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <div class="noteBox">Mesurer du centre de l‚Äôaccouplement jusqu‚Äôaux pattes avant du moteur
        </div>
      </div>
        </div>
    `;
  }

  // ===== SOUS-√âTAPE 3 ‚Äî AVANT ‚Üí ARRI√àRE =====
  if(state.measureStep === 2){
    html = `
      <div class="row">
        <div>
          <label style="color:#ff9800;">Pattes AVANT ‚Üí ARRI√àRE (po)</label>
          <input id="in_frontRear" class="c-orange" type="number" step="0.1"
                 value="${geometry.frontToRearFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <div class="noteBox">Mesurer la distance entre pattes avant et arri√®re du moteur
        </div>
      </div>
        </div>
    `;
  }

  ui.inputsArea.innerHTML = html;

  if(state.measureStep === 0){
    wireInputs([["in_diam", v => geometry.couplingDiameter = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 1){
    wireInputs([["in_centerFront", v => geometry.centerToFrontFeet = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 2){
    wireInputs([["in_frontRear", v => geometry.frontToRearFeet = Math.max(0.1, v)]]);
  }

  return;
}

  // =====================================================
  // ANGULARIT√â VERTICALE
  // =====================================================
  if(id === "angV"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Lecture cadran 12‚Äì6 (mils)</label>
        <input id="in_angV" type="number" step="0.1" value="${state.angV}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_angVTol" type="number" step="0.1" value="${state.angVTol}">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Note</label>
        <div class="noteBox">
          Les distances g√©om√©triques proviennent de l‚Äô√©tape 3
        </div>
      </div>
    </div>
  `;

  wireInputs([
    ["in_angV", v => state.angV = v],
    ["in_angVTol", v => state.angVTol = Math.max(0, v)]
  ]);
  return;
}

if(id === "parV"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Parall√©lisme vertical (mils)</label>
        <input id="in_parV" type="number" step="0.1" value="${state.parV}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_parVTol" type="number" step="0.1" value="${state.parVTol}">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Note</label>
        <div class="noteBox">
          Correction uniforme sur les 4 pattes
        </div>
      </div>
    </div>
  `;

  wireInputs([
    ["in_parV", v => state.parV = v],
    ["in_parVTol", v => state.parVTol = Math.max(0, v)]
  ]);
  return;
}


  // =====================================================
  // ANGULARIT√â HORIZONTALE
  // =====================================================
  if(id === "angH"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Lecture cadran 3‚Äì9 (mils)</label>
        <input id="in_angH" type="number" step="0.1" value="${state.angH}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_angHTol" type="number" step="0.1" value="${state.angHTol}">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Note</label>
        <div class="noteBox">
          Les distances g√©om√©triques proviennent de l‚Äô√©tape 3
        </div>
      </div>
    </div>
  `;

  wireInputs([
    ["in_angH", v => state.angH = v],
    ["in_angHTol", v => state.angHTol = Math.max(0, v)]
  ]);
  return;
}
  if(id === "parH"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Parall√©lisme horizontal (mils)</label>
          <input id="in_parH" type="number" step="0.1" value="${state.parH}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_parHTol" type="number" step="0.1" value="${state.parHTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_parH", v => state.parH = v],
      ["in_parHTol", v => state.parHTol = Math.max(0, v)],
    ]);
    return;
  }
}
function buildFormulaSoftFoot(){
  const sf = computeSoftFoot();

  // Valeurs entr√©es
  const A = state.softFoot.A;
  const B = state.softFoot.B;
  const C = state.softFoot.C;
  const D = state.softFoot.D;

  // Calculs
  const diagAC = sf.diagAC;
  const diagBD = sf.diagBD;
  const delta  = sf.delta;

  const corr   = sf.correction;      // 80% du delta
  const each   = corr / 2;           // r√©parti sur 2 pattes

  // Quelle diagonale est fautive?
  let faultyTxt = "Aucune (diagonales √©gales)";
  if(sf.faulty) faultyTxt = sf.faulty.join(" + ");

  return (
`Pied boiteux ‚Äî Diagonales

Diag AC = A + C
       = ${A} + ${C}
       = ${diagAC.toFixed(2)} mil

Diag BD = B + D
       = ${B} + ${D}
       = ${diagBD.toFixed(2)} mil

Œî = |Diag AC ‚àí Diag BD|
  = |${diagAC.toFixed(2)} ‚àí ${diagBD.toFixed(2)}|
  = ${delta.toFixed(2)} mil

Correction ‚âà 0.8 √ó Œî
          = 0.8 √ó ${delta.toFixed(2)}
          = ${corr.toFixed(2)} mil

Par patte (2 pattes) = Correction / 2
                     = ${corr.toFixed(2)} / 2
                     = ${each.toFixed(2)} mil

Pattes √† corriger : ${faultyTxt}`
  );
}

/* =====================================================
   Wire inputs (lecture -> state -> redraw)
===================================================== */
function wireInputs(pairs){
  pairs.forEach(([inputId, setter]) => {
    const input = document.getElementById(inputId);
    if(!input) return;

    // Autoriser la saisie libre sans calcul imm√©diat
    input.addEventListener("input", () => {
      // Ne rien faire ici ‚Üí saisie fluide
    });

    // Validation sur ENTER
    input.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        input.blur();   // force validation
      }
    });

    // Validation finale quand on quitte le champ
    input.addEventListener("blur", () => {
      let raw = input.value.trim();

      if(raw === ""){
        raw = "0";
        input.value = "0";
      }

      const v = parseFloat(raw);
      setter(Number.isFinite(v) ? v : 0);

      refreshUI();
      drawTopView();
      drawSideView();
    });
  });
}
/* =====================================================
   UI sync
===================================================== */
function refreshUI(){
  ui.stepTitle.textContent = `√âtape ${STEPS[state.step].label}`;

  const okNow = isStepOK(state.step);
  ui.stepBadge.textContent = okNow ? "OK" : "NOT OK";
  ui.stepBadge.classList.toggle("ok", okNow);
  ui.stepBadge.classList.toggle("bad", !okNow);

  renderInputsForCurrentStep();

  ui.infoBox.textContent =
    buildMessage() + "\n\n" + buildCorrectionMessage();

  // ===== FORMULES (PC) ‚Äî √âTAPE 2 SEULEMENT =====
  if(ui.formulaBox){
    if(STEPS[state.step].id === "softfoot"){
      ui.formulaBox.textContent = buildFormulaSoftFoot();
    }else{
      ui.formulaBox.textContent = "";
    }
  }
}
/* =====================================================
   Navigation
===================================================== */
function nextStep(){
  // Sous-√©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep < 2){
      state.measureStep++;
      renderAll();
      return;
    }else{
      state.measureStep = 0;
      state.step++;
      renderAll();
      return;
    }
  }

  if(isStepOK(state.step) && state.step < STEPS.length - 1){
    state.step++;
    renderAll();
  }
}

function prevStep(){
  // Sous-√©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep > 0){
      state.measureStep--;
      renderAll();
      return;
    }else{
      // revenir √† l'√©tape pr√©c√©dente
      state.step--;
      renderAll();
      return;
    }
  }

  if(state.step > 0){
    state.step--;
    renderAll();
  }
}
ui.btnPrev.addEventListener("click", prevStep);
ui.btnNext.addEventListener("click", nextStep);
/* =====================================================
   BLOC 3 ‚Äî DESSINS & SYNCHRO
===================================================== */

const topCanvas = document.getElementById("topView");
const sideCanvas = document.getElementById("sideView");
const topCtx = topCanvas.getContext("2d");
const sideCtx = sideCanvas.getContext("2d");

function resizeCanvas(canvas, ctx){
  const dpr = window.devicePixelRatio || 1;

  const rect = canvas.getBoundingClientRect();

  const w = Math.max(200, rect.width);
  const h = Math.max(200, rect.height);

  canvas.width  = w * dpr;
  canvas.height = h * dpr;

  ctx.setTransform(dpr,0,0,dpr,0,0);

  return { w, h };
}
/* =====================================================
   UTILITAIRES DESSIN
===================================================== */
function clear(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,w,h);
}

function drawDimOnly(ctx, x1, x2, y){
  ctx.beginPath();
  ctx.moveTo(x1, y);
  ctx.lineTo(x2, y);
  ctx.stroke();

  // petites barres aux extr√©mit√©s
  ctx.beginPath();
  ctx.moveTo(x1, y - 8);
  ctx.lineTo(x1, y + 8);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y - 8);
  ctx.lineTo(x2, y + 8);
  ctx.stroke();
}



function drawShimValue(ctx, x, y, value){
  if(value <= 0) return;

  ctx.fillStyle = "#ff5252";
  ctx.font = blinkPhase ? "bold 13px Arial" : "12px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`+${value.toFixed(2)} mil`, x + 14, y + 4);
}

function isBlinking(){
  return blinkPhase ? "#ff5252" : "#000";
}
function footColor(letter){
  const step = STEPS[state.step].id;
  const bad = !isStepOK(state.step);

  if(step === "softfoot" && currentView === "side"){
    return FOOT_NORMAL;
  }

  if(step === "softfoot"){
    const sf = computeSoftFoot();
    if(bad && sf.faulty && sf.faulty.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "angV"){
    const r = computeAngularVertical();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "parV" && bad){
    return isBlinking();
  }

  if(step === "angH"){
    const r = computeAngularHorizontal();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "parH"){
    const r = computeParallelHorizontal();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  return FOOT_NORMAL;
}
function drawFoot(ctx,x,y,label){
  ctx.fillStyle = footColor(label);
  ctx.fillRect(x-10,y-5,20,10);
  ctx.fillStyle="#fff";
  ctx.font="12px Arial";
  ctx.textAlign="center";
  ctx.fillText(label,x,y+18);
}
function drawDimLine(ctx, x1, x2, y, label){
  const left = Math.min(x1, x2);
  const right = Math.max(x1, x2);

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.fillStyle   = "rgba(255,255,255,.90)";
  ctx.lineWidth = 2;

  // ligne principale
  ctx.beginPath();
  ctx.moveTo(left, y);
  ctx.lineTo(right, y);
  ctx.stroke();

  // "ticks" aux extr√©mit√©s
  ctx.beginPath();
  ctx.moveTo(left, y-8);  ctx.lineTo(left, y+8);
  ctx.moveTo(right, y-8); ctx.lineTo(right, y+8);
  ctx.stroke();

  // texte centr√©
  ctx.font = "12px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText(label, (left + right)/2, y - 10);

  ctx.restore();
}

function drawCouplingDiameter(ctx, cx, cy, diam){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.lineWidth = 2;

  // petit cercle indicatif (pas √† l'√©chelle)
  ctx.beginPath();
  ctx.arc(cx, cy, 18, 0, Math.PI*2);
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,.90)";
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  ctx.fillText(`√ò = ${diam} po`, cx + 24, cy);

  ctx.restore();
}



function drawTopView(){

  currentView = "top";

  const {w,h} = resizeCanvas(topCanvas, topCtx);
  const ctx = topCtx;
  clear(ctx,w,h);

  const scale   = visualGain;
  const rotGain = visualGain * 0.00035;

  let baseCy = h * 0.5;
  let baseCx = w * 0.30;

  let cy = baseCy + (
    STEPS[state.step].id === "parH"
    ? state.parH * scale
    : 0
  );
  let cx = baseCx;

  const { motorW, motorH, pumpW, pumpH, gap, shaftH, coupW, coupH } = GEOM;

  // ====================================================
  //   SEMELLE COMMUNE
  // ====================================================
  const baseMargin = 40;

  ctx.fillStyle = "#1a235a";
  ctx.fillRect(
    cx - motorW/2 - baseMargin,
    cy - motorH/2 - baseMargin,
    motorW + gap + pumpW + baseMargin*2,
    motorH + baseMargin*2
  );

  // ====================================================
  //   ROTATION MOTEUR
  // ====================================================
  const ang =
    STEPS[state.step].id === "angH"
      ? state.angH * dialSign * rotGain
      : 0;

  // ====================================================
  //   MOTEUR + PATTES (rotation)
  // ====================================================
  const P = {
    A:{x:cx - motorW/2 + 24, y:cy - motorH/2 + 18},
    B:{x:cx + motorW/2 - 24, y:cy - motorH/2 + 18},
    D:{x:cx - motorW/2 + 24, y:cy + motorH/2 - 18},
    C:{x:cx + motorW/2 - 24, y:cy + motorH/2 - 18},
  };

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(ang);
  ctx.translate(-cx, -cy);

  ctx.fillStyle = "#00a2ff";
  ctx.fillRect(cx - motorW/2, cy - motorH/2, motorW, motorH);

  function drawPad(letter){
    const {x,y} = P[letter];
    ctx.fillStyle = footColor(letter);
    ctx.fillRect(x-12, y-6, 24, 12);
  }

  drawPad("A");
  drawPad("B");
  drawPad("C");
  drawPad("D");

  ctx.restore();

  // ====================================================
  //   LETTRES
  // ====================================================
  ctx.fillStyle = "#fff";
  ctx.font = "14px Arial";
  ctx.textAlign = "center";

  const labelOffset = 26;
  ctx.fillText("A", P.A.x, P.A.y - labelOffset);
  ctx.fillText("B", P.B.x, P.B.y - labelOffset);
  ctx.fillText("D", P.D.x, P.D.y + labelOffset + 8);
  ctx.fillText("C", P.C.x, P.C.y + labelOffset + 8);

  // ====================================================
  //   ARBRES
  // ====================================================
  ctx.fillStyle = "#bbbbbb";

  ctx.fillRect(
    cx + motorW/2,
    cy - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  ctx.fillRect(
    cx + motorW/2 + (gap/2) + 8,
    cy - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // ====================================================
  //   ACCOUPLEMENT
  // ====================================================
  const coupX = cx + motorW/2 + gap/2;

  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(coupX - 14, cy - coupH/2, coupW, coupH);
  ctx.fillRect(coupX + 2,  cy - coupH/2, coupW, coupH);

  // ====================================================
  //   POMPE FIXE
  // ====================================================
  const pumpX = cx + motorW/2 + gap;

  ctx.fillStyle="#ff9800";
  ctx.fillRect(pumpX, baseCy - pumpH/2, pumpW, pumpH);

  // ====================================================
  //   LIGNE D‚ÄôAXE ‚Äî PREMIER PLAN ‚Äî SUIT LE MOTEUR
  // ====================================================
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.setLineDash([14,8]);
  ctx.lineWidth = 4;
  ctx.shadowColor = "rgba(255,255,255,0.7)";
  ctx.shadowBlur = 6;

  ctx.beginPath();
  ctx.moveTo(cx - motorW/2 - 80, cy);
  ctx.lineTo(cx + motorW/2 + gap + pumpW + 80, cy);
  ctx.stroke();

  ctx.restore();

  // ====================================================
  //   TITRES
  // ====================================================
  ctx.fillStyle="#fff";
  ctx.font="13px Arial";
  ctx.textAlign="center";
  ctx.fillText("MOTEUR (mobile)", cx, cy - motorH/2 - 18);
  ctx.fillText("POMPE (fixe)", pumpX + pumpW/2, baseCy - pumpH/2 - 18);
}

function drawSideView(){

  currentView = "side";

  const {w,h} = resizeCanvas(sideCanvas, sideCtx);
  const ctx = sideCtx;
  clear(ctx,w,h);

  const scale   = visualGain;
  const rotGain = visualGain * 0.00035;

  let baseCy = h * 0.55;
  let baseCx = w * 0.30;

  let cy = baseCy + (
    STEPS[state.step].id === "parV"
      ? state.parV * scale
      : 0
  );

  let cx = baseCx;

  const axisPumpY  = baseCy;   // axe pompe = FIXE
  const axisMotorY = cy;       // axe moteur = MOBILE

  const { motorW, motorH, pumpW, pumpH, gap, shaftH, coupW, coupH } = GEOM;

  const footW = 24;
  const footH = 10;

  const rearFootX  = cx - motorW/2 + footW/2;
  const frontFootX = cx + motorW/2 - footW/2;

  // ====================================================
  //   SEMELLE COMMUNE
  // ====================================================
  const baseMargin = 40;
  const baseTop = cy + motorH/2 + footH - 2;

  ctx.fillStyle = "#1a235a";
  ctx.fillRect(
    cx - motorW/2 - baseMargin,
    baseTop,
    motorW + gap + pumpW + baseMargin*2,
    16
  );

  // ====================================================
  //   PARAM√àTRE ANGULAIRE
  // ====================================================
  const ang =
    STEPS[state.step].id === "angV"
      ? -state.angV * dialSign * rotGain
      : 0;

  // ====================================================
  //   POMPE FIXE + ARBRE + ¬Ω ACCOUPLEMENT
  // ====================================================
  const pumpX = cx + motorW/2 + gap;
  const coupX = cx + motorW/2 + gap/2;

  // pompe
  ctx.fillStyle = "#ff9800";
  ctx.fillRect(pumpX, baseCy - pumpH/2, pumpW, pumpH);

  // pattes pompe
  ctx.fillRect(pumpX + 12, baseCy + pumpH/2 - 2, footW, footH);
  ctx.fillRect(pumpX + pumpW - 12 - footW, baseCy + pumpH/2 - 2, footW, footH);

  // arbre pompe
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    coupX + 14,
    axisPumpY - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // demi-accouplement pompe
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(
    coupX + 4,
    axisPumpY - coupH/2,
    coupW,
    coupH
  );

// ====================================================
//   MOTEUR + ARBRE + ¬Ω ACCOUPLEMENT + AXE (BLOC SOLIDAIRE)
// ====================================================
ctx.save();
ctx.translate(cx, cy);
ctx.rotate(ang);
ctx.translate(-cx, -cy);

// ---- AXE MOTEUR ----
ctx.save();
ctx.strokeStyle = "rgba(255,255,255,0.95)";
ctx.setLineDash([5,6]);
ctx.lineWidth = 2;
ctx.shadowColor = "rgba(255,255,255,0.6)";
ctx.shadowBlur = 3;

ctx.beginPath();
ctx.moveTo(cx - motorW/2 - 100, cy);
ctx.lineTo(cx + motorW/2 + gap/2, cy);
ctx.stroke();
ctx.restore();

// ---- MOTEUR ----
ctx.fillStyle = "#00a2ff";
ctx.fillRect(cx - motorW/2, cy - motorH/2, motorW, motorH);

// pattes moteur
ctx.fillRect(rearFootX - footW/2,  cy + motorH/2 - 2, footW, footH);
ctx.fillRect(frontFootX - footW/2, cy + motorH/2 - 2, footW, footH);

// lettres
ctx.fillStyle = "#fff";
ctx.font = "14px Arial";
ctx.textAlign = "center";
ctx.fillText("D", rearFootX,  cy + motorH/2 + 24);
ctx.fillText("C", frontFootX, cy + motorH/2 + 24);

// ---- ARBRE MOTEUR ----
ctx.fillStyle = "#bbbbbb";
ctx.fillRect(
  cx + motorW/2,
  cy - shaftH/2,
  (gap/2) - 8,
  shaftH
);

// ---- DEMI-ACCOUPLEMENT MOTEUR ----
ctx.fillStyle = "#cfcfcf";
ctx.fillRect(
  cx + motorW/2 + gap/2 - 14,
  cy - coupH/2,
  coupW,
  coupH
);

ctx.restore();

  // ---- AXE POMPE (FIXE) ----
ctx.save();
ctx.strokeStyle = "rgba(255,255,255,0.95)";
ctx.setLineDash([5,6]);
ctx.lineWidth = 2;
ctx.shadowColor = "rgba(255,255,255,0.6)";
ctx.shadowBlur = 3;

ctx.beginPath();
ctx.moveTo(cx + motorW/2 + gap/2, axisPumpY);
ctx.lineTo(cx + motorW/2 + gap + pumpW + 100, axisPumpY);
ctx.stroke();
ctx.restore();
  // ====================================================
  //   TITRES
  // ====================================================
  ctx.fillStyle="#fff";
  ctx.font="14px Arial";
  ctx.textAlign="center";
  ctx.fillText("MOTEUR (mobile)", cx, cy - motorH/2 - 14);
  ctx.fillText("POMPE (fixe)", pumpX + pumpW/2, baseCy - pumpH/2 - 14);

  // ===============================
  //   MESURES G√âOM√âTRIQUES
  // ===============================
  if(STEPS[state.step].id === "measures"){

    const sub = state.measureStep;
    const color = ["#00a2ff","#4caf50","#ff9800"][sub];

    ctx.strokeStyle = color;
    ctx.lineWidth = 3;

    // 0 ‚Üí √ò ACCOUPLEMENT
    if(sub === 0){
      const r = 26;
      const x = baseCx + motorW/2 + gap/2;

      ctx.beginPath();
      ctx.moveTo(x, baseCy - r);
      ctx.lineTo(x, baseCy + r);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x - 8, baseCy - r);
      ctx.lineTo(x + 8, baseCy - r);
      ctx.moveTo(x - 8, baseCy + r);
      ctx.lineTo(x + 8, baseCy + r);
      ctx.stroke();
      return;
    }

    // 1 ‚Üí CENTRE ‚Üí PATTES AVANT
    if(sub === 1){
      const x1 = coupX;
      const x2 = frontFootX;
      const y  = cy + motorH/2 + 30;

      ctx.beginPath();
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x1, y - 8);
      ctx.lineTo(x1, y + 8);
      ctx.moveTo(x2, y - 8);
      ctx.lineTo(x2, y + 8);
      ctx.stroke();
      return;
    }

    // 2 ‚Üí AVANT ‚Üí ARRI√àRE
    if(sub === 2){
      const x1 = rearFootX;
      const x2 = frontFootX;
      const y  = cy + motorH/2 + 52;

      ctx.beginPath();
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x1, y - 8);
      ctx.lineTo(x1, y + 8);
      ctx.moveTo(x2, y - 8);
      ctx.lineTo(x2, y + 8);
      ctx.stroke();
      return;
    }
  }
}
function renderAll(){
  refreshUI();
  drawTopView();
  drawSideView();
}


window.addEventListener("load", () => {
  renderAll();
});

</script>




</body>
</html>
