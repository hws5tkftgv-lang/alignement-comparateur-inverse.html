<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement ‚Äì Comparateur invers√© (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.75);
  --ok:#4caf50;
  --bad:#ff5252;
  --accent:#00a2ff;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:Arial,system-ui,sans-serif;
}

/* ===== HEADER ===== */
.headerBar{
  position:sticky;
  top:0;
  z-index:50;
  background:linear-gradient(to bottom, rgba(11,20,54,.98), rgba(11,20,54,.88));
  border-bottom:1px solid rgba(255,255,255,.08);
  padding:12px;
  text-align:center;
  font-weight:900;
  font-size:16px;
}

/* ===== LAYOUT ===== */
.wrap{
  padding:12px;
  max-width:1100px;
  margin:0 auto;
}
.grid{
  display:grid;
  gap:12px;
}
@media (min-width:900px){
  .grid{ grid-template-columns:1fr 1fr; }
}

/* ===== CARDS ===== */
.card{
  background:var(--card);
  border-radius:14px;
  padding:12px;
  border:1px solid rgba(255,255,255,.06);
}
h2{
  margin:0 0 8px;
  font-size:15px;
}
p{
  margin:6px 0;
  font-size:13px;
  color:var(--muted);
}

/* ===== √âTAPES ===== */
.step{
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:12px;
  background:rgba(255,255,255,.03);
}
.stepHead{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:6px;
}
.stepTitle{
  font-weight:900;
  font-size:14px;
}
.badge{
  font-size:12px;
  font-weight:900;
  padding:4px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
}
.badge.ok{ background:rgba(76,175,80,.15); }
.badge.bad{ background:rgba(255,82,82,.15); }

/* ===== INPUTS ===== */
.row{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
}
@media(max-width:420px){
  .row{ grid-template-columns:1fr; }
}
label{
  font-size:12px;
  color:var(--muted);
}
input{
  width:100%;
  padding:10px;
  font-size:16px;
  border-radius:12px;
  border:none;
}

/* ===== NAV ===== */
.navRow{
  display:flex;
  gap:10px;
  margin-top:10px;
}
button{
  flex:1;
  padding:12px;
  font-size:16px;
  border:none;
  border-radius:12px;
  background:var(--accent);
  color:#fff;
  font-weight:900;
}
button.secondary{
  background:rgba(255,255,255,.15);
}

/* ===== CANVAS ===== */
.canvasGrid{
  display:grid;
  gap:12px;
}
@media(min-width:900px){
  .canvasGrid{ grid-template-columns:1fr 1fr; }
}
.canvasCard{
  background:#000;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.canvasHeader{
  padding:8px 12px;
  font-size:13px;
  font-weight:900;
  background:rgba(0,0,0,.35);
}
/* ===== CANVAS (dessins p√©dagogiques) ===== */
canvas{
  width:100%;
  height:180px;   /* ‚¨ÖÔ∏è r√©duit proportionnellement */
  display:block;
}

@media(min-width:900px){
  canvas{
    height:280px; /* ‚¨ÖÔ∏è r√©duit aussi sur PC */
  }
}

/* ===== INFO ===== */
.infoBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.2);
  font-size:12px;
  white-space:pre-line;
}
/* ===== FORMULES (PC seulement) ===== */
.formulaBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.25);
  font-size:13px;
  font-family:Consolas, monospace;
  line-height:1.45;
  white-space:pre-line;
  display:none; /* cach√© par d√©faut (mobile) */
}
@media (min-width:900px){
  .formulaBox{ display:block; } /* visible PC */
}

.c-blue{ border:2px solid #00a2ff !important; }
.c-green{ border:2px solid #4caf50 !important; }
.c-orange{ border:2px solid #ff9800 !important; }

.noteBox{
  background:rgba(255,255,255,.10);
  border-radius:12px;
  padding:10px 12px;
  font-size:13px;
  color:rgba(234,241,255,.9);
  line-height:1.4;
}

.btnActive{
  background:#00a2ff !important;
  color:white !important;
}
/* =========================
   MODAL AIDE / FORMULES
========================= */
#helpModal{
  position:fixed;
  inset:0;
  z-index:9999;
}

#helpBackdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.65);
}

#helpPanel{
  position:relative;
  width:min(920px, calc(100% - 24px));
  max-height:calc(100% - 24px);
  margin:12px auto;
  background:#0b1436;
  border:1px solid rgba(255,255,255,.12);
  border-radius:14px;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  box-shadow:0 10px 40px rgba(0,0,0,.35);
}

.helpHeader{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  padding:12px;
  background:rgba(255,255,255,.06);
  border-bottom:1px solid rgba(255,255,255,.10);
}

.helpTitle{
  font-weight:900;
  font-size:14px;
}

.helpActions{
  display:flex;
  gap:10px;
}

.helpBtn{
  padding:10px 12px;
  border:none;
  border-radius:10px;
  background:var(--accent);
  color:#fff;
  font-weight:900;
  cursor:pointer;
}

.helpBtn.secondary{
  background:rgba(255,255,255,.15);
}

.helpContent{
  padding:20px;
  overflow:auto;
  font-size:14px;
  line-height:1.6;
  color:#000;
  background:#fff;
  text-align:left;
  max-width:820px;
  margin:auto;
}

/* Titres internes */
.helpContent h3{
  margin:20px 0 10px;
  font-size:16px;
  text-align:center;
  font-weight:900;
}
.helpContent .box{
  border:1px solid #ddd;
  background:#f8f8f8;
  border-radius:10px;
  padding:14px 16px;
  margin:10px 0;
}
.helpContent code{
  font-family:Consolas, monospace;
  background:#eee;
  padding:2px 6px;
  border-radius:4px;
  font-size:13px;
}
  #trainingModal{
  position:fixed;
  inset:0;
  z-index:9998;
}

#trainingBackdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.65);
}


  
/* ==========================
   MODE IMPRESSION ‚Äî PRO
========================== */

@media print {

  body {
    background:#fff !important;
    color:#000 !important;
  }

  body > * {
    display:none !important;
  }

  #helpModal {
    display:block !important;
    position:static !important;
  }

  #helpPanel {
    display:block !important;
    width:100% !important;
    max-width:100% !important;
    box-shadow:none !important;
    background:#fff !important;
    color:#000 !important;
    border-radius:0 !important;
    padding:20px !important;
  }

  #helpBackdrop {
    display:none !important;
  }

  .helpActions {
    display:none !important;
  }

  /* ===== TEXTE ULTRA LISIBLE ===== */

  .helpContent {
    font-size:13.5pt !important;
    line-height:1.45 !important;
    color:#000 !important;
  }

  .helpContent h3 {
    font-size:16pt !important;
    margin-top:20px !important;
    color:#000 !important;
    border-bottom:2px solid #000 !important;
    padding-bottom:4px !important;
  }

  .helpContent .box {
    border:1px solid #000 !important;
    background:#fff !important;
    color:#000 !important;
  }

  .helpContent code {
    background:#eee !important;
    color:#000 !important;
    font-weight:bold !important;
    padding:2px 5px !important;
  }

}

/* ===== FORMULES P√âDAGOGIQUES ===== */
.formula{
  font-family: Consolas, monospace;
  font-size: 14px;
  background: rgba(255,255,255,.12);
  padding: 4px 8px;
  border-radius: 6px;
  font-weight: 600;
  display: inline-block;
}
#trainingModal{
  position:fixed;
  inset:0;
  z-index:9999;
}

#trainingBackdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.65);
}

#trainingPanel{
  position:relative;
  width:min(900px, calc(100% - 24px));
  margin:12px auto;
  background:#0b1436;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.15);
  box-shadow:0 10px 40px rgba(0,0,0,.45);

  display:flex;
  flex-direction:column;

  max-height:90vh;
  overflow:hidden;
}
#trainingPanel{
  padding-bottom: env(safe-area-inset-bottom);
}

#dialBlock{
  margin-top:6px;
  padding:8px;
  background:#0b1436;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.15);
}
@media (max-width:600px){
  #dialBlock{
    padding:8px;
    margin-top:6px;
  }
}
#dialBlock,
#dialBlock *{
  color: #ffffff !important;
}


body.modal-open{
  overflow: hidden;
  position: fixed;
  width: 100%;
}

#dialWrap{
  width:100%;
  max-width:260px;
  aspect-ratio:1/1;
  margin:auto;
}

#trainDial{
  width:100%;
  height:100%;
  background:#000;
  border-radius:50%;
  border:3px solid #666;
}

@media (max-width: 600px){
  #dialWrap{ max-width:200px; }
}

@media (min-width: 1200px){
  #dialWrap{ max-width:220px; }
}

#dialWrap{
  width:100%;
  max-width:220px;
  aspect-ratio:1 / 1;
  margin:6px auto 4px auto;
  display:flex;
  justify-content:center;
  align-items:center;
}

#trainDial{
  width:100%;
  height:100%;
  display:block;
  background:#000;
  border-radius:50%;
  border:3px solid #666;
}

#dialValue{
  margin-top:4px !important;
  font-size:14px;
}

#trainingExplain{
  margin-top:4px;
  font-size:12px;
  line-height:1.25;
  max-height:60px;
  overflow:hidden;
}

.canvasGrid{
  margin-top:6px !important;
}

/* =====================================================
   TRAINING ‚Äî MOBILE COMPACT (SANS IMPACT GLOBAL)
===================================================== */
@media (max-width: 768px){

  /* On cible UNIQUEMENT le training */
  body.training-on #trainingPanel{
    max-height:100vh;
  }

  /* ======================
     1Ô∏è‚É£ CADRAN
  ====================== */
  body.training-on #dialBlock{
    padding:10px;
  }

  body.training-on #dialWrap{
    max-width:165px;   /* ~ -25 % r√©el */
    margin:4px auto;
  }

  body.training-on #dialValue{
    font-size:12px;
  }

  body.training-on #trainingExplain{
    font-size:11px;
    max-height:46px;
  }

  /* ======================
     2Ô∏è‚É£ SLIDER
  ====================== */
  body.training-on input[type="range"]{
    height:22px;
    margin:4px 0;
  }

  body.training-on .rangeLabels{
    font-size:11px;
    margin-top:2px;
  }

  /* ======================
     3Ô∏è‚É£ DESSINS (CANVAS)
  ====================== */
  body.training-on .canvasGrid{
    gap:8px;
  }

  body.training-on .canvasCard{
    padding:0;
  }

  body.training-on canvas{
    height:190px; /* r√©duit mais lisible */
  }

  body.training-on .canvasHeader{
    font-size:11px;
    padding:5px 8px;
  }
}


/* =====================================================
   TRAINING ‚Äî NETTOYAGE CONTENU INUTILE (MOBILE SEULEMENT)
===================================================== */
@media (max-width: 768px){

  /* Titre "Mode entra√Ænement ‚Äî Compr√©hension du cadran" */
  #trainingModal h2{
    display: none !important;
  }

  /* Bloc "But p√©dagogique" (le cadre blanc) */
  #trainingModal .helpContent > .box:first-of-type{
    display: none !important;
  }
}
@media (max-width: 768px){

  #trainingModal #dialWrap{
    max-width: 165px;   /* ‚âà -25 % */
  }

  #trainingModal #dialValue{
    font-size: 12px;
  }

  #trainingModal #trainingExplain{
    font-size: 11px;
    line-height: 1.2;
    max-height: 48px;
  }
}
@media (max-width: 768px){

  /* Slider */
  #trainingModal input[type="range"]{
    margin-top: 6px;
    margin-bottom: 4px;
    height: 24px;
  }

  /* Labels -100 / 0 / +100 */
  #trainingModal .rangeLabels{
    font-size: 11px;
    margin-top: 2px;
  }
}
@media (max-width: 768px){

  #trainingModal .canvasCard{
    padding: 6px;
  }

  #trainingModal .canvasHeader{
    font-size: 11px;
    padding: 4px 6px;
  }

  #trainingModal .canvasCard canvas{
    height: 180px;   /* ‚âà -25 % */
  }
}

/* =====================================================
   TRAINING ‚Äî SUPPRESSION DU BLOC INTRO P√âDAGOGIQUE
   (titre + but p√©dagogique)
===================================================== */
#trainingModal h2,
#trainingModal .noteBox{
  display: none !important;
}
/* =====================================================
   TRAINING ‚Äî SUPPRESSION DU TITRE "COMPR√âHENSION DU CADRAN"
===================================================== */

/* Supprime le titre texte dans le contenu du modal */
#trainingModal #trainingPanel h1,
#trainingModal #trainingPanel h2:first-of-type{
  display: none !important;
}



/* =====================================================
   TRAINING ‚Äî SUPPRESSION DU TITRE INTERNE (SOUS LE BANDEAU)
===================================================== */

#trainingModal #trainingPanel .wrap > h2:first-of-type,
#trainingModal #trainingPanel .wrap > .card > h2:first-of-type{
  display: none !important;
}

/* =====================================================
   TRAINING ‚Äî SUPPRESSION DU TITRE
   "Mode entra√Ænement ‚Äî Compr√©hension du cadran"
===================================================== */

#trainingModal #trainingPanel h1,
#trainingModal #trainingPanel h2{
  display: none !important;
}

.trainingOptions{
  display:flex;
  gap:12px;
  align-items:center;
}

.trainingOptions .opt{
  display:flex;
  flex-direction:column;
  font-size:11px;
}

.trainingOptions label{
  font-size:11px;
  opacity:.85;
  margin-bottom:2px;
}

.trainingOptions select{
  font-size:13px;
  padding:6px 8px;
  border-radius:8px;
}


#trainingContent{
  overflow-y:auto;
  flex:1;
  padding-bottom:16px;
}

#trainingControls{
  position:sticky;
  bottom:0;
  background:#0b1436;
  padding:12px 0 16px;
  border-top:1px solid rgba(255,255,255,.15);
}

/* =====================================================
   MODE TEST ‚Äî SLIDERS ULTRA COMPACTS (MOBILE SAFARI)
===================================================== */

@media (max-width: 768px){

  /* Zone compl√®te des contr√¥les TEST */
  #trainingControls{
    padding: 6px 10px !important;
  }

  /* Met les 2 sliders sur UNE SEULE LIGNE */
  #trainingControls .row{
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  /* Labels plus petits */
  #trainingControls label{
    font-size: 11px;
    margin-bottom: 2px;
  }

  /* Sliders beaucoup moins hauts */
  #trainingControls input[type="range"]{
    height: 22px;
    margin: 2px 0;
  }

  /* Bouton reset compact */
  #btnResetTraining{
    margin-top: 6px;
    padding: 8px;
    font-size: 13px;
    border-radius: 10px;
  }
}
/* ===============================
   TRAINING TEST ‚Äî SLIDERS COMPACTS
   =============================== */

#trainingControls{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:10px;
  margin-top:8px;
}

#trainingControls label{
  font-size:11px;
  opacity:.85;
}

#trainingControls input[type="range"]{
  margin:4px 0 0 0;
}

/* Bouton reset centr√© et compact */
#btnResetTraining{
  grid-column:1 / -1;
  margin-top:8px;
  padding:10px;
  font-size:14px;
}

/* iPhone : encore plus compact */
@media (max-width:600px){
  #trainingControls{
    gap:8px;
  }

  #trainingControls label{
    font-size:10.5px;
  }

  #btnResetTraining{
    padding:9px;
    font-size:13px;
  }
}


/* ===============================
   MODE TEST ‚Äî CADRAN COMPACT (iPhone)
   =============================== */
@media (max-width: 600px) {

  #dialBlock{
    transform: scale(0.78);     /* ~22 % plus petit */
    transform-origin: top center;
    margin-top: -20px;          /* remonte visuellement */
    margin-bottom: -30px;       /* r√©cup√®re de la hauteur */
  }

}
/* ===============================
   MODE TEST ‚Äî DESSINS COMPACTS
   =============================== */
@media (max-width: 600px) {

  .visualisation-pedagogique,
  #visualisationPedagogique,
  .pedagoBox{
    transform: scale(0.80);     /* ~20 % plus petit */
    transform-origin: top center;
    margin-top: -15px;
    margin-bottom: -25px;
  }

}

/* ================================
   R√âDUCTION PROPORTIONNELLE BLOCS
   ================================ */

/* BO√éTE CADRAN */
#dialBlock{
  transform: scale(0.65);          /* ‚Üê ajuste ici (0.80 √† 0.90) */
  transform-origin: top center;
  margin-bottom: -40px;            /* compense l'espace vide */
}



</style>
</head>

<body>

<div class="headerBar">
  <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
    <span>Alignement d‚Äôarbres ‚Äî Comparateur invers√© (mils)</span>

    <button id="btnHelp"
      type="button"
      style="flex:0; padding:6px 10px; border-radius:10px; border:none; background:rgba(255,255,255,.15); color:#fff; font-weight:900; cursor:pointer;">
      ‚ÑπÔ∏è
    </button>
    <button id="btnTraining"
  type="button"
  style="flex:0; padding:6px 12px; border-radius:10px; border:none; background:#4caf50; color:#fff; font-weight:900; cursor:pointer;">
  üéì Training
</button>
  </div>
</div>

<div class="wrap">
  <div class="grid">
    
      <div class="step" id="stepCard">
  <div class="stepHead">
    <div class="stepTitle" id="stepTitle">‚Äî</div>
    <div class="badge" id="stepBadge">Info</div>
  </div>

  <!-- Inputs g√©n√©r√©s par JS selon l'√©tape -->
  <div id="inputsArea"></div>
  <div id="formulaBox" class="formulaBox"></div>

  <div class="navRow">
    <button class="secondary" id="btnPrev" type="button">‚óÄ Pr√©c√©dent</button>
    <button id="btnNext" type="button">Suivant ‚ñ∂</button>
  </div>

  <div class="infoBox" id="infoBox">‚Äî</div>
</div>
    </div>

    <!-- ===== DESSINS ===== -->
    <div class="card">
      <h2>Dessins p√©dagogiques</h2>
      <p>
Vue de dessus (horizontal) et vue de profil (vertical).
Les pattes A / B / C / D seront affich√©es ici.
      </p>

      <div class="canvasGrid">
        <div class="canvasCard">
          <div class="canvasHeader">Vue de dessus (TopView)</div>
          <canvas id="topView"></canvas>
        </div>
        <div class="canvasCard">
          <div class="canvasHeader">Vue de profil (SideView)</div>
          <canvas id="sideView"></canvas>
        </div>
      </div>
      
      
      
<!-- =========================
     MODAL AIDE / FORMULES
========================= -->
<div id="helpModal" class="print-scope" style="display:none;">

  <div id="helpBackdrop"></div>

  <div id="helpPanel" role="dialog" aria-modal="true" aria-label="Aide et formules">
    <div class="helpHeader">
      <div class="helpTitle">‚ÑπÔ∏è Guide ‚Äî Formules & Conventions (Alignement)</div>

      <div class="helpActions">
        <button id="btnHelpPrint" type="button" class="helpBtn">üñ®Ô∏è Imprimer</button>
        <button id="btnHelpClose" type="button" class="helpBtn secondary">Fermer ‚úï</button>
      </div>
    </div>

    <div id="helpContent" class="helpContent">
      <!-- inject√© par JS -->
    </div>
  </div>

</div>
  <!-- =========================
     MODAL üéì TRAINING
========================= -->
<div id="trainingModal" style="display:none;">
  <div id="trainingBackdrop"></div>

  <div id="trainingPanel">
    <div class="helpHeader">
    <div class="trainingOptions">
  <div class="opt">
    <label>Montage</label>
    <select id="trainMount">
      <option value="motor">Moteur</option>
      <option value="pump">Pompe</option>
    </select>
  </div>

  <div class="opt">
    <label>D√©faut</label>
    <select id="trainType">
      <option value="parV">Par V</option>
      <option value="angV">Ang V</option>
      <option value="parH">Par H</option>
      <option value="angH">Ang H</option>
    </select>
  </div>
</div>

      <div class="helpActions">
        <button id="btnTrainingClose" type="button" class="helpBtn secondary">
          Fermer ‚úï
        </button>
      </div>
    </div>

    <div id="trainingContent" class="helpContent">
      <!-- inject√© par JS -->
    </div>
    <!-- =========================
     CONTROLES MODE TEST
========================= -->
<div id="trainingControls" style="margin-top:14px">

  <div class="row">
    <div>
      <label>D√©faut angulaire (mils)</label>
      <input id="trainAngular" type="range" min="-50" max="50" value="0">
    </div>

    <div>
      <label>D√©faut parall√®le (mils)</label>
      <input id="trainParallel" type="range" min="-50" max="50" value="0">
    </div>
  </div>

  <button id="btnResetTraining" style="margin-top:10px">
    Z√©ro d√©fauts (TEST)
  </button>

</div>
  </div>
</div>
</div>
<script>
"use strict";
/* =====================================================
   AIDE / FORMULES (BULLE ‚ÑπÔ∏è) + IMPRESSION
===================================================== */

// 1) contenu HTML de la fiche
function buildHelpHTML(){
  // ‚ö†Ô∏è Ici on √©crit LA r√©f√©rence p√©dagogique (une seule source de v√©rit√©)
  return `
  <h3><b>Conventions importantes</b></h3>

<div class="box">
  <b>1) Comparateur invers√© = mesure RELATIVE entre 2 arbres</b><br>
  La lecture au cadran repr√©sente l‚Äô√©cart entre l‚Äôarbre mobile (moteur) et l‚Äôarbre fixe (pompe).<br>
</div>

<div class="box">
  <b>2) Parall√©lisme (12‚Äì6 et 3‚Äì9) : r√®gle CRITIQUE</b><br>
  Correction moteur = Lecture √∑ 2<br>
  Parce que l‚Äôon corrige uniquement une des deux machines (le moteur).
</div>

<div class="box">
  <b>3) Angularit√©</b><br>
  Les valeurs <b>Avant</b> et <b>Arri√®re</b> sont des valeurs absolues de cale.
  Ensuite, le <b>signe</b> (+ / ‚àí) indique quelle extr√©mit√© est plus haute ou plus basse, et la r√®gle (ajouter / enlever) indique sur quelles pattes appliquer la correction.
</div>


<h3><b>√âtape 1 ‚Äî Voilage (Runout)</b></h3>
<div class="box">
  But : v√©rifier que la rotation est correcte et que la lecture est dans la tol√©rance.<br>
  Condition : Il faut que la valeur mesur√©e soit plus petite que la tol√©rance admissible.
</div>


<h3><b>√âtape 2 ‚Äî Pied boiteux (Soft Foot)</b></h3>
<div class="box">
  M√©thode par diagonales :<br>
  Diag 1 = A (haut gauche) + C (bas droit)<br>
  Diag 2 = B (haut droit) + D (bas gauche)<br><br>

  Œî = Diag 1 (celle ayant la plus grande valeur) ‚àí Diag 2 (celle ayant la valeur la plus petite<br>
  Si le r√©sultat est de 3 mils et moins= Aucune correction n√©c√©ssaire.
  Si r√©sultat est de plus de 3 mils= Correction ‚âà 0.8 √ó Œî<br>
  On corrige les deux pattes de la diagonale la plus √©lev√©e.
  Par patte (2 pattes) = Correction √∑ 2<br><br>
</div>


<h3><b>√âtape 3 ‚Äî Mesures g√©om√©triques</b></h3>
<div class="box">
  D = diam√®tre de l‚Äôaccouplement (support) en pouces (po)<br>
  a = distance entre le point de mesure et les pattes AVANT (po)<br>
  b = distance entre les pattes AVANT et les pattes ARRI√àRE (po)
</div>


<h3><b>√âtape 4 ‚Äî Angularit√© verticale (12‚Äì6)</b></h3>
<div class="box">
  Lecture : v = Lecture du cadran 12‚Äì6 (mils)<br><br>

  Formules :<br>
  Avant  = (v √∑ D) √ó a<br>
  Arri√®re = (v √∑ D) √ó (a + b)<br><br>

  Appliquer ensuite selon le signe (+ / ‚àí) et la r√®gle d‚Äôajout / retrait.
</div>


<h3><b>√âtape 5 ‚Äî Parall√©lisme vertical (12‚Äì6)</b></h3>
<div class="box">
  Lecture : Lecture du cadran 12‚Äì6
  R√®gle : Correction = Valeur mesur√©e √∑ 2<br><br>

  Application : m√™me correction sur les quatre pattes (A + B + C + D), en ajout ou en retrait selon le signe.
</div>


<h3><b>√âtape 6 ‚Äî Angularit√© horizontale (3‚Äì9)</b></h3>
<div class="box">
  Lecture : Lecture du cadran 3‚Äì9 <br><br>

  Formules :<br>
  Avant  = (h √∑ D) √ó a<br>
  Arri√®re = (h √∑ D) √ó (a + b)<br><br>

  Appliquer selon le signe (+ / ‚àí) sur les bonnes pattes en poussant ou en tirant.
</div>


<h3><b>√âtape 7 ‚Äî Parall√©lisme horizontal (3‚Äì9)</b></h3>
<div class="box">
  Lecture : p = parH (mils)<br>
  R√®gle : Correction = |p| √∑ 2<br><br>

  Le d√©placement r√©el du moteur correspond √† la moiti√© de la lecture mesur√©e.
</div>
  `;
}

// 2) ouvrir/fermer/imprimer
function openHelp(){
  const modal = document.getElementById("helpModal");
  const content = document.getElementById("helpContent");
  if(!modal || !content) return;

  content.innerHTML = buildHelpHTML();
  modal.style.display = "block";
  document.body.classList.add("modal-open");
}

function closeHelp(){
  const modal = document.getElementById("helpModal");
  if(!modal) return;
  modal.style.display = "none";
  document.body.classList.remove("modal-open");
}

function printHelp(){
  // Ouvre si jamais ferm√©, pour √™tre s√ªr d‚Äôimprimer la fiche
  const modal = document.getElementById("helpModal");
  if(modal && modal.style.display !== "block"){
    openHelp();
  }
  window.print();
}

function buildTrainingHTML(){
  return `


<div class="box">
<b>But p√©dagogique :</b><br>
Comprendre le lien entre :
<ul>
<li>D√©placement r√©el du moteur</li>
<li>Position du comparateur</li>
<li>Lecture au cadran (directe ou invers√©e)</li>
</ul>
</div>



<div style="margin-top:18px;">
  <label>D√©placement r√©el du moteur (mils)</label>
  <input id="trainSlider" type="range" min="-100" max="100" step="1" value="0">

  <div id="dialBlock" style="display:flex; flex-direction:column; align-items:center; margin-top:10px;">

<div id="dialWrap">
  <canvas id="trainDial"></canvas>
</div>

<div id="dialValue">0.00 mil</div>

<!-- üîò BOUTON Z√âRO CADRAN -->
  <button id="zeroDialBtn"
    style="padding:6px 14px; font-size:13px; border-radius:10px;
           border:none; background:#ff9800; color:#000; font-weight:900;">
    Z√©ro cadran
  </button>


<div id="trainingExplain"></div>
  </div>

  <div style="display:flex; justify-content:space-between; font-size:12px;">
    <span>-100</span>
    <span>0</span>
    <span>+100</span>
  </div>
</div>

</div>

<!-- ============================
     SANDBOX VISUEL ‚Äî TRAINING SEULEMENT
============================= -->
<div class="card" style="margin-top:16px; border:2px dashed rgba(255,255,255,.25);">
  <h3 style="margin-top:0;">Visualisation p√©dagogique</h3>

  <div class="canvasGrid">
    <div class="canvasCard">
      <div class="canvasHeader">Vue de dessus ‚Äî TRAINING</div>
      <canvas id="topViewTest"></canvas>
    </div>

    <div class="canvasCard">
      <div class="canvasHeader">Vue de profil ‚Äî TRAINING</div>
      <canvas id="sideViewTest"></canvas>
    </div>
  </div>
</div>

<div id="trainInfo" class="noteBox" style="margin-top:14px;text-align:center;">
‚Äî
</div>
`;
}

function openTraining(){
  trainingMode = true;
  const modal = document.getElementById("trainingModal");
  const content = document.getElementById("trainingContent");
  if(!modal || !content) return;

  content.innerHTML = buildTrainingHTML();
  console.log("TRAINING HTML inject√©");

const tc = document.getElementById("topViewTest");
const sc = document.getElementById("sideViewTest");

console.log("topViewTest:", tc);
console.log("sideViewTest:", sc);

if(tc && sc){
  window.topCanvasTest  = tc;
  window.sideCanvasTest = sc;

  window.topCtxTest  = tc.getContext("2d");
  window.sideCtxTest = sc.getContext("2d");
}

modal.style.display = "block";
document.body.classList.add("modal-open");
document.body.classList.add("training-on");
document.body.classList.add("training-on", "mobile-compact");
// ‚úÖ iPhone/Safari: forcer le layout du modal avant de dessiner le cadran
requestAnimationFrame(() => {
  requestAnimationFrame(() => {
    drawDial(0, 0);      // reset visuel imm√©diat
    updateTraining();    // redraw avec la vraie taille
  });
});


  // ===============================
  // INIT TRAINING (√âTAPE 3)
  // ===============================

  const slider = document.getElementById("trainSlider");
  const mount  = document.getElementById("trainMount");
  const type   = document.getElementById("trainType");
  
  
  const zeroBtn = document.getElementById("zeroDialBtn");

if(zeroBtn){
  zeroBtn.addEventListener("click", () => {

    // ===== RESET TOTAL =====

    // 1) Slider
    trainValue = 0;
    if(slider){
      slider.value = 0;
    }

    // 2) Z√©ro cadran (aiguille)
    dialZeroOffset = 0;

    // 3) RESET m√©canique (dessins)
    state.parV = 0;
    state.parH = 0;
    state.angV = 0;
    state.angH = 0;

    // 4) Redessin complet
    updateTraining();
  });
}
  if(slider){
  slider.addEventListener("input", () => {

    trainValue = parseFloat(slider.value);

    

    updateTraining();
    
  });
}
  if(type){
    type.addEventListener("change", () => {
      trainType = type.value;
      updateTraining();
    });
  }

  if(mount){
    mount.addEventListener("change", () => {
      trainMount = mount.value;
      updateTraining();
    });
  }

  trainValue = 0;
trainType  = type?.value || "angV";
trainMount = mount?.value || "motor";

dialZeroOffset = 0;   // üîë RESET Z√âRO AU D√âPART

if(slider) slider.value = 0;

updateTraining();
}
function closeTraining(){
  trainingMode = false;
  const modal = document.getElementById("trainingModal");
  if(!modal) return;

  modal.style.display = "none";
  document.body.classList.remove("modal-open");
  document.body.classList.remove("training-on");
  document.body.classList.remove("training-on", "mobile-compact");
}
/* =====================================================
   TRAINING ‚Äî MOTEUR DU CADRAN
===================================================== */

let trainValue = 0;
let trainType  = "angV";
let trainMount = "motor";
let trainingOffset = 0;
let trainingMode = false;
let dialZeroOffset = 0;

const DIAL = {
  center: 130,
  radius: 110,
  needle: 90
};

function drawDial(needleVal, displayVal){

  const canvas = document.getElementById("trainDial");
  if(!canvas) return;

  const ctx = canvas.getContext("2d");

  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const size = Math.max(220, Math.min(300, rect.width || 260));

  canvas.width  = Math.round(size * dpr);
  canvas.height = Math.round(size * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  const w = size, h = size;
  const cx = w/2, cy = h/2;

  const R_outer = w * 0.47;
  const R_ticks = w * 0.44;
  const R_text  = w * 0.36;
  const R_needle= w * 0.40;

  let nv = Number(needleVal);

if (isNaN(nv)) nv = 0;

// snap parfait au z√©ro (√©vite les r√©sidus flottants Safari)
if (Math.abs(nv) < 0.001) nv = 0;

nv = Math.max(-100, Math.min(100, nv));

  ctx.clearRect(0,0,w,h);

  // fond
  ctx.fillStyle = "#0b1436";
  ctx.fillRect(0,0,w,h);

  // disque
  ctx.beginPath();
  ctx.arc(cx,cy, R_outer, 0, Math.PI*2);
  ctx.fillStyle = "#000";
  ctx.fill();

  // anneaux
  ctx.lineWidth = 6;
  ctx.strokeStyle = "rgba(255,255,255,.25)";
  ctx.beginPath();
  ctx.arc(cx,cy, R_outer, 0, Math.PI*2);
  ctx.stroke();

  ctx.lineWidth = 3;
  ctx.strokeStyle = "rgba(255,255,255,.40)";
  ctx.beginPath();
  ctx.arc(cx,cy, R_ticks, 0, Math.PI*2);
  ctx.stroke();

  ctx.save();
  ctx.translate(cx,cy);

  // graduations fines 0 ‚Üí 100 sur 360¬∞
  for(let i=0; i<100; i++){
    const a = -Math.PI/2 + (i/100)*Math.PI*2;

    let len = 6;
    let lw  = 1;

    if(i%5===0){ len=12; lw=2; }
    if(i%10===0){ len=18; lw=3; }
    if(i%50===0){ len=24; lw=4; }

    const x1 = Math.cos(a)*(R_ticks-len);
    const y1 = Math.sin(a)*(R_ticks-len);
    const x2 = Math.cos(a)*R_ticks;
    const y2 = Math.sin(a)*R_ticks;

    ctx.strokeStyle="rgba(255,255,255,.9)";
    ctx.lineWidth=lw;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();

    if(i%10===0){
      const tx = Math.cos(a)*R_text;
      const ty = Math.sin(a)*R_text;
      ctx.fillStyle="#fff";
      ctx.font="bold 13px Arial";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText(i===0?"0":i,tx,ty);
    }
  }

  // ================= AIGUILLE =================
ctx.save();

// 1 tour complet √† ¬±100
const ang = (nv / 100) * (Math.PI * 2);
ctx.rotate(ang);

// dessin aiguille (0 = 12h car on dessine vers le haut)
ctx.strokeStyle = "#ff3b30";
ctx.lineWidth = 4;
ctx.beginPath();
ctx.moveTo(0, 12);
ctx.lineTo(0, -R_needle);
ctx.stroke();

// hub
ctx.fillStyle = "#fff";
ctx.beginPath();
ctx.arc(0, 0, 7, 0, Math.PI * 2);
ctx.fill();

ctx.restore();
} 

function computeDialReading(){

  let reading = 0;

  // Parall√©lisme = lecture = 2 √ó d√©placement r√©el
  if(trainType === "parV" || trainType === "parH"){
    reading = trainValue * 2;
  }

  // Angularit√© = lecture directe (simplification p√©dagogique)
  if(trainType === "angV" || trainType === "angH"){
    reading = trainValue;
  }

  // Inversion si cadran mont√© sur la pompe
  if(trainMount === "pump"){
    reading = -reading;
  }

  return reading - dialZeroOffset;
}


function updateTraining(){

  // ===== INJECTION DU TRAINING DANS LA G√âOM√âTRIE =====
if(trainingMode){

  state.parV = 0;
  state.parH = 0;
  state.angV = 0;
  state.angH = 0;

  if(trainType === "parV") state.parV = trainValue;
  if(trainType === "parH") state.parH = trainValue;
  if(trainType === "angV") state.angV = trainValue;
  if(trainType === "angH") state.angH = trainValue;
}

const reading = computeDialReading();

    // Position r√©elle du comparateur ‚Üí aiguille


drawDial(reading, reading);
  renderAll();
  
  const txt = document.getElementById("dialValue");
  if(txt){
    txt.textContent = `${reading.toFixed(2)} mil`;
  }

  const explain = document.getElementById("trainingExplain");
  if(explain){

    let msg = "<b>Interpr√©tation m√©canique :</b><br>";

    msg += `D√©placement moteur : <b>${trainValue.toFixed(2)} mil</b><br>`;
    msg += `Lecture cadran : <b>${reading.toFixed(2)} mil</b><br><br>`;

    if(trainType.startsWith("par")){
      msg += "üìè Parall√©lisme ‚Üí le comparateur lit la moiti√© du d√©placement r√©el.";
    }else{
      msg += "üìê Angularit√© ‚Üí la lecture d√©pend du bras de levier.";
    }

    if(trainMount === "pump"){
      msg += "<br>üîÅ Cadran mont√© sur la pompe ‚Üí lecture invers√©e.";
    }

    explain.innerHTML = msg;
  }
}

/* =====================================================
   MAPPING PATTES (lettres ‚Üî coins)
   Coins = TL (haut-gauche), TR (haut-droite),
           BR (bas-droite), BL (bas-gauche)
===================================================== */
const FOOT_SCHEMES = {
  standard: { name:"Standard (A HG, B HD, C BD, D BG)", TL:"A", TR:"B", BR:"C", BL:"D" },
  invBottom:{ name:"A / B / D / C (inverse bas)",      TL:"A", TR:"B", BR:"D", BL:"C" },
  rot180:   { name:"Rotation 180¬∞",                    TL:"C", TR:"D", BR:"A", BL:"B" },
  roles:    { name:"Par r√¥les (HA, HB, BA, BB)",       TL:"HA",TR:"HB",BR:"BB",BL:"BA" }
};


// mode actif
let footSchemeKey = "standard";






// retourne l'√©tiquette (texte) √† afficher pour un coin
function cornerLabel(corner){
  return FOOT_SCHEMES[footSchemeKey][corner];
}

// retourne la valeur softfoot (mils) pour un coin, peu importe le mode
function sfVal(corner){
  const key = cornerLabel(corner);           // ex: "A" ou "D" ou "HA"
  return Number(state.softFoot[key] || 0);
}
let dialSign = 1;   // +1 = CW normal,  -1 = CW invers√©
let correctionMode = "add";  // "add" | "remove"
let currentView = "top"; // "top" | "side"
let blinkPhase = true;
let visualGain = 6;
const FOOT_NORMAL = "#0070c0";   // bleu fonc√© visible
// ============================
// ORIENTATION / √âTIQUETTES PATTES (affichage seulement)
// ============================
let footLayout = "ABCD";

// mapping: lettre interne -> texte affich√©
const footLabelMap = {
  // Interne : A B C D (A=haut-gauche, B=haut-droite, C=bas-droite, D=bas-gauche)
  "ABCD": { A:"A", B:"B", C:"C", D:"D" },

  // Exemple demand√©: A/B/D/C
  "ABDC": { A:"A", B:"B", C:"D", D:"C" },

  // Rotation 180¬∞ (haut-gauche devient bas-droite, etc.)
  "R180": { A:"C", B:"D", C:"A", D:"B" },

  // Mode r√¥les (HA/HB/BA/BB)
  // HA = Haut Arri√®re, HB = Haut Avant, BA = Bas Arri√®re, BB = Bas Avant
  // ‚ö†Ô∏è Ici, on ASSUME que "haut" = c√¥t√© arbre vers pompe (en haut de ton dessin TopView),
  // et "avant" = c√¥t√© accouplement (√† droite dans ton dessin). Tu peux changer ces mots ensuite.
  "ROLE": { A:"HA", B:"HB", C:"BB", D:"BA" },
};

function labelFoot(letter){
  return footLabelMap[footLayout]?.[letter] || letter;
}

// utilitaire: transforme ["A","C"] en "HA + BA" (ou autre)
function labelFeet(arr){
  return arr.map(labelFoot).join(" + ");
}

const gainSlider = document.getElementById("gainSlider");
if(gainSlider){
  gainSlider.addEventListener("input", () => {
    visualGain = parseFloat(gainSlider.value) || 1;
    drawSideView();
    drawTopView();
  });
}
setInterval(() => {
  blinkPhase = !blinkPhase;

  // ‚ö†Ô∏è JAMAIS toucher √† l‚ÄôUI ici
  drawTopView();
  drawSideView();
}, 600);


const GEOM = {
  motorW: 200,
  motorH: 80,

  pumpW: 130,
  pumpH: 80,

  gap: 70,

  shaftH: 12,
  coupH: 56,
  coupW: 10,

  // ===== DIMENSIONS G√âOM√âTRIQUES POUR CALCULS =====
  dialSpan: 12,          // D = distance entre comparateurs
  centerToFrontFeet: 6, // a = centre ‚Üí pattes avant
  frontToRearFeet: 10   // b = pattes avant ‚Üí arri√®re
};
  
/* =====================================================
   √âTAT GLOBAL (mils)
===================================================== */
const state = {
  step: 0,
  measureStep: 0,
  
  runout: 0,
  runoutTol: 2,

  softFoot: { A:0, B:0, C:0, D:0, HA:0, HB:0, BA:0, BB:0 },
  softFootTol: 3,
  
  footScheme: "standard",

  angV: 0,
  angVTol: 1,

  parV: 0,
  parVTol: 1,

  angH: 0,
  angHTol: 1,

  parH: 0,
  parHTol: 1
};
/* =====================================================
   PARAM√àTRES G√âOM√âTRIQUES (pouces)
===================================================== */
const geometry = {
  couplingDiameter: 3,      // √ò accouplement
  centerToFrontFeet: 6,    // Centre ‚Üí pattes AVANT
  frontToRearFeet: 10      // Pattes AVANT ‚Üí ARRI√àRE
};
/* =====================================================
   D√âFINITION DES √âTAPES
===================================================== */
const STEPS = [
  { id:"runout",  label:"1 ‚Äî Voilage" },
  { id:"softfoot",label:"2 ‚Äî Pied boiteux" },
  { id:"measures",label:"3 ‚Äî Mesures g√©om√©triques" },

  { id:"angV",    label:"4 ‚Äî Angularit√© verticale" },
  { id:"parV",    label:"5 ‚Äî Parall√©lisme vertical" },

  { id:"angH",    label:"6 ‚Äî Angularit√© horizontale" },
  { id:"parH",    label:"7 ‚Äî Parall√©lisme horizontal" }
];
/* =====================================================
   UTILITAIRES
===================================================== */
const abs = Math.abs;
const ok = (v,t) => abs(v) <= t;
function mapFeetByScheme(A, B, C, D, scheme){
  switch(scheme){
    case "standard":
      return { A, B, C, D };

    case "invBottom":   // A / B / D / C
      return { A, B, C: D, D: C };

    case "rot180":      // rotation 180¬∞
      return { A: C, B: D, C: A, D: B };

    case "roles":       // futur (non utilis√© encore)
      return { A, B, C, D };

    default:
      return { A, B, C, D };
  }
}
function mapFeetToCorners(){

  const { A, B, C, D, HA, HB, BA, BB } = state.softFoot;

  const scheme = FOOT_SCHEMES[footSchemeKey];

  return {
    TL: Number(state.softFoot[scheme.TL] || 0),
    TR: Number(state.softFoot[scheme.TR] || 0),
    BR: Number(state.softFoot[scheme.BR] || 0),
    BL: Number(state.softFoot[scheme.BL] || 0)
  };
}
/* =====================================================
   PIED BOITEUX ‚Äî DIAGONALES
   AC vs BD
===================================================== */
function computeSoftFoot(){

  const feet = mapFeetToCorners();

  const diag1 = feet.TL + feet.BR;   // diagonale TL ‚Üî BR
  const diag2 = feet.TR + feet.BL;   // diagonale TR ‚Üî BL

  const delta = Math.abs(diag1 - diag2);
  const correction = delta * 0.8;

  let faulty = null;

  if(diag1 > diag2) faulty = ["TL","BR"];
  if(diag2 > diag1) faulty = ["TR","BL"];

  return {
    diagAC: diag1,
    diagBD: diag2,
    delta,
    correction,
    faulty
  };
}
/* =====================================================
   ANGULARIT√â VERTICALE ‚Äî PAIRES
   Avant = BC
   Arri√®re = AD
===================================================== */
function computeAngularVertical(){

  const v = state.angV * dialSign;

  // POSITIF ‚Üí ARRI√àRE trop bas
  if(v > 0){

    if(correctionMode === "add"){
      return {
        pair:["A","D"],
        direction:"ARRI√àRE trop bas ‚Äî AJOUTER sous A + D"
      };
    }else{
      return {
        pair:["B","C"],
        direction:"ARRI√àRE trop bas ‚Äî ENLEVER sous B + C"
      };
    }

  }

  // N√âGATIF ‚Üí AVANT trop bas
  if(v < 0){

    if(correctionMode === "add"){
      return {
        pair:["B","C"],
        direction:"AVANT trop bas ‚Äî AJOUTER sous B + C"
      };
    }else{
      return {
        pair:["A","D"],
        direction:"AVANT trop bas ‚Äî ENLEVER sous A + D"
      };
    }

  }

  return null;
}



/* =====================================================
   PARALL√âLISME VERTICAL ‚Äî 4 PATTES
===================================================== */
function computeParallelVertical(){
  if(state.parV > 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop bas" };
  }
  if(state.parV < 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop haut" };
  }
  return null;
}
/* =====================================================
   ANGULARIT√â HORIZONTALE ‚Äî TOP VIEW
===================================================== */
function computeAngularHorizontal(){

  const v = state.angH * dialSign;

  // Lecture POSITIVE ‚Üí moteur inclin√© vers la DROITE
  if(v > 0){
    return {
      pair:["B","D"],
      direction:"Moteur inclin√© vers la DROITE ‚Üí corriger B + D"
    };
  }

  // Lecture N√âGATIVE ‚Üí moteur inclin√© vers la GAUCHE
  if(v < 0){
    return {
      pair:["A","C"],
      direction:"Moteur inclin√© vers la GAUCHE ‚Üí corriger A + C"
    };
  }

  return null;
}
/* =====================================================
   PARALL√âLISME HORIZONTAL ‚Äî PAIRES
===================================================== */
function computeParallelHorizontal(){
  if(state.parH > 0){
    return {
      pair:["C","D"],
      direction:"Moteur trop √† droite ‚Üí d√©placer vers la GAUCHE"
    };
  }
  if(state.parH < 0){
    return {
      pair:["A","B"],
      direction:"Moteur trop √† gauche ‚Üí d√©placer vers la DROITE"
    };
  }
  return null;
}
/* =====================================================
   CALCUL CORRECTION ANGULAIRE (mils r√©els)
   B √ó C / A
===================================================== */
function computeAngularShim(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const C = Math.abs(state.angV); // lecture cadran (mils)

  if(A <= 0) return 0;

  return (B * C) / A;
}

function computeAngularShimH(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const C = Math.abs(state.angH); // lecture cadran horizontale (mils)

  if(A <= 0) return 0;
  return (B * C) / A;
}



function computeAngularShimsVertical(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const D = geometry.frontToRearFeet;
  const C = Math.abs(state.angV * dialSign);

  if(A <= 0) return { front:0, rear:0 };

  return {
    front: (B * C) / A,
    rear: ((B + D) * C) / A
  };
}

function computeAngularShimsHorizontal(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const D = geometry.frontToRearFeet;
  const C = Math.abs(state.angH * dialSign);

  if(A <= 0) return { front:0, rear:0 };

  return {
    front: (B * C) / A,
    rear: ((B + D) * C) / A
  };
}
/* =====================================================
   VALIDATION PAR √âTAPE
===================================================== */
function isStepOK(stepIndex){
  const id = STEPS[stepIndex].id;

  if(id === "measures"){
    return geometry.couplingDiameter > 0 &&
           geometry.centerToFrontFeet > 0 &&
           geometry.frontToRearFeet > 0;
  }

  if(id === "runout")  return ok(state.runout, state.runoutTol);
  if(id === "softfoot")return computeSoftFoot().delta <= state.softFootTol;

  if(id === "angV")    return ok(state.angV, state.angVTol);
  if(id === "parV")    return ok(state.parV, state.parVTol);

  if(id === "angH")    return ok(state.angH, state.angHTol);
  if(id === "parH")    return ok(state.parH, state.parHTol);

  return true;
}
/* =====================================================
   MESSAGE TEXTE (ZONE INFO)
===================================================== */
function buildMessage(){
  const step = STEPS[state.step];
  let txt = `√âtape ${step.label}\n\n`;

  if(!isStepOK(state.step)){
    txt += "‚ö†Ô∏è Hors tol√©rance\n\n";
  }else{
    txt += "‚úÖ Dans la tol√©rance\n\n";
  }

  if(step.id === "softfoot"){
    const sf = computeSoftFoot();
    txt += `Diag AC = ${sf.diagAC}\n`;
    txt += `Diag BD = ${sf.diagBD}\n`;
    txt += `Œî = ${sf.delta}\n`;
    txt += `Correction ‚âà ${sf.correction}\n`;
    if(sf.faulty){
      txt += `Pattes √† corriger : ${labelFeet(sf.faulty)}`;
    }
  }

  return txt;
}


/* =====================================================
   UI ‚Äî DOM
===================================================== */
const ui = {
  stepTitle: document.getElementById("stepTitle"),
  stepBadge: document.getElementById("stepBadge"),
  inputsArea: document.getElementById("inputsArea"),
  infoBox: document.getElementById("infoBox"),
  btnPrev: document.getElementById("btnPrev"),
  btnNext: document.getElementById("btnNext"),
    formulaBox: document.getElementById("formulaBox"),
};

/* =====================================================
   MESSAGES DE CORRECTION P√âDAGOGIQUES
===================================================== */

function buildCorrectionMessage(){
  const stepId = STEPS[state.step].id;
  let msg = "";

  // ---------- PIED BOITEUX ----------
  if(stepId === "softfoot"){
    const sf = computeSoftFoot();

    if(sf.delta <= state.softFootTol){
      return "‚úîÔ∏è Pied boiteux corrig√© ‚Äî aucune cale requise.";
    }

    const each = (sf.correction / 2).toFixed(1);

    msg += "ü¶∂ Pied boiteux\n\n";
    msg += "‚ö†Ô∏è Hors tol√©rance\n\n";
    msg += `Diag AC = ${sf.diagAC}\n`;
    msg += `Diag BD = ${sf.diagBD}\n`;
    msg += `Œî = ${sf.delta}\n`;
    msg += `Correction ‚âà ${sf.correction}\n\n`;

    msg += "üë£ Pied boiteux d√©tect√©\n\n";
    msg += `‚ûï Ajouter **+${each} mil** sous :\n`;
    msg += `üëâ ${labelFeet(sf.faulty)}\n`;
    msg += "\n‚ö†Ô∏è Toujours corriger en DIAGONALE";

    return msg;
  }

  // ---------- ANGULARIT√â VERTICALE ----------
  if(stepId === "angV"){
    if(ok(state.angV, state.angVTol)){
      return "‚úîÔ∏è Angularit√© verticale conforme.";
    }

    const v = state.angV * dialSign;
    const a = geometry.centerToFrontFeet;  // centre ‚Üí pattes AVANT
const b = geometry.frontToRearFeet;    // pattes AVANT ‚Üí ARRI√àRE
const D = geometry.couplingDiameter;   // diam√®tre accouplement
    const shims = computeAngularShimsVertical();
    const front = shims.front.toFixed(2);
    const rear  = shims.rear.toFixed(2);
    
    msg += "üßÆ CALCUL ‚Äî Angularit√© verticale\n\n";

msg += `v = ${Math.abs(v).toFixed(2)} mil\n`;
msg += `a = ${a} po (centre ‚Üí pattes AVANT)\n`;
msg += `b = ${b} po (pattes AVANT ‚Üí ARRI√àRE)\n`;
msg += `D = ${D} po (√ò accouplement)\n\n`;

msg += "Formules :\n";
msg += "Avant  = (v / D) √ó a\n";
msg += "Arri√®re = (v / D) √ó (a + b)\n\n";

msg += `Avant  = (${Math.abs(v).toFixed(2)} / ${D}) √ó ${a} = ${front} mil\n`;
msg += `Arri√®re = (${Math.abs(v).toFixed(2)} / ${D}) √ó ${a + b} = ${rear} mil\n\n`;

    msg += "üìê Angularit√© verticale\n\n";

    if(v > 0){
      msg += "Lecture POSITIVE ‚Üí AVANT plus haut que l‚Äôarri√®re\n";
      msg += "(moteur inclin√© vers l‚Äôarri√®re)\n\n";
      msg += "Action m√©canique : abaisser l‚Äôavant\n\n";
      msg += "Corrections possibles :\n";
      msg += `‚ûñ Enlever ${front} mil sous : ${labelFeet(["B","C"])}\n`;
      msg += `OU\n`;
      msg += `‚ûï Ajouter ${rear} mil sous : ${labelFeet(["A","D"])}`;
    }

    if(v < 0){
      msg += "Lecture N√âGATIVE ‚Üí ARRI√àRE plus haut que l‚Äôavant\n";
      msg += "(moteur inclin√© vers l‚Äôavant)\n\n";
      msg += "Action m√©canique : abaisser l‚Äôarri√®re\n\n";
      msg += "Corrections possibles :\n";
      msg += `‚ûñ Enlever ${rear} mil sous : ${labelFeet(["A","D"])}\n`;
      msg += `OU\n`;
      msg += `‚ûï Ajouter ${front} mil sous : ${labelFeet(["B","C"])}`;
    }

    return msg;
  }

  // ---------- PARALL√âLISME VERTICAL ----------
  if(stepId === "parV"){
    if(ok(state.parV, state.parVTol)){
      return "‚úîÔ∏è Parall√©lisme vertical conforme.";
    }

    const v   = state.parV;
    const amt = Math.abs(v).toFixed(2);

    msg += "‚ÜïÔ∏è Parall√©lisme vertical\n\n";

    if(v > 0){
      msg += "Lecture N√âGATIVE ‚Üí moteur trop BAS\n\n";
      msg += "Action m√©canique : remonter le moteur\n\n";
      msg += "Correction :\n";
      msg += `‚ûï Ajouter +${amt} mil sous :\n`;
      msg += "üëâ A + B + C + D\n";
      msg += "(m√™me quantit√© sur les 4 pattes)";
    }

    if(v < 0){
      msg += "Lecture POSITIVE ‚Üí moteur trop HAUT\n\n";
      msg += "Action m√©canique : abaisser le moteur\n\n";
      msg += "Correction :\n";
      msg += `‚ûñ Enlever ${amt} mil sous :\n`;
      msg += "üëâ A + B + C + D\n";
      msg += "(m√™me quantit√© sur les 4 pattes)";
    }

    return msg;
  }

  // ---------- ANGULARIT√â HORIZONTALE ----------
// ---------- ANGULARIT√â HORIZONTALE ----------
// ---------- ANGULARIT√â HORIZONTALE ----------
if(stepId === "angH"){

  if(ok(state.angH, state.angHTol)){
    return "‚úîÔ∏è Angularit√© horizontale conforme.";
  }

  const v = state.angH * dialSign;
  const D = GEOM.dialSpan;
  const a = GEOM.centerToFrontFeet;
  const b = GEOM.frontToRearFeet;

  const front = (Math.abs(v) * a / D).toFixed(2);
  const rear  = (Math.abs(v) * (a + b) / D).toFixed(2);

  msg += "‚ÜîÔ∏è Angularit√© horizontale\n\n";

  msg += "üßÆ CALCUL :\n\n";
  msg += `v = ${v.toFixed(2)} mil\n`;
  msg += `D = ${D} po\n`;
  msg += `a = ${a} po\n`;
  msg += `b = ${b} po\n\n`;

  msg += "Formules :\n";
  msg += "Avant   = (v √ó a) / D\n";
  msg += "Arri√®re = (v √ó (a+b)) / D\n\n";

  msg += `Avant   = (${Math.abs(v).toFixed(2)} √ó ${a}) / ${D} = ${front} mil\n`;
  msg += `Arri√®re = (${Math.abs(v).toFixed(2)} √ó ${a+b}) / ${D} = ${rear} mil\n\n`;

  if(v > 0){
    msg += "üìà Lecture POSITIVE ‚Üí moteur inclin√© vers la DROITE\n\n";
    msg += "Correction m√©canique :\n";
    msg += `üëâ Tirer sur ${labelFeet(["B","D"])}\n`;
    msg += "OU\n";
    msg += `üëâ Pousser sur ${labelFeet(["A","C"])}\n`;
  }

  if(v < 0){
    msg += "üìâ Lecture N√âGATIVE ‚Üí moteur inclin√© vers la GAUCHE\n\n";
    msg += "Correction m√©canique :\n";
    msg += `üëâ Tirer sur ${labelFeet(["A","C"])}\n`;
    msg += "OU\n";
    msg += `üëâ Pousser sur ${labelFeet(["B","D"])}\n`;
  }

  return msg;
}
return "";
}
/* =====================================================
   UI ‚Äî Inputs par √©tape (avec IDs)
===================================================== */
function renderInputsForCurrentStep(){
  const id = STEPS[state.step].id;

  // IMPORTANT: valeurs par d√©faut = 0, tol√©rances ‚â† 0
  if(id === "runout"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Voilage (mils)</label>
          <input id="in_runout" type="number" step="0.1" value="${state.runout}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_runoutTol" type="number" step="0.1" value="${state.runoutTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_runout", v => state.runout = v],
      ["in_runoutTol", v => state.runoutTol = Math.max(0, v)],
    ]);
    return;
  }

  if(id === "softfoot"){
    ui.inputsArea.innerHTML = `
    
    <div style="margin-bottom:10px;">
  <label>Disposition des pattes</label>
  <select id="in_footScheme" style="width:100%; padding:10px; border-radius:12px; border:none;">
    <option value="standard">Standard (A HG, B HD, C BD, D BG)</option>
    <option value="invBottom">A / B / D / C (inverse bas)</option>
    <option value="rot180">Rotation 180¬∞</option>
    <option value="roles">Par r√¥les (HA, HB, BA, BB)</option>
  </select>
</div>
    
    
      <div class="row">
        <div>
          <label>Patte A (haut gauche)</label>
          <input id="in_sfA" type="number" step="0.1" value="${state.softFoot.A}">
        </div>
        <div>
          <label>Patte B (haut droite)</label>
          <input id="in_sfB" type="number" step="0.1" value="${state.softFoot.B}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Patte C (bas droite)</label>
          <input id="in_sfC" type="number" step="0.1" value="${state.softFoot.C}">
        </div>
        <div>
          <label>Patte D (bas gauche)</label>
          <input id="in_sfD" type="number" step="0.1" value="${state.softFoot.D}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Tol√©rance soft foot (mils)</label>
          <input id="in_sfTol" type="number" step="0.1" value="${state.softFootTol}">
        </div>
        <div>
          <label>Note</label>
          <div class="noteBox">La plus grande diagonale est affich√©e (soft foot seulement)
        </div>
      </div>
      </div>
    `;
    wireInputs([
      ["in_sfA", v => state.softFoot.A = Math.abs(v)],
      ["in_sfB", v => state.softFoot.B = Math.abs(v)],
      ["in_sfC", v => state.softFoot.C = Math.abs(v)],
      ["in_sfD", v => state.softFoot.D = Math.abs(v)],
      ["in_sfTol", v => state.softFootTol = Math.max(0, v)],
      ["in_footScheme", v => {
  footSchemeKey = v;
}]
    ]);
    return;
  }

if(id === "measures"){

  let html = "";

  // ===== SOUS-√âTAPE 1 ‚Äî √ò ACCOUPLEMENT =====
  if(state.measureStep === 0){
    html = `
      <div class="row">
        <div>
          <label style="color:#00a2ff;">√ò accouplement (po)</label>
          <input id="in_diam" class="c-blue" type="number" step="0.1"
                 value="${geometry.couplingDiameter}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <div class="noteBox">Mesurer le diam√®tre ext√©rieur de l‚Äôaccouplement
        </div>
      </div>
        </div>
    `;
  }

  // ===== SOUS-√âTAPE 2 ‚Äî CENTRE ‚Üí AVANT =====
  if(state.measureStep === 1){
    html = `
      <div class="row">
        <div>
          <label style="color:#4caf50;">Centre ‚Üí pattes AVANT (po)</label>
          <input id="in_centerFront" class="c-green" type="number" step="0.1"
                 value="${geometry.centerToFrontFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <div class="noteBox">Mesurer du centre de l‚Äôaccouplement jusqu‚Äôaux pattes avant du moteur
        </div>
      </div>
        </div>
    `;
  }

  // ===== SOUS-√âTAPE 3 ‚Äî AVANT ‚Üí ARRI√àRE =====
  if(state.measureStep === 2){
    html = `
      <div class="row">
        <div>
          <label style="color:#ff9800;">Pattes AVANT ‚Üí ARRI√àRE (po)</label>
          <input id="in_frontRear" class="c-orange" type="number" step="0.1"
                 value="${geometry.frontToRearFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <div class="noteBox">Mesurer la distance entre pattes avant et arri√®re du moteur
        </div>
      </div>
        </div>
    `;
  }

  ui.inputsArea.innerHTML = html;

  if(state.measureStep === 0){
    wireInputs([["in_diam", v => geometry.couplingDiameter = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 1){
    wireInputs([["in_centerFront", v => geometry.centerToFrontFeet = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 2){
    wireInputs([["in_frontRear", v => geometry.frontToRearFeet = Math.max(0.1, v)]]);
  }

  return;
}

  // =====================================================
  // ANGULARIT√â VERTICALE
  // =====================================================
  if(id === "angV"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Lecture cadran 12‚Äì6 (mils)</label>
        <input id="in_angV" type="number" step="0.1" value="${state.angV}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_angVTol" type="number" step="0.1" value="${state.angVTol}">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Note</label>
        <div class="noteBox">
          Les distances g√©om√©triques proviennent de l‚Äô√©tape 3
        </div>
      </div>
    </div>
  `;

  wireInputs([
    ["in_angV", v => state.angV = v],
    ["in_angVTol", v => state.angVTol = Math.max(0, v)]
  ]);
  return;
}

if(id === "parV"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Parall√©lisme vertical (mils)</label>
        <input id="in_parV" type="number" step="0.1" value="${state.parV}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_parVTol" type="number" step="0.1" value="${state.parVTol}">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Note</label>
        <div class="noteBox">
          Correction uniforme sur les 4 pattes
        </div>
      </div>
    </div>
  `;

  wireInputs([
    ["in_parV", v => state.parV = v],
    ["in_parVTol", v => state.parVTol = Math.max(0, v)]
  ]);
  return;
}


  // =====================================================
  // ANGULARIT√â HORIZONTALE
  // =====================================================
  if(id === "angH"){
  ui.inputsArea.innerHTML = `
    <div class="row">
      <div>
        <label>Lecture cadran 3‚Äì9 (mils)</label>
        <input id="in_angH" type="number" step="0.1" value="${state.angH}">
      </div>
      <div>
        <label>Tol√©rance (mils)</label>
        <input id="in_angHTol" type="number" step="0.1" value="${state.angHTol}">
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Note</label>
        <div class="noteBox">
          Les distances g√©om√©triques proviennent de l‚Äô√©tape 3
        </div>
      </div>
    </div>
  `;

  wireInputs([
    ["in_angH", v => state.angH = v],
    ["in_angHTol", v => state.angHTol = Math.max(0, v)]
  ]);
  return;
}
  if(id === "parH"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Parall√©lisme horizontal (mils)</label>
          <input id="in_parH" type="number" step="0.1" value="${state.parH}">
        </div>
        <div>
          <label>Tol√©rance (mils)</label>
          <input id="in_parHTol" type="number" step="0.1" value="${state.parHTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_parH", v => state.parH = v],
      ["in_parHTol", v => state.parHTol = Math.max(0, v)],
    ]);
    return;
  }
}
function buildFormulaSoftFoot(){
  const sf = computeSoftFoot();

  // Valeurs entr√©es
  const A = state.softFoot.A;
  const B = state.softFoot.B;
  const C = state.softFoot.C;
  const D = state.softFoot.D;

  // Calculs
  const diagAC = sf.diagAC;
  const diagBD = sf.diagBD;
  const delta  = sf.delta;

  const corr   = sf.correction;      // 80% du delta
  const each   = corr / 2;           // r√©parti sur 2 pattes

  // Quelle diagonale est fautive?
  let faultyTxt = "Aucune (diagonales √©gales)";
  if(sf.faulty) faultyTxt = sf.faulty.join(" + ");

  return (
`Pied boiteux ‚Äî Diagonales

Diag AC = A + C
       = ${A} + ${C}
       = ${diagAC.toFixed(2)} mil

Diag BD = B + D
       = ${B} + ${D}
       = ${diagBD.toFixed(2)} mil

Œî = |Diag AC ‚àí Diag BD|
  = |${diagAC.toFixed(2)} ‚àí ${diagBD.toFixed(2)}|
  = ${delta.toFixed(2)} mil

Correction ‚âà 0.8 √ó Œî
          = 0.8 √ó ${delta.toFixed(2)}
          = ${corr.toFixed(2)} mil

Par patte (2 pattes) = Correction / 2
                     = ${corr.toFixed(2)} / 2
                     = ${each.toFixed(2)} mil

Pattes √† corriger : ${faultyTxt}`
  );
}

/* =====================================================
   Wire inputs (lecture -> state -> redraw)
===================================================== */
function wireInputs(pairs){
  pairs.forEach(([inputId, setter]) => {
    const input = document.getElementById(inputId);
    if(!input) return;

    // Autoriser la saisie libre sans calcul imm√©diat
    input.addEventListener("input", () => {
      // Ne rien faire ici ‚Üí saisie fluide
    });

    // Validation sur ENTER
    input.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        input.blur();   // force validation
      }
    });

    // Validation finale quand on quitte le champ
    input.addEventListener("blur", () => {
      let raw = input.value.trim();

      if(raw === ""){
        raw = "0";
        input.value = "0";
      }

      const v = parseFloat(raw);
      setter(Number.isFinite(v) ? v : 0);

      refreshUI();
      drawTopView();
      drawSideView();
    });
  });
}
/* =====================================================
   UI sync
===================================================== */
function refreshUI(){
  ui.stepTitle.textContent = `√âtape ${STEPS[state.step].label}`;

  const okNow = isStepOK(state.step);
  ui.stepBadge.textContent = okNow ? "OK" : "NOT OK";
  ui.stepBadge.classList.toggle("ok", okNow);
  ui.stepBadge.classList.toggle("bad", !okNow);

  renderInputsForCurrentStep();

  ui.infoBox.textContent =
    buildMessage() + "\n\n" + buildCorrectionMessage();

  // ===== FORMULES (PC) ‚Äî √âTAPE 2 SEULEMENT =====
  if(ui.formulaBox){
    if(STEPS[state.step].id === "softfoot"){
      ui.formulaBox.textContent = buildFormulaSoftFoot();
    }else{
      ui.formulaBox.textContent = "";
    }
  }
}
/* =====================================================
   Navigation
===================================================== */
function nextStep(){
  // Sous-√©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep < 2){
      state.measureStep++;
      renderAll();
      return;
    }else{
      state.measureStep = 0;
      state.step++;
      renderAll();
      return;
    }
  }

  if(isStepOK(state.step) && state.step < STEPS.length - 1){
    state.step++;
    renderAll();
  }
}

function prevStep(){
  // Sous-√©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep > 0){
      state.measureStep--;
      renderAll();
      return;
    }else{
      // revenir √† l'√©tape pr√©c√©dente
      state.step--;
      renderAll();
      return;
    }
  }

  if(state.step > 0){
    state.step--;
    renderAll();
  }
}
ui.btnPrev.addEventListener("click", prevStep);
ui.btnNext.addEventListener("click", nextStep);
/* =====================================================
   BLOC 3 ‚Äî DESSINS & SYNCHRO
===================================================== */

const topCanvas = document.getElementById("topView");
const sideCanvas = document.getElementById("sideView");
const topCtx = topCanvas.getContext("2d");
const sideCtx = sideCanvas.getContext("2d");

// ===== CONTEXTES ZONE TEST =====


function resizeCanvas(canvas, ctx){
  const dpr = window.devicePixelRatio || 1;

  const parent = canvas.parentElement;
  const rect = parent.getBoundingClientRect();

  const w = Math.max(240, rect.width);
  const h = Math.max(240, rect.height);

  canvas.width  = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);

  ctx.setTransform(dpr,0,0,dpr,0,0);

  return { w, h };
}
/* =====================================================
   UTILITAIRES DESSIN
===================================================== */
function clear(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,w,h);
}

function drawDimOnly(ctx, x1, x2, y){
  ctx.beginPath();
  ctx.moveTo(x1, y);
  ctx.lineTo(x2, y);
  ctx.stroke();

  // petites barres aux extr√©mit√©s
  ctx.beginPath();
  ctx.moveTo(x1, y - 8);
  ctx.lineTo(x1, y + 8);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y - 8);
  ctx.lineTo(x2, y + 8);
  ctx.stroke();
}



function drawShimValue(ctx, x, y, value){
  if(value <= 0) return;

  ctx.fillStyle = "#ff5252";
  ctx.font = blinkPhase ? "bold 13px Arial" : "12px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`+${value.toFixed(2)} mil`, x + 14, y + 4);
}

function isBlinking(){
  return blinkPhase ? "#ff5252" : "#000";
}
function footColor(letter){
  const step = STEPS[state.step].id;
  const bad = !isStepOK(state.step);

  if(step === "softfoot" && currentView === "side"){
    return FOOT_NORMAL;
  }

  if(step === "softfoot"){
    const sf = computeSoftFoot();
    if(bad && sf.faulty && sf.faulty.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "angV"){
    const r = computeAngularVertical();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "parV" && bad){
    return isBlinking();
  }

  if(step === "angH"){
    const r = computeAngularHorizontal();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  return FOOT_NORMAL;
}
function drawFoot(ctx,x,y,label){
  ctx.fillStyle = footColor(label);
  ctx.fillRect(x-10,y-5,20,10);
  ctx.fillStyle="#fff";
  ctx.font="12px Arial";
  ctx.textAlign="center";
  ctx.fillText(label,x,y+18);
}

function drawArrow(ctx, x1, y1, x2, y2, color="#ff5252"){
  const head = 12;
  const angle = Math.atan2(y2-y1, x2-x1);

  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 3;

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(
    x2 - head * Math.cos(angle - Math.PI/6),
    y2 - head * Math.sin(angle - Math.PI/6)
  );
  ctx.lineTo(
    x2 - head * Math.cos(angle + Math.PI/6),
    y2 - head * Math.sin(angle + Math.PI/6)
  );
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawMathBlock(ctx, x, y, lines){
  ctx.save();
  ctx.font = "13px Consolas, monospace";
  ctx.fillStyle = "rgba(255,255,255,.95)";
  ctx.textAlign = "left";

  // petit fond discret
  const pad = 10;
  const lineH = 18;
  const boxW = 360;
  const boxH = pad*2 + lines.length*lineH;

  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.fillRect(x-pad, y-pad, boxW, boxH);

  ctx.fillStyle = "rgba(255,255,255,.95)";
  let dy = 0;
  for(const l of lines){
    ctx.fillText(l, x, y + dy);
    dy += lineH;
  }

  ctx.restore();
}


function drawDimLine(ctx, x1, x2, y, label){
  const left = Math.min(x1, x2);
  const right = Math.max(x1, x2);

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.fillStyle   = "rgba(255,255,255,.90)";
  ctx.lineWidth = 2;

  // ligne principale
  ctx.beginPath();
  ctx.moveTo(left, y);
  ctx.lineTo(right, y);
  ctx.stroke();

  // "ticks" aux extr√©mit√©s
  ctx.beginPath();
  ctx.moveTo(left, y-8);  ctx.lineTo(left, y+8);
  ctx.moveTo(right, y-8); ctx.lineTo(right, y+8);
  ctx.stroke();

  // texte centr√©
  ctx.font = "12px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText(label, (left + right)/2, y - 10);

  ctx.restore();
}




function drawCouplingDiameter(ctx, cx, cy, diam){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.lineWidth = 2;

  // petit cercle indicatif (pas √† l'√©chelle)
  ctx.beginPath();
  ctx.arc(cx, cy, 18, 0, Math.PI*2);
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,.90)";
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  ctx.fillText(`√ò = ${diam} po`, cx + 24, cy);

  ctx.restore();
}

function blinkColor(col){
  const t = Math.floor(Date.now() / 350) % 2;
  return t ? "#ff5252" : col;
}

function drawTopViewGeneric(ctxTarget){

  currentView = "top";

  const canvas = ctxTarget.canvas;
const {w,h} = resizeCanvas(canvas, ctxTarget);
const ctx = ctxTarget;
  clear(ctx,w,h);

  const scale = trainingMode ? visualGain * 0.08 : visualGain;
  const rotGain = visualGain * 0.00035;
  // ====================================================
//   MODE TRAINING ‚Äî SURCHARGE DES VALEURS M√âCANIQUES
// ====================================================
let parH = state.parH;
let angH = state.angH;
let parV = state.parV;
let angV = state.angV;

if(trainingMode){
  if(trainType === "parH") parH = trainValue;
  if(trainType === "angH") angH = trainValue;
  if(trainType === "parV") parV = trainValue;
  if(trainType === "angV") angV = trainValue;
}

  // ====================================================
  //   R√âF√âRENCES FIXES (POMPE + SOCLE)
  // ====================================================
  const baseCy = h * 0.5;
  const baseCx = w * 0.30;

  // ====================================================
//   MOTEUR MOBILE ‚Äî PARALL√âLISME HORIZONTAL (D√âPLACEMENT EN X)
// ====================================================
// ====================================================
//   MOTEUR MOBILE ‚Äî TOUJOURS DESSIN√â
// ====================================================
const maxShift = 60;
const shift = Math.max(-maxShift, Math.min(maxShift, parH * scale));

const motorCx = baseCx;

// üîë PATCH : on applique le shift UNIQUEMENT en parH,
// mais le moteur est TOUJOURS dessin√©
const motorCy =
  (trainingMode && trainType === "parH") ||
  (!trainingMode && STEPS[state.step].id === "parH")
    ? baseCy + shift
    : baseCy;
  const { motorW, motorH, pumpW, pumpH, gap, shaftH, coupW, coupH } = GEOM;
  // ====================================================
//   PATTES √Ä POUSSER ‚Äî PARALL√âLISME HORIZONTAL
// ====================================================
let flashFeet = [];

if(STEPS[state.step].id === "parH"){
  if(state.parH > 0) flashFeet = ["C","D"];
  if(state.parH < 0) flashFeet = ["A","B"];
}

  const footW = 24;
  const footH = 12;

  // ====================================================
  //   SEMELLE COMMUNE (FIXE ‚Äì R√âF√âRENCE)
  // ====================================================
  const baseMargin = 40;

  ctx.fillStyle = "#1a235a";
  ctx.fillRect(
    baseCx - motorW/2 - baseMargin,
    baseCy - motorH/2 - baseMargin,
    motorW + gap + pumpW + baseMargin*2,
    motorH + baseMargin*2
  );

  // ====================================================
  //   PARAM√àTRE ANGULAIRE (ANGULARIT√â HORIZONTALE)
  // ====================================================
  const ang =
  (trainingMode && trainType === "angH") ||
  (!trainingMode && STEPS[state.step].id === "angH")
    ? angH * dialSign * rotGain
    : 0;
    // ====================================================
//   FALLBACK : vue neutre si aucune √©tape active
// ====================================================
if(
  !["parH","angH"].includes(STEPS[state.step].id) &&
  !trainingMode
){
  // on force une vue neutre lisible
  // (le moteur reste visible, sans d√©placement)
}
  // ====================================================
  //   COORDONN√âES DES PATTES (EN POSITION MOTEUR)
  //   IMPORTANT: utiliser motorCx / motorCy (pas baseCy)
  // ====================================================
  const P = {
    A:{x: motorCx - motorW/2 + 24, y: motorCy - motorH/2 + 18},
    B:{x: motorCx + motorW/2 - 24, y: motorCy - motorH/2 + 18},
    D:{x: motorCx - motorW/2 + 24, y: motorCy + motorH/2 - 18},
    C:{x: motorCx + motorW/2 - 24, y: motorCy + motorH/2 - 18},
  };
// ‚úÖ PATCH ‚Äî appliquer l‚Äôorientation des pattes
// ‚úÖ PATCH STABLE ‚Äî mapping via FOOT_SCHEMES (soft-foot)
const scheme = FOOT_SCHEMES[footSchemeKey];

const PM = {
  A: P[scheme.TL],
  B: P[scheme.TR],
  C: P[scheme.BR],
  D: P[scheme.BL],
};

if(!PM.A || !PM.B || !PM.C || !PM.D){
  console.warn("PM invalide ‚Äî fallback standard");
  PM.A = P.A; PM.B = P.B; PM.C = P.C; PM.D = P.D;
}
  // ====================================================
  //   PIVOT M√âCANIQUE (OPTIONNEL)
  //   - ang > 0  => pivot coin ext√©rieur C
  //   - ang < 0  => pivot coin ext√©rieur D
  //   - ang = 0  => pivot centre
  // ====================================================
  let pivot = {x: motorCx, y: motorCy};
if(ang > 0) pivot = PM.C;
if(ang < 0) pivot = PM.D;
  // ====================================================
  //   BLOC MOTEUR (MOBILE) : MOTEUR + ARBRE + ¬Ω ACCOUPLEMENT + AXE
  // ====================================================
  ctx.save();
  ctx.translate(pivot.x, pivot.y);
  ctx.rotate(ang);
  ctx.translate(-pivot.x, -pivot.y);

  // ---- moteur ----
  ctx.fillStyle = "#00a2ff";
  ctx.fillRect(motorCx - motorW/2, motorCy - motorH/2, motorW, motorH);

  function drawPad(letter){
  const {x,y} = PM[letter];
  let col = footColor(letter);
  if(flashFeet.includes(letter)){
    if(typeof blinkColor === "function"){
      col = blinkColor(col);
    }
  }
  ctx.fillStyle = col;
  ctx.fillRect(x - footW/2, y - footH/2, footW, footH);
}
  drawPad("A"); drawPad("B"); drawPad("C"); drawPad("D");

  // ---- arbre moteur ----
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    motorCx + motorW/2,
    motorCy - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // ---- demi-accouplement moteur ----
  const coupX = motorCx + motorW/2 + gap/2;
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(coupX - 14, motorCy - coupH/2, coupW, coupH);

  // ---- AXE MOTEUR (AU PREMIER PLAN, DANS LE BLOC ROTATIF) ----
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.setLineDash([5,4]);
  ctx.lineWidth = 2.5;

  ctx.beginPath();
  ctx.moveTo(motorCx - motorW/2 - 90, motorCy);
  ctx.lineTo(motorCx + motorW/2 + gap/2, motorCy);
  ctx.stroke();
  ctx.restore();

  ctx.restore(); // FIN BLOC ROTATIF MOTEUR
// ====================================================
//   ANGULARIT√â HORIZONTALE ‚Äî FL√àCHES + CALCUL EXPLICITE
//   (AU PREMIER PLAN)
// ====================================================
// ====================================================
//   ANGULARIT√â HORIZONTALE ‚Äî FL√àCHES = POUSSER (SENS R√âEL)
// ====================================================
if(STEPS[state.step].id === "angH"){

  const v = state.angH * dialSign;
  const len = 60;

  // POSITIF ‚Üí moteur inclin√© DROITE ‚Üí pousser A + C
  if(v > 0){

    // A ‚Üí pousser vers le BAS
    drawArrow(ctx,
      PM.A.x, PM.A.y - len,
      PM.A.x, PM.A.y
    );

    // C ‚Üí pousser vers le HAUT
    drawArrow(ctx,
      PM.C.x,PM.C.y + len,
      PM.C.x, PM.C.y
    );
  }

  // N√âGATIF ‚Üí moteur inclin√© GAUCHE ‚Üí pousser B + D
  if(v < 0){

    // B ‚Üí pousser vers le BAS
    drawArrow(ctx,
      PM.B.x, PM.B.y - len,
      PM.B.x, PM.B.y
    );

    // D ‚Üí pousser vers le HAUT
    drawArrow(ctx,
      PM.D.x, PM.D.y + len,
      PM.D.x, PM.D.y
    );
  }
}
  // ====================================================
  //   BLOC POMPE (FIXE) : POMPE + ARBRE + ¬Ω ACCOUPLEMENT + AXE
  // ====================================================
  const pumpX = baseCx + motorW/2 + gap;

  // ---- pompe ----
  ctx.fillStyle="#ff9800";
  ctx.fillRect(pumpX, baseCy - pumpH/2, pumpW, pumpH);

  // ---- arbre pompe ----
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    baseCx + motorW/2 + gap/2 + 14,
    baseCy - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // ---- demi-accouplement pompe ----
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(
    baseCx + motorW/2 + gap/2 + 4,
    baseCy - coupH/2,
    coupW,
    coupH
  );

  // ---- AXE POMPE (FIXE) ----
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.setLineDash([5,4]);
  ctx.lineWidth = 2.5;

  ctx.beginPath();
  ctx.moveTo(baseCx + motorW/2 + gap/2, baseCy);
  ctx.lineTo(baseCx + motorW/2 + gap + pumpW + 90, baseCy);
  ctx.stroke();
  ctx.restore();

  // ====================================================
  //   LETTRES (UTILISER LES COORDONN√âES MOTEUR P)
  // ====================================================
  ctx.fillStyle = "#fff";
  ctx.font = "14px Arial";
  ctx.textAlign = "center";

  const labelOffset = 26;
  ctx.fillText(labelFoot("A"), PM.A.x, PM.A.y - labelOffset);
ctx.fillText(labelFoot("B"), PM.B.x, PM.B.y - labelOffset);
ctx.fillText(labelFoot("D"), PM.D.x, PM.D.y + labelOffset + 6);
ctx.fillText(labelFoot("C"), PM.C.x, PM.C.y + labelOffset + 6);
  // ====================================================
  //   TITRES
  // ====================================================
  ctx.fillText("MOTEUR (mobile)", motorCx, motorCy - motorH/2 - 18);
  ctx.fillText("POMPE (fixe)", pumpX + pumpW/2, baseCy - pumpH/2 - 18);
}




function drawSideViewGeneric(ctxTarget){

  currentView = "side";

  const canvas = ctxTarget.canvas;
const {w,h} = resizeCanvas(canvas, ctxTarget);
const ctx = ctxTarget;
  clear(ctx,w,h);

  const scale = trainingMode ? visualGain * 0.08 : visualGain;
  const rotGain = visualGain * 0.00035;
  // ====================================================
//   MODE TRAINING ‚Äî SURCHARGE DES VALEURS M√âCANIQUES
// ====================================================
let parV = state.parV;
let angV = state.angV;

if(trainingMode){
  if(trainType === "parV") parV = trainValue;
  if(trainType === "angV") angV = trainValue;
}

  let baseCy = h * 0.55;
  let baseCx = w * 0.30;

  let cy = baseCy + (
  (trainingMode && trainType === "parV") ||
  (!trainingMode && STEPS[state.step].id === "parV")
    ? parV * scale
    : 0
);
  let cx = baseCx;

  const axisPumpY  = baseCy;   // axe pompe = FIXE
  const axisMotorY = cy;       // axe moteur = MOBILE

  const { motorW, motorH, pumpW, pumpH, gap, shaftH, coupW, coupH } = GEOM;

  const footW = 24;
  const footH = 10;

  const rearFootX  = cx - motorW/2 + footW/2;
  const frontFootX = cx + motorW/2 - footW/2;

  // ====================================================
  //   SEMELLE COMMUNE
  // ====================================================
  const baseMargin = 40;
  const baseTop = baseCy + pumpH/2 + footH - 2;

  ctx.fillStyle = "#1a235a";
  ctx.fillRect(
    cx - motorW/2 - baseMargin,
    baseTop,
    motorW + gap + pumpW + baseMargin*2,
    16
  );

  // ====================================================
  //   PARAM√àTRE ANGULAIRE
  // ====================================================
  const ang =
  (trainingMode && trainType === "angV") ||
  (!trainingMode && STEPS[state.step].id === "angV")
    ? -angV * dialSign * rotGain
    : 0;
  // ====================================================
  //   POMPE FIXE + ARBRE + ¬Ω ACCOUPLEMENT
  // ====================================================
  const pumpX = cx + motorW/2 + gap;
  const coupX = cx + motorW/2 + gap/2;

  // pompe
  ctx.fillStyle = "#ff9800";
  ctx.fillRect(pumpX, baseCy - pumpH/2, pumpW, pumpH);

  // pattes pompe
  ctx.fillRect(pumpX + 12, baseCy + pumpH/2 - 2, footW, footH);
  ctx.fillRect(pumpX + pumpW - 12 - footW, baseCy + pumpH/2 - 2, footW, footH);

  // arbre pompe
  ctx.fillStyle = "#bbbbbb";
  ctx.fillRect(
    coupX + 14,
    axisPumpY - shaftH/2,
    (gap/2) - 8,
    shaftH
  );

  // demi-accouplement pompe
  ctx.fillStyle = "#cfcfcf";
  ctx.fillRect(
    coupX + 4,
    axisPumpY - coupH/2,
    coupW,
    coupH
  );

// ====================================================
//   MOTEUR + ARBRE + ¬Ω ACCOUPLEMENT + AXE
//   BLOC SOLIDAIRE ‚Äî PIVOT M√âCANIQUE R√âALISTE
// ====================================================

// pivots m√©caniques r√©els
const pivotDX = rearFootX;
const pivotCX = frontFootX;
const pivotY  = cy + motorH/2;

// choix automatique du pied porteur
const pivotX = (ang >= 0) ? pivotCX : pivotDX;

ctx.save();
ctx.translate(pivotX, pivotY);
ctx.rotate(ang);
ctx.translate(-pivotX, -pivotY);

// ---- MOTEUR ----
ctx.fillStyle = "#00a2ff";
ctx.fillRect(cx - motorW/2, cy - motorH/2, motorW, motorH);

// pattes moteur
ctx.fillRect(rearFootX - footW/2,  cy + motorH/2 - 2, footW, footH);
ctx.fillRect(frontFootX - footW/2, cy + motorH/2 - 2, footW, footH);

// lettres
ctx.fillStyle = "#fff";
ctx.font = "14px Arial";
ctx.textAlign = "center";
ctx.fillText("D", rearFootX,  cy + motorH/2 + 24);
ctx.fillText("C", frontFootX, cy + motorH/2 + 24);

// ---- ARBRE MOTEUR ----
ctx.fillStyle = "#bbbbbb";
ctx.fillRect(
  cx + motorW/2,
  cy - shaftH/2,
  (gap/2) - 8,
  shaftH
);

// ---- DEMI-ACCOUPLEMENT MOTEUR ----
ctx.fillStyle = "#cfcfcf";
ctx.fillRect(
  cx + motorW/2 + gap/2 - 14,
  cy - coupH/2,
  coupW,
  coupH
);

// ---- AXE MOTEUR (DERNIER = PREMIER PLAN) ----
ctx.save();
ctx.strokeStyle = "rgba(255,255,255,0.95)";
ctx.setLineDash([5,4]);
ctx.lineWidth = 2.5;

ctx.beginPath();
ctx.moveTo(cx - motorW/2 - 90, cy);
ctx.lineTo(cx + motorW/2 + gap/2, cy);
ctx.stroke();
ctx.restore();

ctx.restore();
  // ---- AXE POMPE (FIXE) ----
ctx.save();
ctx.strokeStyle = "rgba(255,255,255,0.95)";
ctx.setLineDash([5,6]);
ctx.lineWidth = 2;
ctx.shadowColor = "rgba(255,255,255,0.6)";
ctx.shadowBlur = 3;

ctx.beginPath();
ctx.moveTo(cx + motorW/2 + gap/2, axisPumpY);
ctx.lineTo(cx + motorW/2 + gap + pumpW + 100, axisPumpY);
ctx.stroke();
ctx.restore();
  // ====================================================
  //   TITRES
  // ====================================================
  ctx.fillStyle="#fff";
  ctx.font="14px Arial";
  ctx.textAlign="center";
  ctx.fillText("MOTEUR (mobile)", cx, cy - motorH/2 - 14);
  ctx.fillText("POMPE (fixe)", pumpX + pumpW/2, baseCy - pumpH/2 - 14);




  // ===============================
  //   MESURES G√âOM√âTRIQUES
  // ===============================
  if(STEPS[state.step].id === "measures"){

    const sub = state.measureStep;
    const color = ["#00a2ff","#4caf50","#ff9800"][sub];

    ctx.strokeStyle = color;
    ctx.lineWidth = 3;

    // 0 ‚Üí √ò ACCOUPLEMENT
    if(sub === 0){
      const r = 26;
      const x = baseCx + motorW/2 + gap/2;

      ctx.beginPath();
      ctx.moveTo(x, baseCy - r);
      ctx.lineTo(x, baseCy + r);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x - 8, baseCy - r);
      ctx.lineTo(x + 8, baseCy - r);
      ctx.moveTo(x - 8, baseCy + r);
      ctx.lineTo(x + 8, baseCy + r);
      ctx.stroke();
      return;
    }

    // 1 ‚Üí CENTRE ‚Üí PATTES AVANT
    if(sub === 1){
      const x1 = coupX;
      const x2 = frontFootX;
      const y  = cy + motorH/2 + 30;

      ctx.beginPath();
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x1, y - 8);
      ctx.lineTo(x1, y + 8);
      ctx.moveTo(x2, y - 8);
      ctx.lineTo(x2, y + 8);
      ctx.stroke();
      return;
    }

    // 2 ‚Üí AVANT ‚Üí ARRI√àRE
    if(sub === 2){
      const x1 = rearFootX;
      const x2 = frontFootX;
      const y  = cy + motorH/2 + 52;

      ctx.beginPath();
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x1, y - 8);
      ctx.lineTo(x1, y + 8);
      ctx.moveTo(x2, y - 8);
      ctx.lineTo(x2, y + 8);
      ctx.stroke();
      return;
    }
  }
}



// ===== VUES TEST (ZONE P√âDAGOGIQUE) =====


// ===== WRAPPERS PRINCIPAUX =====
function drawTopView(){
  drawTopViewGeneric(topCtx);
}

function drawSideView(){
  drawSideViewGeneric(sideCtx);
}
function renderAll(){
  refreshUI();
  drawTopView();
  drawSideView();
}
window.addEventListener("load", () => {

  // ===== ORIENTATION =====
  const layoutSelect = document.getElementById("footLayout");
  if(layoutSelect){
    layoutSelect.value = footLayout;

    layoutSelect.addEventListener("change", () => {
      footLayout = layoutSelect.value;
      renderAll();
    });
  }

  // ===== ‚ÑπÔ∏è AIDE / FORMULES =====
  const btnHelp = document.getElementById("btnHelp");
  const btnHelpClose = document.getElementById("btnHelpClose");
  const btnHelpPrint = document.getElementById("btnHelpPrint");
  const helpBackdrop = document.getElementById("helpBackdrop");

  if(btnHelp) btnHelp.addEventListener("click", openHelp);
  if(btnHelpClose) btnHelpClose.addEventListener("click", closeHelp);
  if(btnHelpPrint) btnHelpPrint.addEventListener("click", printHelp);
  if(helpBackdrop) helpBackdrop.addEventListener("click", closeHelp);

  document.addEventListener("keydown", (e) => {
    if(e.key === "Escape"){
      closeHelp();
      closeTraining();
    }
  });

  // ===== üéì TRAINING =====
  const btnTraining = document.getElementById("btnTraining");
  const btnTrainingClose = document.getElementById("btnTrainingClose");
  const trainingBackdrop = document.getElementById("trainingBackdrop");

  if(btnTraining) btnTraining.addEventListener("click", openTraining);
  if(btnTrainingClose) btnTrainingClose.addEventListener("click", closeTraining);
  if(trainingBackdrop) trainingBackdrop.addEventListener("click", closeTraining);


  

  renderAll();
});


</script>
</body>
</html>