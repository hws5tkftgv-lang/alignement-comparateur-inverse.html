<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement ‚Äì Comparateur invers√© (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.72);
  --ok:#4caf50;
  --bad:#ff5252;
  --accent:#00a2ff;
  --warn:#ffcc00;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{ margin:0; background:var(--bg); color:var(--text); font-family:Arial,system-ui,sans-serif; }

header{
  padding:14px 14px 10px;
  font-size:18px;
  font-weight:800;
  text-align:center;
}

.wrap{ padding:0 12px 18px; max-width:820px; margin:0 auto; }

.card{
  background:var(--card);
  border-radius:14px;
  padding:14px;
  margin:10px 0;
}

h2{ margin:0 0 10px; font-size:16px; }
p{ margin:6px 0 10px; font-size:13px; color:var(--muted); line-height:1.35; }

.row{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}
@media (max-width:520px){
  .row{ grid-template-columns:1fr; }
}

label{ font-size:12px; color:var(--muted); display:block; }
input[type="number"]{
  width:100%;
  padding:10px;
  font-size:16px;
  border:none;
  border-radius:12px;
  margin-top:6px;
}
input[type="range"]{ width:100%; }
.small{ font-size:12px; color:var(--muted); margin-top:8px; }

.btnRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
button{
  flex:1;
  min-width:140px;
  padding:12px;
  font-size:16px;
  border:none;
  border-radius:12px;
  background:var(--accent);
  color:#fff;
  font-weight:800;
}

.badTxt{ color:var(--bad); font-weight:800; }
.okTxt{ color:var(--ok); font-weight:800; }
.warnTxt{ color:var(--warn); font-weight:800; }

.status{
  margin-top:8px;
  font-size:13px;
  line-height:1.35;
}

.canvasBox{
  background:#05080f;
  border-radius:14px;
  overflow:hidden;
}

canvas{
  width:100%;
  height:260px;
  display:block;
  background:#05080f;
  touch-action:none;
}
#sideView{ height:220px; }

.kpi{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
  margin-top:10px;
}
.kpi .pill{
  background:rgba(255,255,255,0.08);
  border-radius:12px;
  padding:10px;
  font-size:13px;
  line-height:1.35;
}
.kpi b{ color:#cfe2ff; }

hr.sep{
  border:none;
  height:1px;
  background:rgba(255,255,255,0.12);
  margin:12px 0;
}
</style>
</head>

<body>
<header>Alignement ‚Äì Comparateur invers√© (mils) ‚Ä¢ iPhone-first</header>

<div class="wrap">

  <!-- 0) Param√®tres visuels -->
  <div class="card">
    <h2>üéõÔ∏è Param√®tres (p√©dagogiques)</h2>
    <div class="row">
      <div>
        <label>Exag√©ration visuelle (√ó) ‚Äî pour voir les mils √† l‚Äô≈ìil</label>
        <input id="gain" type="range" min="20" max="200" value="80">
        <div class="small">Plus grand = d√©placements plus visibles sur le dessin.</div>
      </div>
      <div>
        <label>Tol√©rance pied boiteux (mils)</label>
        <input id="softTol" type="number" inputmode="decimal" value="3">
        <div class="small">R√©f√©rence p√©dagogique (ex.: 2 √† 3 mils selon pratiques).</div>
      </div>
    </div>

    <div class="btnRow">
      <button id="resetBtn" type="button">Reset (tout remettre √† 0)</button>
    </div>
  </div>

  <!-- 1) Pied boiteux -->
  <div class="card">
    <h2>1Ô∏è‚É£ Pied boiteux (4 pattes) ‚Äî entr√©es directes</h2>
    <p>
      Entre la valeur (mils) mesur√©e √† chaque patte du <b>moteur</b> (ex.: variation max-min au comparateur).
      L‚Äôoutil affiche <b>rouge</b> si hors tol√©rance, mais <b>n‚Äôemp√™che pas</b> de continuer.
    </p>

    <div class="row">
      <div><label>Patte AV-G (mils)</label><input id="sf_fl" type="number" inputmode="decimal" value="0"></div>
      <div><label>Patte AV-D (mils)</label><input id="sf_fr" type="number" inputmode="decimal" value="0"></div>
      <div><label>Patte AR-G (mils)</label><input id="sf_rl" type="number" inputmode="decimal" value="0"></div>
      <div><label>Patte AR-D (mils)</label><input id="sf_rr" type="number" inputmode="decimal" value="0"></div>
    </div>

    <div class="status" id="softStatus"></div>
  </div>

  <!-- 2) Corrections live -->
  <div class="card">
    <h2>2Ô∏è‚É£ Corrections (live) ‚Äî moteur mobile / pompe fixe</h2>
    <p>
      Tu ajustes ces valeurs comme si tu appliquais des corrections. Le dessin exag√®re pour √™tre visible.
      <b>Offset</b> = parall√©lisme. <b>Angularit√©</b> = diff√©rence AV/AR (shim ou d√©placement lat√©ral AV/AR).
    </p>

    <div class="row">
      <div>
        <label>Parall√©lisme vertical (Offset Y) ‚Äî mils</label>
        <input id="offY" type="range" min="-20" max="20" value="0">
        <div class="small"><span id="offYv">0</span> mils</div>
      </div>
      <div>
        <label>Parall√©lisme horizontal (Offset X) ‚Äî mils</label>
        <input id="offX" type="range" min="-20" max="20" value="0">
        <div class="small"><span id="offXv">0</span> mils</div>
      </div>

      <div>
        <label>Angularit√© verticale (shim AV vs AR) ‚Äî Œîmils</label>
        <input id="angV" type="range" min="-20" max="20" value="0">
        <div class="small"><span id="angVv">0</span> mils (AV ‚Üï / AR ‚Üï)</div>
      </div>
      <div>
        <label>Angularit√© horizontale (AV vs AR) ‚Äî Œîmils</label>
        <input id="angH" type="range" min="-20" max="20" value="0">
        <div class="small"><span id="angHv">0</span> mils (AV ‚Üî / AR ‚Üî)</div>
      </div>
    </div>

    <div class="kpi">
      <div class="pill">
        <b>Interpr√©tation (rappel)</b><br>
        Offset = m√™me valeur AV/AR.<br>
        Angularit√© = AV ‚â† AR.
      </div>
      <div class="pill">
        <b>Astuce</b><br>
        Mets gain √©lev√© (ex. 80‚Äì120) pour bien voir les variations.
      </div>
    </div>

    <div class="status" id="alignStatus"></div>
  </div>

  <!-- 3) Dessins -->
  <div class="card">
    <h2>üß≠ Vue du dessus (plan)</h2>
    <p>Grille plus voyante + arbres + accouplement. Pompe fixe (orange), moteur mobile (bleu).</p>
    <div class="canvasBox"><canvas id="topView"></canvas></div>

    <hr class="sep">

    <h2>üìê Vue de profil</h2>
    <p>Montre surtout l‚Äôeffet du vertical (offset + angularit√© verticale).</p>
    <div class="canvasBox"><canvas id="sideView"></canvas></div>
  </div>

</div>

<script>
(() => {
  "use strict";

  /* ========= DOM ========= */
  const gainEl   = document.getElementById("gain");
  const softTolEl= document.getElementById("softTol");

  const sf = {
    fl: document.getElementById("sf_fl"),
    fr: document.getElementById("sf_fr"),
    rl: document.getElementById("sf_rl"),
    rr: document.getElementById("sf_rr"),
  };

  const offXEl = document.getElementById("offX");
  const offYEl = document.getElementById("offY");
  const angVEl = document.getElementById("angV");
  const angHEl = document.getElementById("angH");

  const offXv = document.getElementById("offXv");
  const offYv = document.getElementById("offYv");
  const angVv = document.getElementById("angVv");
  const angHv = document.getElementById("angHv");

  const softStatus = document.getElementById("softStatus");
  const alignStatus = document.getElementById("alignStatus");

  const resetBtn = document.getElementById("resetBtn");

  const topCanvas  = document.getElementById("topView");
  const sideCanvas = document.getElementById("sideView");
  const topCtx  = topCanvas.getContext("2d");
  const sideCtx = sideCanvas.getContext("2d");

  const dprNow = () => Math.min(3, window.devicePixelRatio || 1);
  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));

  function toNum(el){
    const v = parseFloat(el.value);
    return Number.isFinite(v) ? v : 0;
  }

  /* ========= Mod√®le =========
     On dessine un ensemble pompe (fixe) + moteur (mobile).
     Les "mils" deviennent des pixels via gain.
  */
  const model = {
    // offsets
    offX: 0, // mils
    offY: 0, // mils
    angV: 0, // mils (diff AV/AR sur Y)
    angH: 0, // mils (diff AV/AR sur X)
    gain: 80, // px per mil (exag√©ration)
  };

  /* ========= Canvas resize ========= */
  function resizeCanvas(canvas, ctx){
    const dpr = dprNow();
    const cssW = canvas.clientWidth || 1;
    const cssH = canvas.clientHeight || 1;
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function resizeAll(){
    resizeCanvas(topCanvas, topCtx);
    resizeCanvas(sideCanvas, sideCtx);
    drawAll();
  }

  /* ========= Grille (plus voyante) ========= */
  function drawGrid(ctx, W, H){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#05080f";
    ctx.fillRect(0,0,W,H);

    // Grille principale
    const step = 20; // px
    ctx.lineWidth = 1;

    // lignes fines
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    for(let x=0; x<=W; x+=step){
      ctx.beginPath();
      ctx.moveTo(x,0); ctx.lineTo(x,H);
      ctx.stroke();
    }
    for(let y=0; y<=H; y+=step){
      ctx.beginPath();
      ctx.moveTo(0,y); ctx.lineTo(W,y);
      ctx.stroke();
    }

    // lignes fortes (toutes les 5)
    ctx.strokeStyle = "rgba(0,162,255,0.28)";
    ctx.lineWidth = 1.4;
    for(let x=0; x<=W; x+=step*5){
      ctx.beginPath();
      ctx.moveTo(x,0); ctx.lineTo(x,H);
      ctx.stroke();
    }
    for(let y=0; y<=H; y+=step*5){
      ctx.beginPath();
      ctx.moveTo(0,y); ctx.lineTo(W,y);
      ctx.stroke();
    }

    // axes centre
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 1.8;
    ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke();
  }

  /* ========= Dessin des machines (style sch√©ma) ========= */
  function drawMachineTop(ctx, x, y, w, h, color, label){
    // corps
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.92;
    ctx.fillRect(x, y, w, h);
    ctx.globalAlpha = 1;

    // contour
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, w, h);

    // pattes (4)
    const footW = 18;
    const footH = 10;
    const pad = 10;

    ctx.fillStyle = "rgba(255,255,255,0.22)";
    // avant (g/d)
    ctx.fillRect(x+pad,     y+h, footW, footH);
    ctx.fillRect(x+w-pad-footW, y+h, footW, footH);
    // arri√®re (g/d)
    ctx.fillRect(x+pad,     y-footH, footW, footH);
    ctx.fillRect(x+w-pad-footW, y-footH, footW, footH);

    // label
    ctx.fillStyle = "#eaf1ff";
    ctx.font = "12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillText(label, x+w/2, y-12);
  }

  function drawMachineSide(ctx, x, y, w, h, color, label){
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.92;
    ctx.fillRect(x, y, w, h);
    ctx.globalAlpha = 1;

    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, w, h);

    // base
    ctx.fillStyle = "rgba(255,255,255,0.14)";
    ctx.fillRect(x, y+h, w, 8);

    ctx.fillStyle = "#eaf1ff";
    ctx.font = "12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillText(label, x+w/2, y-10);
  }

  /* ========= Arbres + accouplement ========= */
  function drawShaftAndCouplingTop(ctx, pumpCX, pumpCY, motorCX, motorCY, coupX){
    // ligne d‚Äôaxe pompe
    ctx.strokeStyle = "rgba(255,152,0,0.90)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(pumpCX-120, pumpCY);
    ctx.lineTo(coupX, pumpCY);
    ctx.stroke();

    // ligne d‚Äôaxe moteur
    ctx.strokeStyle = "rgba(0,162,255,0.95)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(motorCX+120, motorCY);
    ctx.lineTo(coupX, motorCY);
    ctx.stroke();

    // accouplement (2 demi)
    const r = 14;
    ctx.fillStyle = "rgba(255,152,0,0.95)";
    ctx.beginPath(); ctx.arc(coupX-10, pumpCY, r, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(0,162,255,0.95)";
    ctx.beginPath(); ctx.arc(coupX+10, motorCY, r, 0, Math.PI*2); ctx.fill();

    // jeu au centre
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(coupX, Math.min(pumpCY, motorCY)-18);
    ctx.lineTo(coupX, Math.max(pumpCY, motorCY)+18);
    ctx.stroke();

    // annotation d√©calage
    const dy = motorCY - pumpCY;
    const dx = (motorCX - pumpCX);

    ctx.fillStyle = "rgba(255,255,255,0.90)";
    ctx.font = "12px Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(`ŒîY (visuel) = ${dy.toFixed(0)} px`, 12, 12);
    ctx.fillText(`ŒîX (visuel) = ${dx.toFixed(0)} px`, 12, 28);
  }

  function drawShaftAndCouplingSide(ctx, pumpCY, motorCY, coupX){
    // axe pompe
    ctx.strokeStyle = "rgba(255,152,0,0.90)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(coupX-170, pumpCY);
    ctx.lineTo(coupX, pumpCY);
    ctx.stroke();

    // axe moteur
    ctx.strokeStyle = "rgba(0,162,255,0.95)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(coupX+170, motorCY);
    ctx.lineTo(coupX, motorCY);
    ctx.stroke();

    // accouplement (2 demi)
    const r = 12;
    ctx.fillStyle = "rgba(255,152,0,0.95)";
    ctx.beginPath(); ctx.arc(coupX-10, pumpCY, r, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(0,162,255,0.95)";
    ctx.beginPath(); ctx.arc(coupX+10, motorCY, r, 0, Math.PI*2); ctx.fill();

    // marqueur √©cart vertical
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(coupX, pumpCY);
    ctx.lineTo(coupX, motorCY);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.90)";
    ctx.font = "12px Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(`ŒîY profil (px) = ${(motorCY - pumpCY).toFixed(0)}`, 12, 12);
  }

  /* ========= Logique pied boiteux ========= */
  function evalSoftFoot(){
    const tol = Math.max(0, toNum(softTolEl));
    const v = {
      fl: Math.abs(toNum(sf.fl)),
      fr: Math.abs(toNum(sf.fr)),
      rl: Math.abs(toNum(sf.rl)),
      rr: Math.abs(toNum(sf.rr)),
    };

    const maxV = Math.max(v.fl, v.fr, v.rl, v.rr);

    if(maxV <= tol){
      softStatus.innerHTML =
        `<span class="okTxt">‚úî Pied boiteux OK</span> ‚Äî max = <b>${maxV.toFixed(2)}</b> mils (tol. ${tol.toFixed(2)})`;
      return { ok:true, max:maxV, tol };
    }else{
      // liste des pattes hors tol
      const out = [];
      if(v.fl > tol) out.push("AV-G");
      if(v.fr > tol) out.push("AV-D");
      if(v.rl > tol) out.push("AR-G");
      if(v.rr > tol) out.push("AR-D");

      softStatus.innerHTML =
        `<span class="badTxt">‚ùå Pied boiteux √Ä corriger</span> ‚Äî max = <b>${maxV.toFixed(2)}</b> mils (tol. ${tol.toFixed(2)})<br>
         <span class="small">Hors tol√©rance : <b>${out.join(", ")}</b> (p√©dagogique: shim/correction avant alignement)</span>`;
      return { ok:false, max:maxV, tol };
    }
  }

  /* ========= Interpr√©tation alignement (simple et utile) ========= */
  function evalAlignment(){
    // Ici on ne fait PAS la math de comparateurs (on viendra apr√®s).
    // On affiche simplement l‚Äô√©tat des 4 r√©glages (offset/ang) et un avertissement p√©dagogique.
    const offX = model.offX, offY = model.offY, angV = model.angV, angH = model.angH;

    const abs = (x)=>Math.abs(x);
    const warn = [];

    // seuils p√©dagogiques (tu pourras changer)
    const T_OFF = 2;  // mils
    const T_ANG = 2;  // mils

    if(abs(offY) > T_OFF) warn.push(`Parall√©lisme vertical √©lev√© (${offY.toFixed(1)} mils)`);
    if(abs(offX) > T_OFF) warn.push(`Parall√©lisme horizontal √©lev√© (${offX.toFixed(1)} mils)`);
    if(abs(angV) > T_ANG) warn.push(`Angularit√© verticale √©lev√©e (${angV.toFixed(1)} mils)`);
    if(abs(angH) > T_ANG) warn.push(`Angularit√© horizontale √©lev√©e (${angH.toFixed(1)} mils)`);

    if(warn.length === 0){
      alignStatus.innerHTML = `<span class="okTxt">‚úî Alignement visuel : bon</span> <span class="small">(p√©dagogique ‚Äî on ajoutera la logique comparateur ensuite)</span>`;
    }else{
      alignStatus.innerHTML =
        `<span class="badTxt">‚ö† Ajustements requis</span><br>
         <span class="small">‚Ä¢ ${warn.join("<br>‚Ä¢ ")}</span>`;
    }
  }

  /* ========= Mapping mils -> pixels ========= */
  function milsToPx(m){ return m * model.gain; }

  /* ========= Dessin TOP ========= */
  function drawTop(){
    const W = topCanvas.clientWidth;
    const H = topCanvas.clientHeight;

    drawGrid(topCtx, W, H);

    // zone / rep√®res
    const centerY = H/2;
    const pumpX = W*0.65;
    const motorX = W*0.20;

    const machineW = 150;
    const machineH = 70;

    // Pompe fixe : au centre
    const pumpY = centerY - machineH/2;

    // Moteur mobile : on applique offset + angularit√© H (effet AV/AR)
    // Pour la vue TOP : on simule que l‚ÄôAV et l‚ÄôAR n‚Äôont pas la m√™me position (angularit√©)
    // On dessine le moteur comme un bloc, mais on calcule la ligne d‚Äôaxe moteur avec un tilt simplifi√©.
    const offXpx = milsToPx(model.offX);
    const offYpx = milsToPx(model.offY);
    const angHpx = milsToPx(model.angH);

    // Position du bloc moteur (moyenne)
    const motorY = centerY - machineH/2 + offYpx;
    const motorBlockX = motorX + offXpx;

    // Centres d‚Äôaxes au niveau couplage
    const coupX = W/2;

    // Axe pompe (fixe)
    const pumpAxisY = centerY; // fixe

    // Axe moteur (variable) :
    // - OffY d√©place l‚Äôaxe
    // - AngH donne une diff√©rence AV/AR en X (p√©dagogique: inclinaison lat√©rale)
    // Dans TOP, on applique angH comme une "pente" proche du couplage.
    // Simplification: on d√©cale l‚Äôaxe moteur au couplage d‚Äôune fraction de angH.
    const motorAxisY = centerY + offYpx; // (top: angularit√© verticale se verra plut√¥t en profil)
    const motorAxisXCenter = motorBlockX + machineW/2;

    // Dessin machines
    drawMachineTop(topCtx, pumpX, pumpY, machineW, machineH, "#ff9800", "Pompe (fixe)");
    drawMachineTop(topCtx, motorBlockX, motorY, machineW, machineH, "#00a2ff", "Moteur (mobile)");

    // Arbres + accouplement (TOP)
    drawShaftAndCouplingTop(
      topCtx,
      pumpX + machineW/2, pumpAxisY,
      motorAxisXCenter + (angHpx*0.15), motorAxisY,
      coupX
    );

    // Marqueur de d√©placement moteur (point)
    topCtx.fillStyle = "rgba(255,255,255,0.9)";
    topCtx.beginPath();
    topCtx.arc(motorAxisXCenter, motorAxisY, 4, 0, Math.PI*2);
    topCtx.fill();

    // L√©gende mini
    topCtx.fillStyle = "rgba(255,255,255,0.85)";
    topCtx.font = "12px Arial";
    topCtx.textAlign = "right";
    topCtx.textBaseline = "top";
    topCtx.fillText("Vue dessus (plan)", W-10, 10);
  }

  /* ========= Dessin SIDE ========= */
  function drawSide(){
    const W = sideCanvas.clientWidth;
    const H = sideCanvas.clientHeight;

    drawGrid(sideCtx, W, H);

    const centerY = H/2;

    const machineW = 160;
    const machineH = 60;

    const pumpX = W*0.12;
    const motorX = W*0.62;

    // Pompe fixe
    const pumpY = centerY - machineH/2;

    // Moteur mobile : OFFY + ANGV (shim AV/AR)
    const offYpx = milsToPx(model.offY);
    const angVpx = milsToPx(model.angV);

    // Pour la vue profil, on fait une repr√©sentation claire :
    // - le bloc moteur bouge en moyenne (offY)
    // - le nez au couplage refl√®te une partie de l‚Äôangularit√© (angV)
    const motorY = centerY - machineH/2 + offYpx;

    // Centres d‚Äôaxes au couplage
    const coupX = W/2;

    const pumpAxisY = centerY;
    const motorAxisY = centerY + offYpx + (angVpx * 0.18);

    // Machines
    drawMachineSide(sideCtx, pumpX, pumpY, machineW, machineH, "#ff9800", "Pompe (fixe)");
    drawMachineSide(sideCtx, motorX, motorY, machineW, machineH, "#00a2ff", "Moteur (mobile)");

    // Arbres + accouplement (profil)
    drawShaftAndCouplingSide(sideCtx, pumpAxisY, motorAxisY, coupX);

    // Indication angularit√© verticale (p√©dagogique)
    sideCtx.fillStyle = "rgba(255,255,255,0.90)";
    sideCtx.font = "12px Arial";
    sideCtx.textAlign = "left";
    sideCtx.textBaseline = "bottom";
    sideCtx.fillText(`OffsetY=${model.offY.toFixed(1)} mils | AngV=${model.angV.toFixed(1)} mils`, 12, H-10);

    sideCtx.fillStyle = "rgba(255,255,255,0.85)";
    sideCtx.font = "12px Arial";
    sideCtx.textAlign = "right";
    sideCtx.textBaseline = "top";
    sideCtx.fillText("Vue profil", W-10, 10);
  }

  function drawAll(){
    // sync numbers
    model.gain = clamp(parseFloat(gainEl.value)||80, 20, 200);

    model.offX = parseFloat(offXEl.value) || 0;
    model.offY = parseFloat(offYEl.value) || 0;
    model.angV = parseFloat(angVEl.value) || 0;
    model.angH = parseFloat(angHEl.value) || 0;

    offXv.textContent = model.offX.toFixed(0);
    offYv.textContent = model.offY.toFixed(0);
    angVv.textContent = model.angV.toFixed(0);
    angHv.textContent = model.angH.toFixed(0);

    // statuses
    evalSoftFoot();
    evalAlignment();

    // draw
    drawTop();
    drawSide();
  }

  /* ========= Events ========= */
  const allInputs = [
    gainEl, softTolEl,
    sf.fl,sf.fr,sf.rl,sf.rr,
    offXEl, offYEl, angVEl, angHEl
  ];

  allInputs.forEach(el => el.addEventListener("input", drawAll));

  resetBtn.addEventListener("click", () => {
    gainEl.value = "80";
    softTolEl.value = "3";

    sf.fl.value = "0";
    sf.fr.value = "0";
    sf.rl.value = "0";
    sf.rr.value = "0";

    offXEl.value = "0";
    offYEl.value = "0";
    angVEl.value = "0";
    angHEl.value = "0";

    drawAll();
  });

  window.addEventListener("resize", resizeAll);
  if(window.visualViewport){
    window.visualViewport.addEventListener("resize", resizeAll);
  }

  /* ========= Init ========= */
  resizeAll();
})();
</script>

</body>
</html>