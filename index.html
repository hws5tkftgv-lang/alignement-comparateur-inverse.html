<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement – Comparateur inversé (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.75);
  --ok:#49d17a;
  --bad:#ff5252;
  --warn:#ffb300;
  --accent:#00a2ff;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{ margin:0; background:var(--bg); color:var(--text); font-family:Arial,system-ui,sans-serif; }

header{
  padding:14px 12px 8px;
  text-align:center;
  font-weight:900;
  font-size:18px;
  position:relative;
}
.sub{
  text-align:center;
  opacity:.85;
  font-size:12px;
  margin:0 12px 10px;
}
.wrap{ max-width:980px; margin:0 auto; padding:0 12px 18px; }

.grid{
  display:grid;
  gap:12px;
}
@media (min-width: 860px){
  .grid{ grid-template-columns: 1.05fr 0.95fr; align-items:start; }
}

.card{
  background:var(--card);
  border-radius:14px;
  padding:12px;
}

h2{ margin:0 0 8px; font-size:16px; }
p{ margin:6px 0 10px; color:var(--muted); font-size:13px; line-height:1.35; }

.step{
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:10px;
  background:rgba(255,255,255,.03);
  margin-top:10px;
}
.stepHead{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}
.stepTitle{ font-weight:900; font-size:14px; }
.badge{
  font-size:12px;
  font-weight:900;
  padding:4px 8px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
  color:var(--muted);
}
.badge.ok{ background:rgba(73,209,122,.16); color:#c9ffe0; }
.badge.bad{ background:rgba(255,82,82,.16); color:#ffd0d0; }
.badge.warn{ background:rgba(255,179,0,.16); color:#ffe6b0; }

.row{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
@media (max-width: 380px){ .row{ grid-template-columns:1fr; } }

label{ display:block; font-size:12px; color:var(--muted); margin:0 0 4px; }
input,select{
  width:100%;
  padding:10px;
  border:none;
  border-radius:12px;
  outline:none;
  font-size:16px;
}

.note{
  margin-top:8px;
  font-size:12px;
  color:var(--muted);
  line-height:1.35;
}

.hr{ height:1px; background:rgba(255,255,255,.10); margin:12px 0; }

.canvasGrid{ display:grid; gap:12px; }
@media (min-width: 860px){ .canvasGrid{ grid-template-columns:1fr 1fr; } }

.canvasCard{
  background:#000;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.canvasHeader{
  padding:10px 12px;
  font-size:13px;
  font-weight:900;
  background:rgba(0,0,0,.35);
  border-bottom:1px solid rgba(255,255,255,.10);
}
canvas{ width:100%; height:240px; display:block; background:#000; }
@media (min-width: 860px){ canvas{ height:280px; } }

.kpi{
  margin-top:10px;
  border-radius:14px;
  padding:10px;
  background:rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.10);
}
.kpi b{ color:#cfe2ff; }
.mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; white-space:pre-wrap; }

.btnRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
button{
  flex:1;
  min-width:140px;
  padding:12px;
  border:none;
  border-radius:12px;
  font-size:16px;
  font-weight:900;
  color:#fff;
  background:var(--accent);
}
button.secondary{ background:rgba(255,255,255,.14); }

.infoBtn{
  position:absolute;
  right:10px;
  top:50%;
  transform:translateY(-50%);
  font-size:20px;
  background:none;
  border:none;
  color:#eaf1ff;
}

.infoModal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.65);
  z-index:9999;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:16px;
}
.infoBox{
  width:min(92vw,560px);
  max-height:88vh;
  background:var(--card);
  border-radius:16px;
  padding:14px;
  display:flex;
  flex-direction:column;
}
.infoScroll{
  overflow:auto;
  margin-top:10px;
  font-size:13px;
  line-height:1.45;
  color:var(--muted);
}
.hidden{ display:none; }
details{
  border:1px solid rgba(255,255,255,.12);
  border-radius:10px;
  padding:8px 10px;
  margin-bottom:8px;
  background:rgba(255,255,255,.03);
}
summary{ cursor:pointer; font-weight:900; color:#cfe2ff; list-style:none; }
summary::-webkit-details-marker{ display:none; }
</style>
</head>

<body>
<header>
  Alignement – Comparateur inversé (mils)
  <button id="infoBtn" class="infoBtn" aria-label="Informations">ℹ️</button>
</header>
<div class="sub">
  2 vues (dessus + profil) • moteur mobile / pompe fixe • valeurs en <b>mils</b> • ordre: voilage → pied boiteux → angulaire V → parallèle V → angulaire H → parallèle H
</div>

<div class="wrap">
  <div class="grid">

    <!-- =================== PANNEAU GAUCHE =================== -->
    <div class="card">
      <h2>Étapes (débutant)</h2>
      <p>
        Rappel signe (simple) :
        <b>+</b> = le moteur <b>monte</b> (vertical) ou va <b>à droite</b> (horizontal).
        <b>−</b> = le moteur <b>descend</b> ou va <b>à gauche</b>.
      </p>

      <!-- 1 -->
      <div class="step">
        <div class="stepHead">
          <div class="stepTitle">1) Voilage (runout)</div>
          <div class="badge" id="b1">Info</div>
        </div>
        <p>On vérifie avant tout. Si le voilage est trop grand, les lectures d’alignement deviennent peu fiables.</p>
        <div class="row">
          <div>
            <label>Voilage max (mils)</label>
            <input id="runout" type="number" inputmode="decimal" step="0.1" value="0.8">
          </div>
          <div>
            <label>Tolérance (mils)</label>
            <input id="runoutTol" type="number" inputmode="decimal" step="0.1" value="2.0">
          </div>
        </div>
      </div>

      <!-- 2 -->
      <div class="step">
        <div class="stepHead">
          <div class="stepTitle">2) Pied boiteux (4 pattes)</div>
          <div class="badge" id="b2">Info</div>
        </div>
        <p>
          Ici tu entres <b>la valeur mesurée par patte</b> (différence MAX–MIN).
          L’appli retient la <b>pire patte</b> (ou celle que tu choisis).
        </p>

        <div class="row">
          <div>
            <label>Patte AV-G (FL) (mils)</label>
            <input id="sfFL" type="number" inputmode="decimal" step="0.1" value="2.0">
          </div>
          <div>
            <label>Patte AV-D (FR) (mils)</label>
            <input id="sfFR" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <div>
            <label>Patte AR-G (RL) (mils)</label>
            <input id="sfRL" type="number" inputmode="decimal" step="0.1" value="0.5">
          </div>
          <div>
            <label>Patte AR-D (RR) (mils)</label>
            <input id="sfRR" type="number" inputmode="decimal" step="0.1" value="3.5">
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <div>
            <label>Tolérance soft foot (mils)</label>
            <input id="sfTol" type="number" inputmode="decimal" step="0.1" value="3.0">
          </div>
          <div>
            <label>Quelle patte on montre ?</label>
            <select id="sfFoot">
              <option value="auto" selected>Auto (pire patte)</option>
              <option value="FL">FL (AV-G)</option>
              <option value="FR">FR (AV-D)</option>
              <option value="RL">RL (AR-G)</option>
              <option value="RR">RR (AR-D)</option>
            </select>
          </div>
        </div>

        <div class="note">
          Le dessin colore la patte « problème ». En vrai, on corrige avec des <b>cales (shims)</b> et on re-mesure.
        </div>
      </div>

      <!-- 3 -->
      <div class="step">
        <div class="stepHead">
          <div class="stepTitle">3) Angulaire verticale (profil)</div>
          <div class="badge" id="b3">Info</div>
        </div>
        <p>
          Angulaire = l’axe du moteur est <b>incliné</b> (comme une bascule).
          Le dessin de profil montre le moteur qui « penche ».
        </p>
        <div class="row">
          <div>
            <label>Angulaire V (mils)</label>
            <input id="angV" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tolérance (mils)</label>
            <input id="angVTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <!-- 4 -->
      <div class="step">
        <div class="stepHead">
          <div class="stepTitle">4) Parallèle verticale (profil)</div>
          <div class="badge" id="b4">Info</div>
        </div>
        <p>
          Parallèle = l’axe du moteur reste <b>droit</b>, mais il est <b>plus haut ou plus bas</b> que la pompe.
        </p>
        <div class="row">
          <div>
            <label>Parallèle V (mils)</label>
            <input id="parV" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tolérance (mils)</label>
            <input id="parVTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <!-- 5 -->
      <div class="step">
        <div class="stepHead">
          <div class="stepTitle">5) Angulaire horizontale (dessus)</div>
          <div class="badge" id="b5">Info</div>
        </div>
        <p>
          Angulaire horizontal = le moteur <b>pivote</b> vers la gauche/droite (vue de dessus).
        </p>
        <div class="row">
          <div>
            <label>Angulaire H (mils)</label>
            <input id="angH" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tolérance (mils)</label>
            <input id="angHTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <!-- 6 -->
      <div class="step">
        <div class="stepHead">
          <div class="stepTitle">6) Parallèle horizontale (dessus)</div>
          <div class="badge" id="b6">Info</div>
        </div>
        <p>
          Parallèle horizontal = le moteur se déplace <b>au complet</b> vers la gauche/droite (sans pivoter).
        </p>
        <div class="row">
          <div>
            <label>Parallèle H (mils)</label>
            <input id="parH" type="number" inputmode="decimal" step="0.1" value="0.0">
          </div>
          <div>
            <label>Tolérance (mils)</label>
            <input id="parHTol" type="number" inputmode="decimal" step="0.1" value="1.0">
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <h2>Affichage (pour voir les effets)</h2>
      <p>Le gain transforme les mils en pixels pour que l’élève voie la correction.</p>
      <div class="row">
        <div>
          <label>Gain visuel (px / mil)</label>
          <input id="gain" type="number" inputmode="decimal" step="1" value="25">
        </div>
        <div>
          <label>Réinitialiser</label>
          <button class="secondary" id="btnReset" type="button">Reset valeurs</button>
        </div>
      </div>

      <div class="kpi">
        <b>Résumé (simple)</b>
        <div class="mono" id="kpi">—</div>
      </div>

      <div class="note">
        Important : on corrige <b>l’angulaire avant le parallèle</b> (V puis H). La pompe reste fixe; on déplace le moteur.
      </div>
    </div>

    <!-- =================== CANVAS DROITE =================== -->
    <div class="card">
      <h2>Dessins (2 vues)</h2>
      <p>On laisse toujours un espace pour l’<b>accouplement</b> et on dessine les <b>arbres</b>.</p>

      <div class="canvasGrid">
        <div class="canvasCard">
          <div class="canvasHeader">Vue de dessus (horizontal) • 4 pattes</div>
          <canvas id="topView"></canvas>
        </div>
        <div class="canvasCard">
          <div class="canvasHeader">Vue de profil (vertical) • 2 pattes visibles</div>
          <canvas id="sideView"></canvas>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- =================== CALCULS =================== -->
<script>
/*
  PIED BOITEUX — version simple + stable
  Entrées: FL, FR, RL, RR (valeurs déjà en mils, ex: MAX–MIN)
  Sortie:
    - worstFoot: patte à montrer (auto) + valeur
    - pattesBadges: tableau des pattes "à colorer" (ici: seulement worstFoot)
*/
function calculPiedBoiteuxSimple(FL, FR, RL, RR){
  const feet = [
    { foot:"FL", val: Math.abs(FL) },
    { foot:"FR", val: Math.abs(FR) },
    { foot:"RL", val: Math.abs(RL) },
    { foot:"RR", val: Math.abs(RR) },
  ];
  feet.sort((a,b)=>b.val-a.val);
  return {
    worstFoot: feet[0],
    pattes: [feet[0].foot]
  };
}

/* Angulaire / Parallèle — ici on ne fait pas “la vraie géométrie laser” :
   on garde une version débutant: valeurs entrées = défaut à corriger.
   Le but de l’app est pédagogique + dessins cohérents.
*/
</script>

<script>
(() => {
  "use strict";

  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
  const isNum = (x)=>Number.isFinite(x);

  const el = (id)=>document.getElementById(id);

  // Inputs
  const runout    = el("runout");
  const runoutTol = el("runoutTol");

  const sfFL = el("sfFL");
  const sfFR = el("sfFR");
  const sfRL = el("sfRL");
  const sfRR = el("sfRR");
  const sfTol = el("sfTol");
  const sfFoot = el("sfFoot");

  const angV = el("angV");
  const angVTol = el("angVTol");

  const parV = el("parV");
  const parVTol = el("parVTol");

  const angH = el("angH");
  const angHTol = el("angHTol");

  const parH = el("parH");
  const parHTol = el("parHTol");

  const gain = el("gain");
  const btnReset = el("btnReset");

  // Badges
  const b1 = el("b1");
  const b2 = el("b2");
  const b3 = el("b3");
  const b4 = el("b4");
  const b5 = el("b5");
  const b6 = el("b6");

  const kpi = el("kpi");

  // Canvas
  const topCanvas = el("topView");
  const topCtx = topCanvas.getContext("2d");

  const sideCanvas = el("sideView");
  const sideCtx = sideCanvas.getContext("2d");

  // State (mils)
  const align = {
    runout:0.8, runoutTol:2.0,
    sf:{ FL:2.0, FR:1.0, RL:0.5, RR:3.5 }, sfTol:3.0, sfFoot:"auto",
    angV:0.0, angVTol:1.0,
    parV:0.0, parVTol:1.0,
    angH:0.0, angHTol:1.0,
    parH:0.0, parHTol:1.0,
    gain:25
  };

  function readFloat(inputEl, fallback){
    const v = parseFloat(inputEl.value);
    return isNum(v) ? v : fallback;
  }

  function syncFromInputs(){
    align.runout = readFloat(runout, align.runout);
    align.runoutTol = Math.max(0, readFloat(runoutTol, align.runoutTol));

    align.sf.FL = Math.abs(readFloat(sfFL, align.sf.FL));
    align.sf.FR = Math.abs(readFloat(sfFR, align.sf.FR));
    align.sf.RL = Math.abs(readFloat(sfRL, align.sf.RL));
    align.sf.RR = Math.abs(readFloat(sfRR, align.sf.RR));

    align.sfTol = Math.max(0, readFloat(sfTol, align.sfTol));
    align.sfFoot = (sfFoot.value || "auto");

    align.angV = readFloat(angV, align.angV);
    align.angVTol = Math.max(0, readFloat(angVTol, align.angVTol));

    align.parV = readFloat(parV, align.parV);
    align.parVTol = Math.max(0, readFloat(parVTol, align.parVTol));

    align.angH = readFloat(angH, align.angH);
    align.angHTol = Math.max(0, readFloat(angHTol, align.angHTol));

    align.parH = readFloat(parH, align.parH);
    align.parHTol = Math.max(0, readFloat(parHTol, align.parHTol));

    align.gain = clamp(readFloat(gain, align.gain), 1, 120);
  }

  function setBadge(badgeEl, kind, txt){
    badgeEl.classList.remove("ok","bad","warn");
    badgeEl.classList.add(kind);
    badgeEl.textContent = txt;
  }

  function getActiveSoftFoot(pb){
    if(align.sfFoot !== "auto"){
      return { foot: align.sfFoot, val: align.sf[align.sfFoot] ?? 0, pattes:[align.sfFoot] };
    }
    return { foot: pb.worstFoot.foot, val: pb.worstFoot.val, pattes: pb.pattes };
  }

  // ---------- Canvas helpers ----------
  function dprNow(){ return Math.min(3, window.devicePixelRatio || 1); }
  function resizeCanvas(c, ctx){
    const dpr = dprNow();
    const w = c.clientWidth || 320;
    const h = c.clientHeight || 240;
    c.width  = Math.round(w * dpr);
    c.height = Math.round(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return { W:w, H:h };
  }

  function clear(ctx, W, H){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);
  }

  function drawGrid(ctx, W, H){
    ctx.strokeStyle="rgba(255,255,255,.06)";
    ctx.lineWidth=1;
    const step=24;
    for(let x=0;x<=W;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  }

  function drawCoupling(ctx, x, y){
    // 2 demi-accouplements (simple)
    ctx.strokeStyle="rgba(255,255,255,.35)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(x-6,y,12,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(x+6,y,12,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(x-6,y,6,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(x+6,y,6,0,Math.PI*2); ctx.stroke();
  }

  function drawFoot(ctx, x, y, w, h, highlight=false){
    if(highlight){
      ctx.fillStyle = "rgba(255,82,82,.95)";
      ctx.fillRect(x,y,w,h);
      ctx.strokeStyle = "rgba(255,255,255,.85)";
      ctx.lineWidth = 2;
      ctx.strokeRect(x+1,y+1,w-2,h-2);
    } else {
      ctx.fillRect(x,y,w,h);
    }
  }

  // ---------- DRAW TOP VIEW (dessus) ----------
  function drawTopView(activeFoot){
    const { W, H } = resizeCanvas(topCanvas, topCtx);
    clear(topCtx, W, H);
    drawGrid(topCtx, W, H);

    // Géométrie (on laisse un vrai espace coupling + arbres)
    const midY  = H * 0.55;
    const baseX = 36;

    const unitLen = Math.min(170, (W - 120) * 0.44);
    const gap     = Math.min(110, (W - 120) * 0.22); // espace pour coupling + arbres

    const motorW = unitLen, motorH = 44;
    const pumpW  = unitLen, pumpH  = 44;

    const motorX0 = baseX;
    const motorY0 = midY;

    const pumpX = baseX + motorW + gap;
    const pumpY = midY;

    // transformations moteur (H)
    const g  = align.gain;
    const dx = align.parH * g;            // translation latérale
    const ang = align.angH * 0.0025;      // rotation (pédagogique)

    // zones pieds (dessus = 4 pattes)
    const fw=16, fh=8;

    // Pompe (fixe)
    topCtx.fillStyle="#ff9800";
    topCtx.fillRect(pumpX, pumpY - pumpH/2, pumpW, pumpH);

    topCtx.fillStyle="#d98200";
    drawFoot(topCtx, pumpX + 12,         pumpY - pumpH/2 - fh - 2, fw, fh, false);
    drawFoot(topCtx, pumpX + pumpW - 28, pumpY - pumpH/2 - fh - 2, fw, fh, false);
    drawFoot(topCtx, pumpX + 12,         pumpY + pumpH/2 + 2,      fw, fh, false);
    drawFoot(topCtx, pumpX + pumpW - 28, pumpY + pumpH/2 + 2,      fw, fh, false);

    topCtx.fillStyle="#eaf1ff";
    topCtx.font="12px Arial";
    topCtx.textAlign="center";
    topCtx.fillText("Pompe (fixe)", pumpX + pumpW/2, pumpY - pumpH/2 - 14);

    // Moteur (mobile) avec rotation + translation
    const cx = motorX0 + motorW/2;
    const cy = motorY0;

    topCtx.save();
    topCtx.translate(cx + dx, cy);
    topCtx.rotate(ang);
    topCtx.translate(-cx, -cy);

    // corps moteur
    topCtx.fillStyle="#00a2ff";
    topCtx.fillRect(motorX0, motorY0 - motorH/2, motorW, motorH);

    // pieds moteur (HL = soft foot highlight)
    // positions: haut = avant, bas = arrière (vue de dessus)
    topCtx.fillStyle="#0086d6";
    drawFoot(topCtx, motorX0 + 12,         motorY0 - motorH/2 - fh - 2, fw, fh, activeFoot==="FL");
    drawFoot(topCtx, motorX0 + motorW - 28, motorY0 - motorH/2 - fh - 2, fw, fh, activeFoot==="FR");
    drawFoot(topCtx, motorX0 + 12,         motorY0 + motorH/2 + 2,      fw, fh, activeFoot==="RL");
    drawFoot(topCtx, motorX0 + motorW - 28, motorY0 + motorH/2 + 2,      fw, fh, activeFoot==="RR");

    // arbres + coupling (important: espace)
    const shaftY = motorY0;
    const motorShaftEndX = motorX0 + motorW;
    const pumpShaftStartX = pumpX;

    // arbre moteur vers coupling
    topCtx.strokeStyle="rgba(255,255,255,.60)";
    topCtx.lineWidth=3;
    topCtx.beginPath();
    topCtx.moveTo(motorShaftEndX, shaftY);
    topCtx.lineTo(motorShaftEndX + gap*0.35, shaftY);
    topCtx.stroke();

    // arbre pompe depuis coupling
    topCtx.beginPath();
    topCtx.moveTo(pumpShaftStartX - gap*0.35, pumpY);
    topCtx.lineTo(pumpShaftStartX, pumpY);
    topCtx.stroke();

    // coupling au centre du gap
    const coupX = motorShaftEndX + gap/2;
    drawCoupling(topCtx, coupX, shaftY);

    // label moteur
    topCtx.fillStyle="#eaf1ff";
    topCtx.font="12px Arial";
    topCtx.textAlign="center";
    topCtx.fillText("Moteur (mobile)", motorX0 + motorW/2, motorY0 - motorH/2 - 14);

    topCtx.restore();

    // note bas
    topCtx.fillStyle="rgba(255,255,255,.80)";
    topCtx.font="12px Arial";
    topCtx.textAlign="left";
    topCtx.fillText(`Dessus: angH=${align.angH.toFixed(1)} mil, parH=${align.parH.toFixed(1)} mil (gain=${align.gain})`, 12, H - 12);
  }

  // ---------- DRAW SIDE VIEW (profil) ----------
  function drawSideView(activeFoot){
    const { W, H } = resizeCanvas(sideCanvas, sideCtx);
    clear(sideCtx, W, H);
    drawGrid(sideCtx, W, H);

    const midY  = H * 0.60;
    const baseX = 36;

    const unitLen = Math.min(170, (W - 120) * 0.44);
    const gap     = Math.min(110, (W - 120) * 0.22);

    const motorW = unitLen, motorH = 44;
    const pumpW  = unitLen, pumpH  = 44;

    const motorX0 = baseX;
    const pumpX   = baseX + motorW + gap;

    const g = align.gain;

    // vertical transforms
    const dy  = -align.parV * g;         // + monte => Y diminue
    const ang = -(align.angV * 0.0025);  // rotation profil

    // soft foot: on "descend" la patte sélectionnée (pédagogique)
    const sfVal = align.sf[activeFoot] ?? 0;
    const sfDrop = sfVal * g * 0.35;

    // pompe fixe
    const pumpY = midY;
    sideCtx.fillStyle="#ff9800";
    sideCtx.fillRect(pumpX, pumpY - pumpH/2, pumpW, pumpH);

    // pattes pompe (profil = 2 visibles)
    sideCtx.fillStyle="#d98200";
    const fw=22, fh=10;
    drawFoot(sideCtx, pumpX + 16,        pumpY + pumpH/2 + 2, fw, fh, false);
    drawFoot(sideCtx, pumpX + pumpW - 38, pumpY + pumpH/2 + 2, fw, fh, false);

    sideCtx.fillStyle="#eaf1ff";
    sideCtx.font="12px Arial";
    sideCtx.textAlign="center";
    sideCtx.fillText("Pompe (fixe)", pumpX + pumpW/2, pumpY - pumpH/2 - 14);

    // moteur (mobile)
    const motorY0 = midY + dy;
    const cx = motorX0 + motorW/2;
    const cy = motorY0;

    sideCtx.save();
    sideCtx.translate(cx, cy);
    sideCtx.rotate(ang);
    sideCtx.translate(-cx, -cy);

    sideCtx.fillStyle="#00a2ff";
    sideCtx.fillRect(motorX0, motorY0 - motorH/2, motorW, motorH);

    // profil = 2 pattes visibles (avant / arrière)
    // AV = FL/FR, AR = RL/RR
    const frontHighlight = (activeFoot==="FL" || activeFoot==="FR");
    const rearHighlight  = (activeFoot==="RL" || activeFoot==="RR");

    // si patte avant sélectionnée => on la "baisse" un peu
    const frontDrop = frontHighlight ? sfDrop : 0;
    const rearDrop  = rearHighlight  ? sfDrop : 0;

    sideCtx.fillStyle="#0086d6";
    drawFoot(sideCtx, motorX0 + 16,         motorY0 + motorH/2 + 2 + frontDrop, fw, fh, frontHighlight);
    drawFoot(sideCtx, motorX0 + motorW - 38, motorY0 + motorH/2 + 2 + rearDrop,  fw, fh, rearHighlight);

    // arbres + coupling (profil)
    const motorShaftEndX = motorX0 + motorW;
    const shaftY = motorY0;

    sideCtx.strokeStyle="rgba(255,255,255,.60)";
    sideCtx.lineWidth=3;

    // arbre moteur -> coupling
    sideCtx.beginPath();
    sideCtx.moveTo(motorShaftEndX, shaftY);
    sideCtx.lineTo(motorShaftEndX + gap*0.35, shaftY);
    sideCtx.stroke();

    // arbre pompe -> coupling
    sideCtx.beginPath();
    sideCtx.moveTo(pumpX - gap*0.35, pumpY);
    sideCtx.lineTo(pumpX, pumpY);
    sideCtx.stroke();

    // coupling au centre
    const coupX = motorShaftEndX + gap/2;
    drawCoupling(sideCtx, coupX, shaftY);

    sideCtx.fillStyle="#eaf1ff";
    sideCtx.font="12px Arial";
    sideCtx.textAlign="center";
    sideCtx.fillText("Moteur (mobile)", motorX0 + motorW/2, motorY0 - motorH/2 - 14);

    sideCtx.restore();

    sideCtx.fillStyle="rgba(255,255,255,.80)";
    sideCtx.font="12px Arial";
    sideCtx.textAlign="left";
    sideCtx.fillText(`Profil: angV=${align.angV.toFixed(1)} mil, parV=${align.parV.toFixed(1)} mil (gain=${align.gain})`, 12, H - 12);
  }

  // ---------- Badges + résumé ----------
  function updateUI(){
    // soft foot calc
    const pb = calculPiedBoiteuxSimple(align.sf.FL, align.sf.FR, align.sf.RL, align.sf.RR);
    const sfActive = getActiveSoftFoot(pb);

    // 1 voilage
    setBadge(b1, Math.abs(align.runout) <= align.runoutTol ? "ok" : "bad",
      (Math.abs(align.runout) <= align.runoutTol) ? "OK" : "À corriger");

    // 2 soft foot
    setBadge(b2, sfActive.val <= align.sfTol ? "ok" : "bad",
      (sfActive.val <= align.sfTol) ? "OK" : "À corriger");

    // 3 ang V
    setBadge(b3, Math.abs(align.angV) <= align.angVTol ? "ok" : "bad",
      (Math.abs(align.angV) <= align.angVTol) ? "OK" : "À corriger");

    // 4 par V
    setBadge(b4, Math.abs(align.parV) <= align.parVTol ? "ok" : "bad",
      (Math.abs(align.parV) <= align.parVTol) ? "OK" : "À corriger");

    // 5 ang H
    setBadge(b5, Math.abs(align.angH) <= align.angHTol ? "ok" : "bad",
      (Math.abs(align.angH) <= align.angHTol) ? "OK" : "À corriger");

    // 6 par H
    setBadge(b6, Math.abs(align.parH) <= align.parHTol ? "ok" : "bad",
      (Math.abs(align.parH) <= align.parHTol) ? "OK" : "À corriger");

    // résumé très simple (débutant)
    const lines = [];
    lines.push(`Étape 1 (Voilage): ${align.runout.toFixed(1)} mil (tol ${align.runoutTol.toFixed(1)})`);
    lines.push(`Étape 2 (Soft foot): patte ${sfActive.foot} = ${sfActive.val.toFixed(1)} mil (tol ${align.sfTol.toFixed(1)})`);
    lines.push(`Étape 3 (Angulaire V): ${align.angV.toFixed(1)} mil`);
    lines.push(`Étape 4 (Parallèle V): ${align.parV.toFixed(1)} mil`);
    lines.push(`Étape 5 (Angulaire H): ${align.angH.toFixed(1)} mil`);
    lines.push(`Étape 6 (Parallèle H): ${align.parH.toFixed(1)} mil`);
    lines.push("");
    lines.push("Conseil atelier:");
    lines.push("• Corrige d’abord l’ANGULAIRE (V puis H), ensuite le PARALLÈLE (V puis H).");
    lines.push("• Le dessin exagère l’effet pour être visible.");

    kpi.textContent = lines.join("\n");

    // dessins
    drawTopView(sfActive.foot);
    drawSideView(sfActive.foot);
  }

  function render(){
    syncFromInputs();
    updateUI();
  }

  function resetValues(){
    runout.value="0.8"; runoutTol.value="2.0";
    sfFL.value="2.0"; sfFR.value="1.0"; sfRL.value="0.5"; sfRR.value="3.5";
    sfTol.value="3.0"; sfFoot.value="auto";
    angV.value="0.0"; angVTol.value="1.0";
    parV.value="0.0"; parVTol.value="1.0";
    angH.value="0.0"; angHTol.value="1.0";
    parH.value="0.0"; parHTol.value="1.0";
    gain.value="25";
    render();
  }

  // events
  const allInputs = [
    runout, runoutTol,
    sfFL, sfFR, sfRL, sfRR, sfTol, sfFoot,
    angV, angVTol,
    parV, parVTol,
    angH, angHTol,
    parH, parHTol,
    gain
  ];
  allInputs.forEach(x=>{
    x.addEventListener("input", render, {passive:true});
    x.addEventListener("change", render, {passive:true});
  });
  btnReset.addEventListener("click", resetValues);

  window.addEventListener("resize", render);
  if(window.visualViewport){ window.visualViewport.addEventListener("resize", render); }

  render();
})();
</script>

<!-- =================== MODAL INFO =================== -->
<div id="infoModal" class="infoModal hidden" aria-hidden="true">
  <div class="infoBox">
    <h2 style="margin:0;">ℹ️ Explications (très simple)</h2>

    <div class="infoScroll">
      <details open>
        <summary>Comparateur inversé – idée</summary>
        <div>
          <p>On mesure un <b>défaut</b> en mils. Ensuite on corrige le moteur.</p>
          <p><b>Important</b> : on corrige toujours <b>l’angulaire avant le parallèle</b>.</p>
        </div>
      </details>

      <details>
        <summary>Ordre obligatoire</summary>
        <div>
          <p>1) Voilage → 2) Pied boiteux → 3) Angulaire V → 4) Parallèle V → 5) Angulaire H → 6) Parallèle H</p>
          <p>Si tu changes l’ordre, tu risques de corriger « la mauvaise chose ».</p>
        </div>
      </details>

      <details>
        <summary>Pied boiteux (soft foot)</summary>
        <div>
          <p>Tu entres la valeur de chaque patte (MAX–MIN). L’app colore la patte la plus problématique.</p>
          <p>En vrai : on ajoute/enlève des <b>cales (shims)</b>, puis on revérifie.</p>
        </div>
      </details>

      <details>
        <summary>Angulaire vs Parallèle (différence)</summary>
        <div>
          <p><b>Angulaire</b> : le moteur <b>penche</b> (pivote) → le dessin montre une inclinaison.</p>
          <p><b>Parallèle</b> : le moteur reste <b>droit</b> mais il est <b>décalé</b> (haut/bas ou gauche/droite).</p>
        </div>
      </details>

      <details>
        <summary>Accouplement et arbres</summary>
        <div>
          <p>On garde un <b>espace</b> entre les machines pour représenter l’accouplement et les arbres.</p>
        </div>
      </details>
    </div>

    <div class="btnRow" style="margin-top:10px;">
      <button id="closeInfoBtn" class="secondary" type="button">Fermer</button>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const infoBtn = document.getElementById("infoBtn");
  const infoModal = document.getElementById("infoModal");
  const closeBtn = document.getElementById("closeInfoBtn");
  if(!infoBtn || !infoModal || !closeBtn) return;

  const open = () => { infoModal.classList.remove("hidden"); infoModal.setAttribute("aria-hidden","false"); };
  const close = () => { infoModal.classList.add("hidden"); infoModal.setAttribute("aria-hidden","true"); };

  infoBtn.addEventListener("click", open);
  closeBtn.addEventListener("click", close);
  infoModal.addEventListener("click", (e)=>{ if(e.target === infoModal) close(); });
});
</script>

</body>
</html>