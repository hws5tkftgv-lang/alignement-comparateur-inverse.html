<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Alignement">
<title>Alignement â€“ Comparateur inversÃ© (mils)</title>

<style>
:root{
  --bg:#0b1436;
  --card:#121c4a;
  --text:#eaf1ff;
  --muted:rgba(234,241,255,.75);
  --ok:#4caf50;
  --bad:#ff5252;
  --accent:#00a2ff;
}
*{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
html,body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:Arial,system-ui,sans-serif;
}

/* ===== HEADER ===== */
.headerBar{
  position:sticky;
  top:0;
  z-index:50;
  background:linear-gradient(to bottom, rgba(11,20,54,.98), rgba(11,20,54,.88));
  border-bottom:1px solid rgba(255,255,255,.08);
  padding:12px;
  text-align:center;
  font-weight:900;
  font-size:16px;
}

/* ===== LAYOUT ===== */
.wrap{
  padding:12px;
  max-width:1100px;
  margin:0 auto;
}
.grid{
  display:grid;
  gap:12px;
}
@media (min-width:900px){
  .grid{ grid-template-columns:1fr 1fr; }
}

/* ===== CARDS ===== */
.card{
  background:var(--card);
  border-radius:14px;
  padding:12px;
  border:1px solid rgba(255,255,255,.06);
}
h2{
  margin:0 0 8px;
  font-size:15px;
}
p{
  margin:6px 0;
  font-size:13px;
  color:var(--muted);
}

/* ===== Ã‰TAPES ===== */
.step{
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:12px;
  background:rgba(255,255,255,.03);
}
.stepHead{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:6px;
}
.stepTitle{
  font-weight:900;
  font-size:14px;
}
.badge{
  font-size:12px;
  font-weight:900;
  padding:4px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
}
.badge.ok{ background:rgba(76,175,80,.15); }
.badge.bad{ background:rgba(255,82,82,.15); }

/* ===== INPUTS ===== */
.row{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
}
@media(max-width:420px){
  .row{ grid-template-columns:1fr; }
}
label{
  font-size:12px;
  color:var(--muted);
}
input{
  width:100%;
  padding:10px;
  font-size:16px;
  border-radius:12px;
  border:none;
}

/* ===== NAV ===== */
.navRow{
  display:flex;
  gap:10px;
  margin-top:10px;
}
button{
  flex:1;
  padding:12px;
  font-size:16px;
  border:none;
  border-radius:12px;
  background:var(--accent);
  color:#fff;
  font-weight:900;
}
button.secondary{
  background:rgba(255,255,255,.15);
}

/* ===== CANVAS ===== */
.canvasGrid{
  display:grid;
  gap:12px;
}
@media(min-width:900px){
  .canvasGrid{ grid-template-columns:1fr 1fr; }
}
.canvasCard{
  background:#000;
  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.10);
}
.canvasHeader{
  padding:8px 12px;
  font-size:13px;
  font-weight:900;
  background:rgba(0,0,0,.35);
}
canvas{
  width:100%;
  height:260px;
  display:block;
}
@media(min-width:900px){
  canvas{ height:320px; }
}

/* ===== INFO ===== */
.infoBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.2);
  font-size:12px;
  white-space:pre-line;
}
/* ===== FORMULES (PC seulement) ===== */
.formulaBox{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.25);
  font-size:13px;
  font-family:Consolas, monospace;
  line-height:1.45;
  white-space:pre-line;
  display:none; /* cachÃ© par dÃ©faut (mobile) */
}
@media (min-width:900px){
  .formulaBox{ display:block; } /* visible PC */
}

.c-blue{ border:2px solid #00a2ff !important; }
.c-green{ border:2px solid #4caf50 !important; }
.c-orange{ border:2px solid #ff9800 !important; }



</style>
</head>

<body>

<div class="headerBar">
  Alignement dâ€™arbres â€” Comparateur inversÃ© (mils)
</div>

<div class="wrap">
  <div class="grid">

    <!-- ===== Ã‰TAPES ===== -->
    <div class="card">
      <h2>Ã‰tapes dâ€™alignement</h2>

      <div class="step" id="stepCard">
  <div class="stepHead">
    <div class="stepTitle" id="stepTitle">â€”</div>
    <div class="badge" id="stepBadge">Info</div>
  </div>

  <!-- Inputs gÃ©nÃ©rÃ©s par JS selon l'Ã©tape -->
  <div id="inputsArea"></div>
  <div id="formulaBox" class="formulaBox"></div>

  <div class="navRow">
    <button class="secondary" id="btnPrev" type="button">â—€ PrÃ©cÃ©dent</button>
    <button id="btnNext" type="button">Suivant â–¶</button>
  </div>

  <div class="infoBox" id="infoBox">â€”</div>
</div>
    </div>

    <!-- ===== DESSINS ===== -->
    <div class="card">
      <h2>Dessins pÃ©dagogiques</h2>
      <p>
Vue de dessus (horizontal) et vue de profil (vertical).
Les pattes A / B / C / D seront affichÃ©es ici.
      </p>

      <div class="canvasGrid">
        <div class="canvasCard">
          <div class="canvasHeader">Vue de dessus (TopView)</div>
          <canvas id="topView"></canvas>
        </div>
        <div class="canvasCard">
          <div class="canvasHeader">Vue de profil (SideView)</div>
          <canvas id="sideView"></canvas>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
"use strict";
let currentView = "top"; // "top" | "side"
let blinkPhase = true;
setInterval(() => {
  blinkPhase = !blinkPhase;

  // âš ï¸ JAMAIS toucher Ã  lâ€™UI ici
  drawTopView();
  drawSideView();
}, 600);

/* =====================================================
   Ã‰TAT GLOBAL (mils)
===================================================== */
const state = {
  step: 0,
  measureStep: 0,
  
  runout: 0,
  runoutTol: 2,

  softFoot: { A:0, B:0, C:0, D:0 },
  softFootTol: 3,

  angV: 0,
  angVTol: 1,

  parV: 0,
  parVTol: 1,

  angH: 0,
  angHTol: 1,

  parH: 0,
  parHTol: 1
};
/* =====================================================
   PARAMÃˆTRES GÃ‰OMÃ‰TRIQUES (pouces)
===================================================== */
const geometry = {
  couplingDiameter: 3,      // Ã˜ accouplement
  centerToFrontFeet: 6,    // Centre â†’ pattes AVANT
  frontToRearFeet: 10      // Pattes AVANT â†’ ARRIÃˆRE
};
/* =====================================================
   DÃ‰FINITION DES Ã‰TAPES
===================================================== */
const STEPS = [
  { id:"runout",  label:"1 â€” Voilage" },
  { id:"softfoot",label:"2 â€” Pied boiteux" },
  { id:"measures",label:"3 â€” Mesures gÃ©omÃ©triques" },   // â† AJOUT
  { id:"angV",    label:"4 â€” AngularitÃ© verticale" },
  { id:"angH",    label:"5 â€” AngularitÃ© horizontale" },
  { id:"parH",    label:"6 â€” ParallÃ©lisme horizontal" }
];
/* =====================================================
   UTILITAIRES
===================================================== */
const abs = Math.abs;
const ok = (v,t) => abs(v) <= t;

/* =====================================================
   PIED BOITEUX â€” DIAGONALES
   AC vs BD
===================================================== */
function computeSoftFoot(){
  const {A,B,C,D} = state.softFoot;
  const diagAC = A + C;
  const diagBD = B + D;
  const delta = abs(diagAC - diagBD);
  const correction = delta * 0.8;

  let faulty = null;
  if(diagAC > diagBD) faulty = ["A","C"];
  if(diagBD > diagAC) faulty = ["B","D"];

  return {
    diagAC,
    diagBD,
    delta,
    correction,
    faulty
  };
}

/* =====================================================
   ANGULARITÃ‰ VERTICALE â€” PAIRES
   Avant = BC
   ArriÃ¨re = AD
===================================================== */
function computeAngularVertical(){
  if(state.angV > 0){
    return { pair:["A","D"], direction:"ARRIÃˆRE trop bas" };
  }
  if(state.angV < 0){
    return { pair:["B","C"], direction:"AVANT trop bas" };
  }
  return null;
}

/* =====================================================
   PARALLÃ‰LISME VERTICAL â€” 4 PATTES
===================================================== */
function computeParallelVertical(){
  if(state.parV !== 0){
    return { pair:["A","B","C","D"], direction:"Moteur trop bas" };
  }
  return null;
}

/* =====================================================
   ANGULARITÃ‰ HORIZONTALE â€” TOP VIEW
===================================================== */
function computeAngularHorizontal(){
  if(state.angH > 0){
    return { pair:["B","D"], direction:"InclinÃ© droite" };
  }
  if(state.angH < 0){
    return { pair:["A","C"], direction:"InclinÃ© gauche" };
  }
  return null;
}

/* =====================================================
   PARALLÃ‰LISME HORIZONTAL â€” PAIRES
===================================================== */
function computeParallelHorizontal(){
  if(state.parH > 0){
    return { pair:["A","B"], direction:"DÃ©calÃ© droite" };
  }
  if(state.parH < 0){
    return { pair:["D","C"], direction:"DÃ©calÃ© gauche" };
  }
  return null;
}
/* =====================================================
   CALCUL CORRECTION ANGULAIRE (mils rÃ©els)
   B Ã— C / A
===================================================== */
function computeAngularShim(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const C = Math.abs(state.angV); // lecture cadran (mils)

  if(A <= 0) return 0;

  return (B * C) / A;
}

function computeAngularShimH(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const C = Math.abs(state.angH); // lecture cadran horizontale (mils)

  if(A <= 0) return 0;
  return (B * C) / A;
}



function computeAngularShimsVertical(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const D = geometry.frontToRearFeet;
  const C = Math.abs(state.angV);

  if(A <= 0) return { front:0, rear:0 };

  return {
    front: (B * C) / A,
    rear: ((B + D) * C) / A
  };
}

function computeAngularShimsHorizontal(){
  const A = geometry.couplingDiameter;
  const B = geometry.centerToFrontFeet;
  const D = geometry.frontToRearFeet;
  const C = Math.abs(state.angH);

  if(A <= 0) return { front:0, rear:0 };

  return {
    front: (B * C) / A,
    rear: ((B + D) * C) / A
  };
}
/* =====================================================
   VALIDATION PAR Ã‰TAPE
===================================================== */
function isStepOK(step){
  const id = STEPS[step].id;

  if(id === "measures"){
    // toujours OK (ou tu peux exiger valeurs > 0)
    return geometry.couplingDiameter > 0 && geometry.centerToFrontFeet > 0 && geometry.frontToRearFeet > 0;
  }

  switch(step){
    case 0: return ok(state.runout, state.runoutTol);
    case 1: return computeSoftFoot().delta <= state.softFootTol;
    case 2: return ok(state.angV, state.angVTol);
    case 3: return ok(state.parV, state.parVTol);
    case 4: return ok(state.angH, state.angHTol);
    case 5: return ok(state.parH, state.parHTol);
    default: return true;
  }
}
/* =====================================================
   MESSAGE TEXTE (ZONE INFO)
===================================================== */
function buildMessage(){
  const step = STEPS[state.step];
  let txt = `Ã‰tape ${step.label}\n\n`;

  if(!isStepOK(state.step)){
    txt += "âš ï¸ Hors tolÃ©rance\n\n";
  }else{
    txt += "âœ… Dans la tolÃ©rance\n\n";
  }

  if(step.id === "softfoot"){
    const sf = computeSoftFoot();
    txt += `Diag AC = ${sf.diagAC}\n`;
    txt += `Diag BD = ${sf.diagBD}\n`;
    txt += `Î” = ${sf.delta}\n`;
    txt += `Correction â‰ˆ ${sf.correction}\n`;
    if(sf.faulty){
      txt += `Pattes Ã  corriger : ${sf.faulty.join(" + ")}`;
    }
  }

  return txt;
}


/* =====================================================
   UI â€” DOM
===================================================== */
const ui = {
  stepTitle: document.getElementById("stepTitle"),
  stepBadge: document.getElementById("stepBadge"),
  inputsArea: document.getElementById("inputsArea"),
  infoBox: document.getElementById("infoBox"),
  btnPrev: document.getElementById("btnPrev"),
  btnNext: document.getElementById("btnNext"),
    formulaBox: document.getElementById("formulaBox"),
};

/* =====================================================
   MESSAGES DE CORRECTION PÃ‰DAGOGIQUES
===================================================== */
function buildCorrectionMessage(){
  const stepId = STEPS[state.step].id;
  let msg = "";

  // ---------- PIED BOITEUX ----------
  if(stepId === "softfoot"){
    const sf = computeSoftFoot();
    if(sf.delta <= state.softFootTol){
      return "âœ”ï¸ Pied boiteux corrigÃ© â€” aucune cale requise.";
    }

    const each = (sf.correction / 2).toFixed(1);
    msg += "ðŸ¦¶ Pied boiteux dÃ©tectÃ©\n\n";
    msg += `âž• Ajouter **+${each} mil** sous les pattes :\n`;
    msg += `ðŸ‘‰ ${sf.faulty.join(" + ")}\n`;
    msg += "\nâš ï¸ Toujours corriger en DIAGONALE";
    return msg;
  }

  // ---------- ANGULARITÃ‰ VERTICALE ----------
  // ---------- ANGULARITÃ‰ VERTICALE ----------
if(stepId === "angV"){
  if(ok(state.angV, state.angVTol)){
    return "âœ”ï¸ AngularitÃ© verticale conforme.";
  }

  const r = computeAngularVertical();
  const shims = computeAngularShimsVertical();

  const front = shims.front.toFixed(2);
  const rear  = shims.rear.toFixed(2);

  msg += "ðŸ“ AngularitÃ© verticale\n\n";
  msg += "âž• Ajouter des cales :\n";
  msg += `â€¢ AVANT : **${front} mil**\n`;
  msg += `â€¢ ARRIÃˆRE : **${rear} mil**\n\n`;
  msg += "Sous les pattes :\n";
  msg += `ðŸ‘‰ ${r.pair.join(" + ")}\n`;
  msg += `(${r.direction})`;

  return msg;
}

  // ---------- PARALLÃ‰LISME VERTICAL ----------
  if(stepId === "parV"){
    if(ok(state.parV, state.parVTol)){
      return "âœ”ï¸ ParallÃ©lisme vertical conforme.";
    }

    msg += "â¬†ï¸ ParallÃ©lisme vertical\n\n";
    msg += "âž• Ajouter des cales sous :\n";
    msg += "ðŸ‘‰ A + B + C + D\n";
    msg += "(montÃ©e uniforme du moteur)";
    return msg;
  }

  // ---------- ANGULARITÃ‰ HORIZONTALE ----------
  if(stepId === "angH"){
    if(ok(state.angH, state.angHTol)){
      return "âœ”ï¸ AngularitÃ© horizontale conforme.";
    }

    const r = computeAngularHorizontal();
const shims = computeAngularShimsHorizontal();

const front = shims.front.toFixed(2);
const rear  = shims.rear.toFixed(2);

msg += "â†”ï¸ AngularitÃ© horizontale\n\n";
msg += `â€¢ AVANT : **${front} mil**\n`;
msg += `â€¢ ARRIÃˆRE : **${rear} mil**\n\n`;
msg += "CÃ´tÃ© :\n";
msg += `ðŸ‘‰ ${r.pair.join(" + ")}\n`;
msg += `(${r.direction})`;

return msg;
}

  // ---------- PARALLÃ‰LISME HORIZONTAL ----------
  if(stepId === "parH"){
    if(ok(state.parH, state.parHTol)){
      return "âœ”ï¸ ParallÃ©lisme horizontal conforme.";
    }

    const r = computeParallelHorizontal();
    msg += "â†”ï¸ ParallÃ©lisme horizontal\n\n";
    msg += "âž• DÃ©placer le moteur cÃ´tÃ© :\n";
    msg += `ðŸ‘‰ ${r.pair.join(" + ")}\n`;
    msg += `(${r.direction})`;
    return msg;
  }

  return "";
}




/* =====================================================
   UI â€” Inputs par Ã©tape (avec IDs)
===================================================== */
function renderInputsForCurrentStep(){
  const id = STEPS[state.step].id;

  // IMPORTANT: valeurs par dÃ©faut = 0, tolÃ©rances â‰  0
  if(id === "runout"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Voilage (mils)</label>
          <input id="in_runout" type="number" step="0.1" value="${state.runout}">
        </div>
        <div>
          <label>TolÃ©rance (mils)</label>
          <input id="in_runoutTol" type="number" step="0.1" value="${state.runoutTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_runout", v => state.runout = v],
      ["in_runoutTol", v => state.runoutTol = Math.max(0, v)],
    ]);
    return;
  }

  if(id === "softfoot"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Patte A (haut gauche)</label>
          <input id="in_sfA" type="number" step="0.1" value="${state.softFoot.A}">
        </div>
        <div>
          <label>Patte B (haut droite)</label>
          <input id="in_sfB" type="number" step="0.1" value="${state.softFoot.B}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Patte C (bas droite)</label>
          <input id="in_sfC" type="number" step="0.1" value="${state.softFoot.C}">
        </div>
        <div>
          <label>Patte D (bas gauche)</label>
          <input id="in_sfD" type="number" step="0.1" value="${state.softFoot.D}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>TolÃ©rance soft foot (mils)</label>
          <input id="in_sfTol" type="number" step="0.1" value="${state.softFootTol}">
        </div>
        <div>
          <label>Note</label>
          <input disabled value="La plus grande diagonale est affichÃ©e (soft foot seulement)">
        </div>
      </div>
    `;
    wireInputs([
      ["in_sfA", v => state.softFoot.A = Math.abs(v)],
      ["in_sfB", v => state.softFoot.B = Math.abs(v)],
      ["in_sfC", v => state.softFoot.C = Math.abs(v)],
      ["in_sfD", v => state.softFoot.D = Math.abs(v)],
      ["in_sfTol", v => state.softFootTol = Math.max(0, v)],
    ]);
    return;
  }

if(id === "measures"){

  let html = "";

  // ===== SOUS-Ã‰TAPE 1 â€” Ã˜ ACCOUPLEMENT =====
  if(state.measureStep === 0){
    html = `
      <div class="row">
        <div>
          <label style="color:#00a2ff;">Ã˜ accouplement (po)</label>
          <input id="in_diam" class="c-blue" type="number" step="0.1"
                 value="${geometry.couplingDiameter}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <input disabled value="Mesurer le diamÃ¨tre extÃ©rieur de lâ€™accouplement">
        </div>
      </div>
    `;
  }

  // ===== SOUS-Ã‰TAPE 2 â€” CENTRE â†’ AVANT =====
  if(state.measureStep === 1){
    html = `
      <div class="row">
        <div>
          <label style="color:#4caf50;">Centre â†’ pattes AVANT (po)</label>
          <input id="in_centerFront" class="c-green" type="number" step="0.1"
                 value="${geometry.centerToFrontFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <input disabled value="Mesurer du centre de lâ€™accouplement jusquâ€™aux pattes avant du moteur">
        </div>
      </div>
    `;
  }

  // ===== SOUS-Ã‰TAPE 3 â€” AVANT â†’ ARRIÃˆRE =====
  if(state.measureStep === 2){
    html = `
      <div class="row">
        <div>
          <label style="color:#ff9800;">Pattes AVANT â†’ ARRIÃˆRE (po)</label>
          <input id="in_frontRear" class="c-orange" type="number" step="0.1"
                 value="${geometry.frontToRearFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Instruction</label>
          <input disabled value="Mesurer la distance entre pattes avant et arriÃ¨re du moteur">
        </div>
      </div>
    `;
  }

  ui.inputsArea.innerHTML = html;

  if(state.measureStep === 0){
    wireInputs([["in_diam", v => geometry.couplingDiameter = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 1){
    wireInputs([["in_centerFront", v => geometry.centerToFrontFeet = Math.max(0.1, v)]]);
  }

  if(state.measureStep === 2){
    wireInputs([["in_frontRear", v => geometry.frontToRearFeet = Math.max(0.1, v)]]);
  }

  return;
}

  // =====================================================
  // ANGULARITÃ‰ VERTICALE
  // =====================================================
  if(id === "angV"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Lecture cadran 12â€“6 (mils)</label>
          <input id="in_angV" type="number" step="0.1" value="${state.angV}">
        </div>
        <div>
          <label>TolÃ©rance (mils)</label>
          <input id="in_angVTol" type="number" step="0.1" value="${state.angVTol}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Ã˜ accouplement (po)</label>
          <input id="in_diam" type="number" step="0.1" value="${geometry.couplingDiameter}">
        </div>
        <div>
          <label>Centre â†’ pattes AVANT (po)</label>
          <input id="in_centerFront" type="number" step="0.1" value="${geometry.centerToFrontFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Pattes AVANT â†’ ARRIÃˆRE (po)</label>
          <input id="in_frontRear" type="number" step="0.1" value="${geometry.frontToRearFeet}">
        </div>
        <div>
          <label>Note</label>
          <input disabled value="Correction rÃ©elle aux pattes (mils)">
        </div>
      </div>
    `;

    wireInputs([
      ["in_angV", v => state.angV = v],
      ["in_angVTol", v => state.angVTol = Math.max(0, v)],
      ["in_diam", v => geometry.couplingDiameter = Math.max(0.1, v)],
      ["in_centerFront", v => geometry.centerToFrontFeet = Math.max(0.1, v)],
      ["in_frontRear", v => geometry.frontToRearFeet = Math.max(0.1, v)],
    ]);
    return;
  }

  // =====================================================
  // ANGULARITÃ‰ HORIZONTALE
  // =====================================================
  if(id === "angH"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>Lecture cadran 3â€“9 (mils)</label>
          <input id="in_angH" type="number" step="0.1" value="${state.angH}">
        </div>
        <div>
          <label>TolÃ©rance (mils)</label>
          <input id="in_angHTol" type="number" step="0.1" value="${state.angHTol}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Ã˜ accouplement (po)</label>
          <input id="in_diam" type="number" step="0.1" value="${geometry.couplingDiameter}">
        </div>
        <div>
          <label>Centre â†’ pattes AVANT (po)</label>
          <input id="in_centerFront" type="number" step="0.1" value="${geometry.centerToFrontFeet}">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>Pattes AVANT â†’ ARRIÃˆRE (po)</label>
          <input id="in_frontRear" type="number" step="0.1" value="${geometry.frontToRearFeet}">
        </div>
        <div>
          <label>Note</label>
          <input disabled value="Correction rÃ©elle aux pattes (mils)">
        </div>
      </div>
    `;

    wireInputs([
      ["in_angH", v => state.angH = v],
      ["in_angHTol", v => state.angHTol = Math.max(0, v)],
      ["in_diam", v => geometry.couplingDiameter = Math.max(0.1, v)],
      ["in_centerFront", v => geometry.centerToFrontFeet = Math.max(0.1, v)],
      ["in_frontRear", v => geometry.frontToRearFeet = Math.max(0.1, v)],
    ]);
    return;
  }

  if(id === "parH"){
    ui.inputsArea.innerHTML = `
      <div class="row">
        <div>
          <label>ParallÃ©lisme horizontal (mils)</label>
          <input id="in_parH" type="number" step="0.1" value="${state.parH}">
        </div>
        <div>
          <label>TolÃ©rance (mils)</label>
          <input id="in_parHTol" type="number" step="0.1" value="${state.parHTol}">
        </div>
      </div>
    `;
    wireInputs([
      ["in_parH", v => state.parH = v],
      ["in_parHTol", v => state.parHTol = Math.max(0, v)],
    ]);
    return;
  }
}
function buildFormulaSoftFoot(){
  const sf = computeSoftFoot();

  // Valeurs entrÃ©es
  const A = state.softFoot.A;
  const B = state.softFoot.B;
  const C = state.softFoot.C;
  const D = state.softFoot.D;

  // Calculs
  const diagAC = sf.diagAC;
  const diagBD = sf.diagBD;
  const delta  = sf.delta;

  const corr   = sf.correction;      // 80% du delta
  const each   = corr / 2;           // rÃ©parti sur 2 pattes

  // Quelle diagonale est fautive?
  let faultyTxt = "Aucune (diagonales Ã©gales)";
  if(sf.faulty) faultyTxt = sf.faulty.join(" + ");

  return (
`Pied boiteux â€” Diagonales

Diag AC = A + C
       = ${A} + ${C}
       = ${diagAC.toFixed(2)} mil

Diag BD = B + D
       = ${B} + ${D}
       = ${diagBD.toFixed(2)} mil

Î” = |Diag AC âˆ’ Diag BD|
  = |${diagAC.toFixed(2)} âˆ’ ${diagBD.toFixed(2)}|
  = ${delta.toFixed(2)} mil

Correction â‰ˆ 0.8 Ã— Î”
          = 0.8 Ã— ${delta.toFixed(2)}
          = ${corr.toFixed(2)} mil

Par patte (2 pattes) = Correction / 2
                     = ${corr.toFixed(2)} / 2
                     = ${each.toFixed(2)} mil

Pattes Ã  corriger : ${faultyTxt}`
  );
}

/* =====================================================
   Wire inputs (lecture -> state -> redraw)
===================================================== */
function wireInputs(pairs){
  pairs.forEach(([inputId, setter]) => {
    const input = document.getElementById(inputId);
    if(!input) return;

    // Autoriser la saisie libre sans calcul immÃ©diat
    input.addEventListener("input", () => {
      // Ne rien faire ici â†’ saisie fluide
    });

    // Validation sur ENTER
    input.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        input.blur();   // force validation
      }
    });

    // Validation finale quand on quitte le champ
    input.addEventListener("blur", () => {
      let raw = input.value.trim();

      if(raw === ""){
        raw = "0";
        input.value = "0";
      }

      const v = parseFloat(raw);
      setter(Number.isFinite(v) ? v : 0);

      refreshUI();
      drawTopView();
      drawSideView();
    });
  });
}
/* =====================================================
   UI sync
===================================================== */
function refreshUI(){
  ui.stepTitle.textContent = `Ã‰tape ${STEPS[state.step].label}`;

  const okNow = isStepOK(state.step);
  ui.stepBadge.textContent = okNow ? "OK" : "NOT OK";
  ui.stepBadge.classList.toggle("ok", okNow);
  ui.stepBadge.classList.toggle("bad", !okNow);

  renderInputsForCurrentStep();

  ui.infoBox.textContent =
    buildMessage() + "\n\n" + buildCorrectionMessage();

  // ===== FORMULES (PC) â€” Ã‰TAPE 2 SEULEMENT =====
  if(ui.formulaBox){
    if(STEPS[state.step].id === "softfoot"){
      ui.formulaBox.textContent = buildFormulaSoftFoot();
    }else{
      ui.formulaBox.textContent = "";
    }
  }
}
/* =====================================================
   Navigation
===================================================== */
function nextStep(){
  // Sous-Ã©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep < 2){
      state.measureStep++;
      renderAll();
      return;
    }else{
      state.measureStep = 0;
      state.step++;
      renderAll();
      return;
    }
  }

  if(isStepOK(state.step) && state.step < STEPS.length - 1){
    state.step++;
    renderAll();
  }
}

function prevStep(){
  // Sous-Ã©tapes de "measures"
  if(STEPS[state.step].id === "measures"){
    if(state.measureStep > 0){
      state.measureStep--;
      renderAll();
      return;
    }else{
      // revenir Ã  l'Ã©tape prÃ©cÃ©dente
      state.step--;
      renderAll();
      return;
    }
  }

  if(state.step > 0){
    state.step--;
    renderAll();
  }
}
ui.btnPrev.addEventListener("click", prevStep);
ui.btnNext.addEventListener("click", nextStep);
/* =====================================================
   BLOC 3 â€” DESSINS & SYNCHRO
===================================================== */

const topCanvas = document.getElementById("topView");
const sideCanvas = document.getElementById("sideView");
const topCtx = topCanvas.getContext("2d");
const sideCtx = sideCanvas.getContext("2d");

function resizeCanvas(canvas, ctx){
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return { w, h };
}

/* =====================================================
   UTILITAIRES DESSIN
===================================================== */
function clear(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,w,h);
}

function drawDimOnly(ctx, x1, x2, y){
  ctx.beginPath();
  ctx.moveTo(x1, y);
  ctx.lineTo(x2, y);
  ctx.stroke();

  // petites barres aux extrÃ©mitÃ©s
  ctx.beginPath();
  ctx.moveTo(x1, y - 8);
  ctx.lineTo(x1, y + 8);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x2, y - 8);
  ctx.lineTo(x2, y + 8);
  ctx.stroke();
}



function drawShimValue(ctx, x, y, value){
  if(value <= 0) return;

  ctx.fillStyle = "#ff5252";
  ctx.font = blinkPhase ? "bold 13px Arial" : "12px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`+${value.toFixed(2)} mil`, x + 14, y + 4);
}

function isBlinking(){
  return blinkPhase ? "#ff5252" : "#000";
}
function footColor(letter){
  const step = STEPS[state.step].id;
  const bad = !isStepOK(state.step);

  // âŒ Soft foot jamais en Side View
  if(step === "softfoot" && currentView === "side"){
    return "#00a2ff";
  }

  if(step === "softfoot"){
    const sf = computeSoftFoot();
    if(bad && sf.faulty && sf.faulty.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "angV"){
    const r = computeAngularVertical();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "parV" && bad){
    return isBlinking();
  }

  if(step === "angH"){
    const r = computeAngularHorizontal();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  if(step === "parH"){
    const r = computeParallelHorizontal();
    if(bad && r && r.pair.includes(letter)){
      return isBlinking();
    }
  }

  return "#00a2ff";
}

function drawFoot(ctx,x,y,label){
  ctx.fillStyle = footColor(label);
  ctx.fillRect(x-10,y-5,20,10);
  ctx.fillStyle="#fff";
  ctx.font="12px Arial";
  ctx.textAlign="center";
  ctx.fillText(label,x,y+18);
}
function drawDimLine(ctx, x1, x2, y, label){
  const left = Math.min(x1, x2);
  const right = Math.max(x1, x2);

  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.fillStyle   = "rgba(255,255,255,.90)";
  ctx.lineWidth = 2;

  // ligne principale
  ctx.beginPath();
  ctx.moveTo(left, y);
  ctx.lineTo(right, y);
  ctx.stroke();

  // "ticks" aux extrÃ©mitÃ©s
  ctx.beginPath();
  ctx.moveTo(left, y-8);  ctx.lineTo(left, y+8);
  ctx.moveTo(right, y-8); ctx.lineTo(right, y+8);
  ctx.stroke();

  // texte centrÃ©
  ctx.font = "12px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText(label, (left + right)/2, y - 10);

  ctx.restore();
}

function drawCouplingDiameter(ctx, cx, cy, diam){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,.85)";
  ctx.lineWidth = 2;

  // petit cercle indicatif (pas Ã  l'Ã©chelle)
  ctx.beginPath();
  ctx.arc(cx, cy, 18, 0, Math.PI*2);
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,.90)";
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "middle";
  ctx.fillText(`Ã˜ = ${diam} po`, cx + 24, cy);

  ctx.restore();
}



/* =====================================================
   TOP VIEW
===================================================== */
function drawTopView(){
  currentView = "top";
  const {w,h} = resizeCanvas(topCanvas,topCtx);
  clear(topCtx,w,h);

  const cx = w*0.35;
  const cy = h*0.5;

  // moteur
  topCtx.fillStyle="#00a2ff";
  topCtx.fillRect(cx-80,cy-40,160,80);

  // pattes (ordre demandÃ©)
// haut gauche -> A ; haut droite -> B ; bas gauche -> D ; bas droite -> C
// --- PATTES TOP VIEW (4 rectangles visibles) ---
// Positions coins (inchangÃ©es)
const P = {
  A:{x:cx-70, y:cy-30},
  B:{x:cx+70, y:cy-30},
  D:{x:cx-70, y:cy+30},
  C:{x:cx+70, y:cy+30},
};

// Dessiner les petites pattes (rectangles)
function drawPad(letter){
  const {x,y} = P[letter];
  const offsetY = (letter === "C" || letter === "D") ? 10 : -10;

  const faulty = footColor(letter) !== "#00a2ff";

  topCtx.fillStyle = footColor(letter);
  topCtx.fillRect(
    x - (faulty ? 14 : 12),
    y + offsetY - (faulty ? 7 : 6),
    faulty ? 28 : 24,
    faulty ? 14 : 12
  );
}
drawPad("A"); drawPad("B"); drawPad("D"); drawPad("C");

// --- LETTRES TOP VIEW (zone noire, PAS dans le moteur) ---
topCtx.fillStyle = "#fff";
topCtx.font = "14px Arial";
topCtx.textAlign = "center";

// A & B : AU-DESSUS du moteur
topCtx.fillText("A", P.A.x, P.A.y - 18);
topCtx.fillText("B", P.B.x, P.B.y - 18);

// C & D : EN DESSOUS du moteur
topCtx.fillText("D", P.D.x, P.D.y + 28);
topCtx.fillText("C", P.C.x, P.C.y + 28);
  // pompe
  topCtx.fillStyle="#ff9800";
  topCtx.fillRect(cx+120,cy-40,160,80);

  topCtx.fillStyle="#fff";
  topCtx.font="13px Arial";
  topCtx.textAlign="center";
  topCtx.fillText("MOTEUR (mobile)", cx, cy-110);
topCtx.fillText("POMPE (fixe)",    cx+200, cy-110);

  if(STEPS[state.step].id === "softfoot"){
  const sf = computeSoftFoot();

  // === 1) Diagonale fautive (UNE SEULE) ===
  topCtx.strokeStyle = "#ff5252";
  topCtx.lineWidth = 2;
  topCtx.beginPath();

  if(sf.diagAC >= sf.diagBD){
    // 1 -> 3  (A -> C)
    topCtx.moveTo(P.A.x, P.A.y);
    topCtx.lineTo(P.C.x, P.C.y);
  }else{
    // 2 -> 4  (B -> D)
    topCtx.moveTo(P.B.x, P.B.y);
    topCtx.lineTo(P.D.x, P.D.y);
  }

  topCtx.stroke();

  // === 2) RÃ©partition 80 % sur la diagonale fautive ===
  const shimEach = sf.correction / 2;
  const shim = { A:0, B:0, C:0, D:0 };

  if(sf.diagAC > sf.diagBD){
    shim.A = shimEach;
    shim.C = shimEach;
  }
  else if(sf.diagBD > sf.diagAC){
    shim.B = shimEach;
    shim.D = shimEach;
  }

  // === 3) Affichage des valeurs prÃ¨s des pattes ===
  function drawShimText(letter, x, y){
    const v = shim[letter];
    if(v <= 0) return;
    topCtx.fillStyle = "#ff5252";
    topCtx.font = blinkPhase ? "bold 13px Arial" : "12px Arial";
    topCtx.textAlign = "left";
    topCtx.fillText(`+${v.toFixed(1)} mil`, x + 14, y + 4);
  }

  drawShimText("A", P.A.x, P.A.y);
  drawShimText("B", P.B.x, P.B.y);
  drawShimText("C", P.C.x, P.C.y);
  drawShimText("D", P.D.x, P.D.y);
}
}

function drawDimLine(ctx, x1, x2, y, label){
  ctx.strokeStyle = "rgba(255,255,255,.8)";
  ctx.lineWidth = 1.5;

  // ligne principale
  ctx.beginPath();
  ctx.moveTo(x1, y);
  ctx.lineTo(x2, y);
  ctx.stroke();

  // traits verticaux
  ctx.beginPath();
  ctx.moveTo(x1, y-6); ctx.lineTo(x1, y+6);
  ctx.moveTo(x2, y-6); ctx.lineTo(x2, y+6);
  ctx.stroke();

  // texte
  ctx.fillStyle = "#fff";
  ctx.font = "12px Arial";
  ctx.textAlign = "center";
  ctx.fillText(label, (x1+x2)/2, y-10);
}

function drawCouplingDiameter(ctx, x, y, d){
  const r = 18;
  ctx.strokeStyle = "rgba(255,255,255,.8)";
  ctx.lineWidth = 1.5;

  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.stroke();

  ctx.fillStyle = "#fff";
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`Ã˜ = ${d} po`, x + 26, y + 4);
}



/* =====================================================
   SIDE VIEW
===================================================== */
function drawSideView(){

  const canvas = ui.sideCanvas;
  const ctx = canvas.getContext("2d");

  const w = canvas.width;
  const h = canvas.height;

  ctx.clearRect(0,0,w,h);

  const cx = w * 0.40;
  const cy = h * 0.50;

  const motorLength = 160;
  const motorHeight = 60;
  const pumpLength  = 110;
  const pumpHeight  = 60;

  const frontFootX = cx + 70;
  const rearFootX  = cx - 70;

  const motorRight = cx + motorLength/2;
  const pumpLeft   = motorRight + 40;
  const couplingX  = (motorRight + pumpLeft) / 2;

  // ==============================
  // MOTEUR
  // ==============================
  ctx.fillStyle="#00a2ff";
  ctx.fillRect(cx-motorLength/2, cy-motorHeight/2, motorLength, motorHeight);

  // pattes moteur
  ctx.fillRect(frontFootX-14, cy+motorHeight/2, 28, 10);
  ctx.fillRect(rearFootX-14,  cy+motorHeight/2, 28, 10);

  // ==============================
  // POMPE
  // ==============================
  ctx.fillStyle="#ff9800";
  ctx.fillRect(pumpLeft, cy-pumpHeight/2, pumpLength, pumpHeight);

  // ==============================
  // ACCOUPLEMENT
  // ==============================
  ctx.strokeStyle="#ffffff";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.arc(couplingX, cy, 22, 0, Math.PI*2);
  ctx.stroke();

  // ==============================
  // TEXTE DE BASE
  // ==============================
  ctx.fillStyle="#ffffff";
  ctx.font="13px Arial";
  ctx.textAlign="center";
  ctx.fillText("MOTEUR (mobile)", cx, cy-motorHeight/2-12);
  ctx.fillText("POMPE (fixe)", pumpLeft+pumpLength/2, cy-pumpHeight/2-12);

  // =====================================================
  // MODE NORMAL â†’ PAS L'Ã‰TAPE MESURES
  // =====================================================
  if(STEPS[state.step].id !== "measures"){

    ctx.strokeStyle="rgba(255,255,255,0.35)";
    ctx.lineWidth=1;

    drawDimOnly(ctx, couplingX, frontFootX, cy+85);
    drawDimOnly(ctx, frontFootX, rearFootX,  cy+105);

    return;
  }

  // =====================================================
  // MODE MESURES GUIDÃ‰ES â€” UNE SEULE COTE
  // =====================================================
  ctx.lineWidth = 3;

  // 0 = Ã˜ accouplement (BLEU)
  if(state.measureStep === 0){
    ctx.strokeStyle = "#00a2ff";
    ctx.beginPath();
    ctx.arc(couplingX, cy, 24, 0, Math.PI*2);
    ctx.stroke();
  }

  // 1 = Centre â†’ pattes AVANT (VERT)
  if(state.measureStep === 1){
    ctx.strokeStyle = "#4caf50";
    drawDimOnly(ctx, couplingX, frontFootX, cy+95);
  }

  // 2 = Pattes AVANT â†’ ARRIÃˆRE (ORANGE)
  if(state.measureStep === 2){
    ctx.strokeStyle = "#ff9800";
    drawDimOnly(ctx, frontFootX, rearFootX, cy+95);
  }
}

/* =====================================================
   RENDER GLOBAL
===================================================== */
function renderAll(){
  refreshUI();
  drawTopView();
  drawSideView();
}


renderAll();
</script>




</body>
</html>